use once_cell::sync::Lazy;
use std::collections::BTreeSet;
use std::collections::HashMap;
use std::collections::hash_map::Entry;
use std::collections::HashSet;
use std::collections::VecDeque;
use std::io;
use std::path::{Path, PathBuf};
use std::rc::{Rc, Weak};
use std::sync::Arc;
use std::sync::mpsc::Sender;
use std::sync::Mutex;
use std::sync::atomic::AtomicBool;
use std::sync::atomic::AtomicU64;
use std::sync::atomic::Ordering;
use std::sync::OnceLock;
use std::time::{Duration, Instant, SystemTime};
use std::fs;
use std::process::{Command, Output};
use std::str::FromStr;
use base64::prelude::{Engine as _, BASE64_STANDARD};

use ratatui::style::{Modifier, Style};
use crate::header_wave::HeaderWaveEffect;
use crate::auto_drive_strings;
use crate::auto_drive_style::AutoDriveVariant;
use crate::spinner;
use crate::thread_spawner;

use code_common::elapsed::format_duration;
use code_common::model_presets::builtin_model_presets;
use code_common::model_presets::clamp_reasoning_effort_for_model;
use code_common::model_presets::ModelPreset;
use code_core::agent_defaults::{agent_model_spec, enabled_agent_model_specs};
use code_core::smoke_test_agent_blocking;
use code_core::config::Config;
use code_core::git_info::CommitLogEntry;
use code_core::config_types::AgentConfig;
use code_core::config_types::AutoDriveContinueMode;
use code_core::config_types::Notifications;
use code_core::config_types::ReasoningEffort;
use code_core::config_types::TextVerbosity;
use code_core::spawn::spawn_std_command_with_retry;
use code_core::plan_tool::{PlanItemArg, StepStatus, UpdatePlanArgs};
use code_core::model_family::derive_default_model_family;
use code_core::model_family::find_family_for_model;
use code_core::account_usage::{
    self,
    RateLimitWarningScope,
    StoredRateLimitSnapshot,
    StoredUsageSummary,
    TokenTotals,
};
use code_core::auth_accounts::{self, StoredAccount};
use code_login::AuthManager;
use code_login::AuthMode;
use code_protocol::mcp_protocol::AuthMode as McpAuthMode;
use code_protocol::protocol::SessionSource;
use code_protocol::num_format::format_with_separators;
use code_core::split_command_and_args;
use serde_json::Value as JsonValue;
use crate::weave;
use crate::weave_client;
use crate::weave_client::{WeaveAgent, WeaveAgentConnection, WeaveIncomingMessage, WeaveSession};


mod diff_handlers;
mod agent_summary;
mod esc;
mod modals;
mod agent_install;
mod diff_ui;
mod exec_tools;
mod gh_actions;
mod history_render;
mod help_handlers;
mod settings_handlers;
mod settings_overlay;
mod limits_overlay;
mod interrupts;
mod layout_scroll;
mod message;
mod perf;
mod rate_limit_refresh;
mod streaming;
mod terminal_handlers;
mod terminal;
mod tools;
mod browser_sessions;
mod agent_runs;
mod web_search_sessions;
mod auto_drive_cards;
pub(crate) mod tool_cards;
mod running_tools;
#[cfg(any(test, feature = "test-helpers"))]
pub mod smoke_helpers;

#[cfg(test)]
pub(crate) use self::esc::EscIntent;
use self::agent_summary::agent_summary_counts;
use self::esc::AutoGoalEscState;
use self::agent_install::{
    start_agent_install_session,
    start_direct_terminal_session,
    start_prompt_terminal_session,
    start_upgrade_terminal_session,
    wrap_command,
};
use code_auto_drive_core::{
    start_auto_coordinator,
    AutoCoordinatorCommand,
    AutoCoordinatorEvent,
    AutoCoordinatorEventSender,
    AutoCoordinatorHandle,
    AutoCoordinatorStatus,
    AutoDriveHistory,
    AutoDriveController,
    AutoRunSummary,
    AutoRunPhase,
    AutoControllerEffect,
    AutoTurnAgentsAction,
    AutoTurnAgentsTiming,
    AutoTurnCliAction,
    AutoTurnReviewState,
    AutoResolveState,
    AutoResolvePhase,
    AUTO_RESOLVE_REVIEW_FOLLOWUP,
    CoordinatorContext,
    CoordinatorRouterResponse,
    route_user_message,
    TurnConfig,
    TurnDescriptor,
};
use self::limits_overlay::{LimitsOverlayContent, LimitsTab};
use crate::chrome_launch::ChromeLaunchOption;
use crate::insert_history::word_wrap_lines;
use self::rate_limit_refresh::{
    start_rate_limit_refresh,
    start_rate_limit_refresh_for_account,
};
use self::history_render::{
    CachedLayout, HistoryRenderState, RenderRequest, RenderRequestKind, RenderSettings, VisibleCell,
};
use code_core::parse_command::ParsedCommand;
use code_core::{AutoDriveMode, AutoDrivePidFile};
use code_core::TextFormat;
use code_core::protocol::AgentMessageDeltaEvent;
use code_core::protocol::ApprovedCommandMatchKind;
use code_core::protocol::AskForApproval;
use code_core::protocol::SandboxPolicy;
use code_core::protocol::AgentSourceKind;
use code_core::protocol::AgentMessageEvent;
use code_core::protocol::AgentReasoningDeltaEvent;
use code_core::protocol::AgentReasoningEvent;
use code_core::protocol::AgentReasoningRawContentDeltaEvent;
use code_core::protocol::AgentReasoningRawContentEvent;
use code_core::protocol::AgentReasoningSectionBreakEvent;
use code_core::protocol::AgentStatusUpdateEvent;
use code_core::protocol::ApplyPatchApprovalRequestEvent;
use code_core::protocol::BackgroundEventEvent;
use code_core::protocol::BrowserScreenshotUpdateEvent;
use code_core::protocol::BrowserSnapshotEvent;
use code_core::protocol::CustomToolCallBeginEvent;
use code_core::protocol::CustomToolCallEndEvent;
use code_core::protocol::ErrorEvent;
use code_core::protocol::Event;
use code_core::protocol::EventMsg;
use code_core::protocol::ExecApprovalRequestEvent;
use code_core::protocol::ExecCommandBeginEvent;
use code_core::protocol::ExecCommandEndEvent;
use code_core::protocol::ExecOutputStream;
use code_core::protocol::EnvironmentContextDeltaEvent;
use code_core::protocol::EnvironmentContextFullEvent;
use code_core::protocol::InputItem;
use code_core::protocol::SessionConfiguredEvent;
// MCP tool call handlers moved into chatwidget::tools
use code_core::protocol::Op;
use code_core::protocol::ReviewOutputEvent;
use code_core::protocol::{ReviewContextMetadata, ReviewRequest};
use code_core::protocol::PatchApplyBeginEvent;
use code_core::protocol::PatchApplyEndEvent;
use code_core::protocol::TaskCompleteEvent;
use code_core::protocol::TokenUsage;
use code_core::protocol::TurnDiffEvent;
use code_core::protocol::ViewImageToolCallEvent;
use code_core::review_coord::{bump_snapshot_epoch_for, try_acquire_lock, ReviewGuard};
use code_core::ConversationManager;
use code_core::codex::compact::COMPACTION_CHECKPOINT_MESSAGE;
use crate::bottom_pane::{
    AutoActiveViewModel,
    AutoCoordinatorButton,
    AutoCoordinatorViewModel,
    CountdownState,
    AgentHintLabel, AutoReviewFooterStatus, AutoReviewPhase,
    prompts_settings_view::PromptsSettingsView,
    skills_settings_view::SkillsSettingsView,
    McpSettingsView,
    ModelSelectionView,
    NotificationsMode,
    NotificationsSettingsView,
    SettingsSection,
    ThemeSelectionView,
    agent_editor_view::AgentEditorView,
    AutoDriveSettingsView,
    PlanningSettingsView,
    UpdateSettingsView,
    ReviewSettingsView,
    ValidationSettingsView,
    prompt_args,
};
use crate::bottom_pane::agents_settings_view::SubagentEditorView;
use crate::bottom_pane::mcp_settings_view::{McpServerRow, McpServerRows};
use crate::exec_command::strip_bash_lc_and_escape;
#[cfg(feature = "code-fork")]
use crate::tui_event_extensions::handle_browser_screenshot;
use crate::chatwidget::message::UserMessage;
use crate::history::compat::{
    ContextBrowserSnapshotRecord,
    ContextDeltaField,
    ContextDeltaRecord,
    ContextRecord,
};

pub(crate) const DOUBLE_ESC_HINT: &str = "undo timeline";
const AUTO_ESC_EXIT_HINT: &str = "Press Esc again to exit Auto Drive";
const AUTO_COMPLETION_CELEBRATION_DURATION: Duration = Duration::from_secs(5);
const HISTORY_ANIMATION_FRAME_INTERVAL: Duration = Duration::from_millis(120);
const AUTO_BOOTSTRAP_GOAL_PLACEHOLDER: &str = "Deriving goal from recent conversation";
const AUTO_DRIVE_SESSION_SUMMARY_NOTICE: &str = "Summarizing session";
const AUTO_DRIVE_SESSION_SUMMARY_PROMPT: &str =
    include_str!("../prompt_for_auto_drive_session_summary.md");
const CONTEXT_DELTA_HISTORY: usize = 10;

struct MergeRepoState {
    git_root: PathBuf,
    worktree_path: PathBuf,
    worktree_branch: String,
    worktree_sha: String,
    worktree_status: String,
    worktree_dirty: bool,
    worktree_status_ok: bool,
    worktree_diff_summary: Option<String>,
    repo_status: String,
    repo_dirty: bool,
    repo_status_ok: bool,
    default_branch: Option<String>,
    default_branch_exists: bool,
    repo_head_branch: Option<String>,
    repo_has_in_progress_op: bool,
    fast_forward_possible: bool,
}

impl MergeRepoState {
    async fn gather(worktree_path: PathBuf, git_root: PathBuf) -> Result<Self, String> {
        use tokio::process::Command;

        let worktree_branch = match Command::new("git")
            .current_dir(&worktree_path)
            .args(["rev-parse", "--abbrev-ref", "HEAD"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => {
                String::from_utf8_lossy(&out.stdout).trim().to_string()
            }
            _ => {
                return Err("failed to detect worktree branch name".to_string());
            }
        };

        let worktree_sha = match Command::new("git")
            .current_dir(&worktree_path)
            .args(["rev-parse", "--short", "HEAD"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => {
                let sha = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if sha.is_empty() {
                    "unknown".to_string()
                } else {
                    sha
                }
            }
            _ => "unknown".to_string(),
        };

        let worktree_status_raw = ChatWidget::git_short_status(&worktree_path).await;
        let (worktree_status, worktree_dirty, worktree_status_ok) =
            Self::normalize_status(worktree_status_raw);
        let worktree_diff_summary = if worktree_dirty {
            ChatWidget::git_diff_stat(&worktree_path)
                .await
                .ok()
                .map(|d| d.trim().to_string())
                .filter(|d| !d.is_empty())
        } else {
            None
        };

        let branch_metadata = code_core::git_worktree::load_branch_metadata(&worktree_path);
        let mut default_branch = branch_metadata
            .as_ref()
            .and_then(|meta| meta.base_branch.clone());
        if default_branch.is_none() {
            default_branch = code_core::git_worktree::detect_default_branch(&git_root).await;
        }

        let repo_status_raw = ChatWidget::git_short_status(&git_root).await;
        let (repo_status, repo_dirty, repo_status_ok) = Self::normalize_status(repo_status_raw);

        let repo_head_branch = match Command::new("git")
            .current_dir(&git_root)
            .args(["rev-parse", "--abbrev-ref", "HEAD"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => {
                Some(String::from_utf8_lossy(&out.stdout).trim().to_string())
            }
            _ => None,
        };

        let (default_branch_exists, fast_forward_possible) =
            if let Some(ref default_branch) = default_branch {
                let exists = Command::new("git")
                    .current_dir(&git_root)
                    .args([
                        "rev-parse",
                        "--verify",
                        "--quiet",
                        &format!("refs/heads/{}", default_branch),
                    ])
                    .output()
                    .await
                    .map(|o| o.status.success())
                    .unwrap_or(false);
                let fast_forward = if exists {
                    Command::new("git")
                        .current_dir(&git_root)
                        .args([
                            "merge-base",
                            "--is-ancestor",
                            &format!("refs/heads/{}", default_branch),
                            &format!("refs/heads/{}", worktree_branch),
                        ])
                        .output()
                        .await
                        .map(|o| o.status.success())
                        .unwrap_or(false)
                } else {
                    false
                };
                (exists, fast_forward)
            } else {
                (false, false)
            };

        let git_dir = match Command::new("git")
            .current_dir(&git_root)
            .args(["rev-parse", "--git-dir"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => {
                let raw = String::from_utf8_lossy(&out.stdout).trim().to_string();
                let candidate = PathBuf::from(&raw);
                if candidate.is_absolute() {
                    candidate
                } else {
                    git_root.join(raw)
                }
            }
            _ => git_root.join(".git"),
        };
        let repo_has_in_progress_op = [
            "MERGE_HEAD",
            "rebase-apply",
            "rebase-merge",
            "CHERRY_PICK_HEAD",
            "BISECT_LOG",
        ]
        .iter()
        .any(|name| git_dir.join(name).exists());

        remember_worktree_root_hint(&worktree_path, &git_root);
        Ok(MergeRepoState {
            git_root,
            worktree_path,
            worktree_branch,
            worktree_sha,
            worktree_status,
            worktree_dirty,
            worktree_status_ok,
            worktree_diff_summary,
            repo_status,
            repo_dirty,
            repo_status_ok,
            default_branch,
            default_branch_exists,
            repo_head_branch,
            repo_has_in_progress_op,
            fast_forward_possible,
        })
    }

    fn normalize_status(result: Result<String, String>) -> (String, bool, bool) {
        match result {
            Ok(s) => {
                let trimmed = s.trim().to_string();
                if trimmed.is_empty() {
                    ("clean".to_string(), false, true)
                } else {
                    (trimmed, true, true)
                }
            }
            Err(err) => (format!("status unavailable: {}", err), true, false),
        }
    }

    fn snapshot_summary(&self) -> String {
        let worktree_state = if !self.worktree_status_ok {
            "unknown"
        } else if self.worktree_dirty {
            "dirty"
        } else {
            "clean"
        };
        let repo_state = if !self.repo_status_ok {
            "unknown"
        } else if self.repo_dirty {
            "dirty"
        } else {
            "clean"
        };
        format!(
            "`/merge` — repo snapshot: worktree '{}' ({}) → default '{}' ({}), fast-forward: {}",
            self.worktree_branch,
            worktree_state,
            self.default_branch_label(),
            repo_state,
            if self.fast_forward_possible { "yes" } else { "no" }
        )
    }

    fn auto_fast_forward_blockers(&self) -> Vec<String> {
        let mut reasons = Vec::new();
        if !self.worktree_status_ok {
            reasons.push("unable to read worktree status".to_string());
        }
        if self.worktree_dirty {
            reasons.push("worktree has uncommitted changes".to_string());
        }
        if !self.repo_status_ok {
            reasons.push("unable to read repo status".to_string());
        }
        if self.repo_dirty {
            reasons.push(format!(
                "{} checkout has uncommitted changes",
                self.default_branch_label()
            ));
        }
        if self.repo_has_in_progress_op {
            reasons.push(
                "default checkout has an in-progress merge/rebase/cherry-pick".to_string(),
            );
        }
        if self.default_branch.is_none() {
            reasons.push("default branch is unknown".to_string());
        }
        if self.default_branch.is_some() && !self.default_branch_exists {
            reasons.push(format!(
                "default branch '{}' missing locally",
                self.default_branch_label()
            ));
        }
        match (&self.repo_head_branch, &self.default_branch) {
            (Some(head), Some(default)) if head == default => {}
            (Some(head), Some(default)) => reasons.push(format!(
                "repo root is on '{}' instead of '{}'",
                head, default
            )),
            (Some(_), None) => reasons.push(
                "repo root branch detected but default branch is still unknown".to_string(),
            ),
            (None, _) => reasons.push("unable to detect branch currently checked out in repo root".to_string()),
        }
        if !self.fast_forward_possible {
            reasons.push("fast-forward merge is not possible".to_string());
        }
        reasons
    }

    fn default_branch_label(&self) -> String {
        self.default_branch
            .as_deref()
            .unwrap_or("default branch (determine before merging)")
            .to_string()
    }

    fn agent_preface(&self, reason_text: &str) -> String {
        let default_branch_line = self
            .default_branch
            .as_deref()
            .unwrap_or("unknown default branch (determine before merging)");
        let worktree_status = Self::format_status_for_context(&self.worktree_status);
        let repo_status = Self::format_status_for_context(&self.repo_status);
        let fast_forward_label = if self.fast_forward_possible { "yes" } else { "no" };
        let mut preface = format!(
            "[developer] Automation skipped because: {}. Finish the merge manually with the steps below.\n\nContext:\n- Worktree path (current cwd): {} — branch {} @ {}, status {}\n- Repo root path: {} — target {} checkout, status {}\n- Fast-forward possible: {}\n",
            reason_text,
            self.worktree_path.display(),
            self.worktree_branch,
            self.worktree_sha,
            worktree_status,
            self.git_root.display(),
            default_branch_line,
            repo_status,
            fast_forward_label,
        );
        preface.push_str(
            "\nNOTE: Each command runs in its own shell. Use `cd <path> && <command>` (or `git -C <path> ...`) whenever you need to operate in a different directory.\n",
        );
        preface.push_str(&format!(
            "\n1. Worktree prep (already in {} on {}):\n   - Review `git status`.\n   - Stage and commit every change that belongs in the merge. Use descriptive messages; no network commands and no resets.\n",
            self.worktree_path.display(),
            self.worktree_branch,
        ));
        preface.push_str(&format!(
            "   - When running commands here, prefix them with `cd {} && ...` (or use `git -C {}`) so they actually execute inside the worktree.\n",
            self.worktree_path.display(),
            self.worktree_path.display(),
        ));
        if let Some(ref default_branch) = self.default_branch {
            preface.push_str(&format!(
                "2. Default-branch checkout prep:\n   - cd {}\n   - If HEAD is not {}, run `git checkout {}`.\n   - If this checkout is dirty, stash with a clear message before continuing.\n",
                self.git_root.display(),
                default_branch,
                default_branch,
            ));
        } else {
            preface.push_str(&format!(
                "2. Default-branch checkout prep:\n   - cd {}\n   - Determine the correct default branch for this repo (metadata missing) and check it out.\n   - If this checkout is dirty, stash with a clear message before continuing.\n",
                self.git_root.display(),
            ));
        }
        preface.push_str(&format!(
            "   - Run these commands as `cd {} && ...` (or `git -C {}`) so they execute inside the repo root.\n",
            self.git_root.display(),
            self.git_root.display(),
        ));
        let default_branch_for_copy = self
            .default_branch
            .as_deref()
            .unwrap_or("the default branch you selected");
        preface.push_str(&format!(
            "3. Merge locally (still in {} on {}):\n   - Run `git merge --no-ff {}`.\n   - Resolve conflicts line by line; keep intent from both branches.\n   - No network commands, no `git reset --hard`, no `git checkout -- .`, no `git clean`, and no `-X ours/theirs`.\n   - WARNING: Do not delete files, rewrite them in full, or checkout/prefer commits from one branch over another. Instead use apply_patch to surgically resolve conflicts, even if they are large in scale. Work on each conflict, line by line, so both branches' changes survive.\n   - If you stashed in step 2, apply/pop it now and commit if needed.\n",
            self.git_root.display(),
            default_branch_for_copy,
            self.worktree_branch,
        ));
        preface.push_str(&format!(
            "4. Verify in {}:\n   - `git status` is clean.\n   - `git merge-base --is-ancestor {} HEAD` succeeds.\n   - No MERGE_HEAD/rebase/cherry-pick artifacts remain.\n",
            self.git_root.display(),
            self.worktree_branch,
        ));
        preface.push_str(&format!(
            "5. Cleanup:\n   - `git worktree remove {}` (only after verification).\n   - `git branch -D {}` in {} if the branch still exists.\n",
            self.worktree_path.display(),
            self.worktree_branch,
            self.git_root.display(),
        ));
        preface.push_str(
            "6. Report back with a concise command log and any conflicts you resolved.\n\nAbsolute rules: no network operations, no resets, no dropping local history, no blanket \"ours/theirs\" strategies.\n",
        );
        if let Some(diff) = &self.worktree_diff_summary {
            preface.push_str("\nWorktree diff summary:\n");
            preface.push_str(diff);
        }
        preface
    }

    fn format_status_for_context(status: &str) -> String {
        if status == "clean" {
            return "clean".to_string();
        }
        status
            .lines()
            .enumerate()
            .map(|(idx, line)| if idx == 0 { line.to_string() } else { format!("  {}", line) })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

async fn run_fast_forward_merge(state: &MergeRepoState) -> Result<(), String> {
    use tokio::process::Command;

    let merge = Command::new("git")
        .current_dir(&state.git_root)
        .args(["merge", "--ff-only", &state.worktree_branch])
        .output()
        .await
        .map_err(|err| format!("failed to run git merge --ff-only: {}", err))?;
    if !merge.status.success() {
        return Err(format!(
            "fast-forward merge failed: {}",
            describe_command_failure(&merge, "git merge --ff-only failed")
        ));
    }

    bump_snapshot_epoch_for(&state.git_root);

    let worktree_remove = Command::new("git")
        .current_dir(&state.git_root)
        .args(["worktree", "remove"])
        .arg(&state.worktree_path)
        .arg("--force")
        .output()
        .await
        .map_err(|err| format!("failed to remove worktree: {}", err))?;
    if !worktree_remove.status.success() {
        return Err(format!(
            "failed to remove worktree: {}",
            describe_command_failure(&worktree_remove, "git worktree remove failed")
        ));
    }

    let branch_delete = Command::new("git")
        .current_dir(&state.git_root)
        .args(["branch", "-D", &state.worktree_branch])
        .output()
        .await
        .map_err(|err| format!("failed to delete branch: {}", err))?;
    if !branch_delete.status.success() {
        return Err(format!(
            "failed to delete branch '{}': {}",
            state.worktree_branch,
            describe_command_failure(&branch_delete, "git branch -D failed")
        ));
    }

    Ok(())
}

fn describe_command_failure(out: &Output, fallback: &str) -> String {
    let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
    let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
    if !stderr_s.is_empty() {
        stderr_s
    } else if !stdout_s.is_empty() {
        stdout_s
    } else {
        fallback.to_string()
    }
}

impl ChatWidget<'_> {
    fn is_auto_review_agent(agent: &code_core::protocol::AgentInfo) -> bool {
        if matches!(agent.source_kind, Some(AgentSourceKind::AutoReview)) {
            return true;
        }
        if let Some(batch) = agent.batch_id.as_deref() {
            if batch.eq_ignore_ascii_case("auto-review") {
                return true;
            }
        }
        false
    }
    fn format_code_bridge_call(&self, args: &JsonValue) -> Option<String> {
        let action = args.get("action")?.as_str()?.to_lowercase();
        let mut out = String::from("Code Bridge\n");
        match action.as_str() {
            "subscribe" => {
                out.push_str("└ Subscribe");
                if let Some(level) = args.get("level").and_then(|v| v.as_str()) {
                    out.push_str(&format!("  level={}", level));
                }
                Some(out)
            }
            "screenshot" => {
                out.push_str("└ Screenshot");
                Some(out)
            }
            "javascript" => {
                out.push_str("└ JavaScript\n");
                if let Some(code) = args.get("code").and_then(|v| v.as_str()) {
                    out.push_str("   ```javascript\n");
                    out.push_str(code);
                    out.push_str("\n   ```");
                }
                Some(out)
            }
            _ => None,
        }
    }

    fn format_kill_call(&self, args: &JsonValue) -> Option<String> {
        if let Some(call_id) = args.get("call_id").and_then(|v| v.as_str()) {
            let mut out = String::from("Kill\n");
            out.push_str(&format!("└ call_id: {}", call_id));
            return Some(out);
        }
        None
    }

    fn format_tool_call_preview(&self, name: &str, arguments: &str) -> Option<String> {
        let parsed: JsonValue = serde_json::from_str(arguments).ok()?;
        match name {
            "code_bridge" => self.format_code_bridge_call(&parsed),
            "kill" => self.format_kill_call(&parsed),
            _ => None,
        }
    }

    fn browser_overlay_progress_line(
        &self,
        width: u16,
        current: Duration,
        total: Duration,
    ) -> Line<'static> {
        let width = width.max(20) as usize;
        let prefix = "▶ ";
        let suffix = format!(
            " {} / {}",
            self.format_overlay_mm_ss(current),
            self.format_overlay_mm_ss(total)
        );
        let slider_width = width
            .saturating_sub(prefix.len())
            .saturating_sub(suffix.chars().count())
            .max(5);

        let progress_ratio = if total.as_millis() == 0 {
            0.0
        } else {
            (current.as_secs_f64() / total.as_secs_f64()).clamp(0.0, 1.0)
        };
        let progress_cells = (progress_ratio * slider_width as f64).round() as usize;

        let mut slider = String::with_capacity(slider_width);
        let pointer_idx = if slider_width <= 1 {
            0
        } else {
            progress_cells.clamp(0, slider_width.saturating_sub(1))
        };
        for i in 0..slider_width {
            if i == pointer_idx {
                slider.push('◉');
            } else {
                slider.push('─');
            }
        }

        let mut spans: Vec<Span> = Vec::new();
        spans.push(Span::styled(prefix.to_string(), Style::default().fg(crate::colors::text())));
        spans.push(Span::styled(
            slider,
            Style::default()
                .fg(crate::colors::primary())
                .add_modifier(Modifier::BOLD),
        ));
        spans.push(Span::styled(
            suffix,
            Style::default().fg(crate::colors::text()),
        ));

        Line::from(spans)
    }

    fn format_overlay_mm_ss(&self, duration: Duration) -> String {
        let total_secs = duration.as_secs();
        let minutes = total_secs / 60;
        let seconds = total_secs % 60;
        format!("{:02}:{:02}", minutes, seconds)
    }

    fn normalize_action_time_label(&self, label: &str) -> String {
        if let Some((minutes, seconds)) = label.split_once('m') {
            let minutes = minutes.trim().parse::<u64>().unwrap_or(0);
            let seconds = seconds
                .trim()
                .trim_start_matches(char::is_whitespace)
                .trim_end_matches('s')
                .parse::<u64>()
                .unwrap_or(0);
            return format!("{:02}:{:02}", minutes, seconds);
        }
        if let Some(stripped) = label.strip_suffix('s') {
            if let Ok(seconds) = stripped.trim().parse::<u64>() {
                return format!("00:{:02}", seconds.min(59));
            }
        }
        label.to_string()
    }
}
use code_git_tooling::{
    create_ghost_commit,
    restore_ghost_commit,
    CreateGhostCommitOptions,
    GhostCommit,
    GitToolingError,
};
use crossterm::event::KeyEvent;
use crossterm::event::KeyEventKind;
use image::imageops::FilterType;
use ratatui::buffer::Buffer;
use ratatui::layout::Constraint;
use ratatui::layout::Layout;
use ratatui::layout::Rect;
use ratatui::text::Line;
use ratatui::widgets::Widget;
use ratatui::widgets::WidgetRef;
use ratatui_image::picker::Picker;
use std::cell::{Cell, RefCell};
use std::sync::mpsc;
use tokio::sync::mpsc::{unbounded_channel, UnboundedReceiver, UnboundedSender};
use tokio::task;
use uuid::Uuid;

fn history_cell_logging_enabled() -> bool {
    static ENABLED: OnceLock<bool> = OnceLock::new();
    if let Ok(value) = std::env::var("CODEX_TRACE_HISTORY") {
        let trimmed = value.trim();
        if !matches!(trimmed, "" | "0") {
            return true;
        }
    }
    *ENABLED.get_or_init(|| {
        if let Ok(value) = std::env::var("CODE_BUFFER_DIFF_TRACE_CELLS") {
            return !matches!(value.trim(), "" | "0");
        }
        if let Ok(value) = std::env::var("CODE_BUFFER_DIFF_METRICS") {
            return !matches!(value.trim(), "" | "0");
        }
        false
    })
}

pub(crate) fn is_test_mode() -> bool {
    #[cfg(any(test, feature = "test-helpers"))]
    {
        static FLAG: OnceLock<bool> = OnceLock::new();
        *FLAG.get_or_init(|| match std::env::var("CODE_TUI_TEST_MODE") {
            Ok(raw) => {
                let val = raw.trim().to_ascii_lowercase();
                matches!(val.as_str(), "1" | "true" | "yes" | "on")
            }
            Err(_) => true,
        })
    }
    #[cfg(not(any(test, feature = "test-helpers")))]
    {
        static FLAG: OnceLock<bool> = OnceLock::new();
        *FLAG.get_or_init(|| match std::env::var("CODE_TUI_TEST_MODE") {
            Ok(raw) => {
                let val = raw.trim().to_ascii_lowercase();
                matches!(val.as_str(), "1" | "true" | "yes" | "on")
            }
            Err(_) => false,
        })
    }
}
use serde_json;
use tracing::{debug, info, warn};
// use image::GenericImageView;

const TOKENS_PER_MILLION: f64 = 1_000_000.0;
const INPUT_COST_PER_MILLION_USD: f64 = 1.25;
const CACHED_INPUT_COST_PER_MILLION_USD: f64 = 0.125;
const OUTPUT_COST_PER_MILLION_USD: f64 = 10.0;
const STATUS_LABEL_INDENT: &str = "   ";
const STATUS_LABEL_TARGET_WIDTH: usize = 7;
const STATUS_LABEL_GAP: usize = 2;
const STATUS_CONTENT_PREFIX: &str = "    ";
const RESUME_PLACEHOLDER_MESSAGE: &str = "Resuming previous session...";
const RESUME_NO_HISTORY_NOTICE: &str =
    "No saved messages for this session. Start typing to continue.";
const ENABLE_WARP_STRIPES: bool = false;

fn auto_continue_from_config(mode: AutoDriveContinueMode) -> AutoContinueMode {
    match mode {
        AutoDriveContinueMode::Immediate => AutoContinueMode::Immediate,
        AutoDriveContinueMode::TenSeconds => AutoContinueMode::TenSeconds,
        AutoDriveContinueMode::SixtySeconds => AutoContinueMode::SixtySeconds,
        AutoDriveContinueMode::Manual => AutoContinueMode::Manual,
    }
}

fn auto_continue_to_config(mode: AutoContinueMode) -> AutoDriveContinueMode {
    match mode {
        AutoContinueMode::Immediate => AutoDriveContinueMode::Immediate,
        AutoContinueMode::TenSeconds => AutoDriveContinueMode::TenSeconds,
        AutoContinueMode::SixtySeconds => AutoDriveContinueMode::SixtySeconds,
        AutoContinueMode::Manual => AutoDriveContinueMode::Manual,
    }
}

fn status_field_prefix(label: &str) -> String {
    let padding = STATUS_LABEL_GAP
        .saturating_add(STATUS_LABEL_TARGET_WIDTH.saturating_sub(label.len()));
    format!(
        "{indent}{label}:{spaces}",
        indent = STATUS_LABEL_INDENT,
        label = label,
        spaces = " ".repeat(padding)
    )
}

fn status_content_prefix() -> String {
    STATUS_CONTENT_PREFIX.to_string()
}

fn describe_cloud_error(err: &CloudTaskError) -> String {
    match err {
        CloudTaskError::Msg(message) => message.clone(),
        other => other.to_string(),
    }
}

use crate::account_label::{account_display_label, account_mode_priority};
use crate::app_event::{
    AppEvent,
    AutoContinueMode,
    BackgroundPlacement,
    GitInitResume,
    ModelSelectionKind,
    TerminalAfter,
    TerminalCommandGate,
    TerminalLaunch,
    TerminalRunController,
};
use crate::app_event_sender::AppEventSender;
use crate::bottom_pane::CustomPromptView;
use crate::bottom_pane::list_selection_view::{ListSelectionView, SelectionItem};
use crate::bottom_pane::CloudTasksView;
use crate::bottom_pane::validation_settings_view;
use crate::bottom_pane::validation_settings_view::{GroupStatus, ToolRow};
use crate::bottom_pane::model_selection_view::ModelSelectionTarget;
use crate::bottom_pane::BottomPane;
use crate::bottom_pane::BottomPaneParams;
use crate::bottom_pane::{UndoTimelineEntry, UndoTimelineEntryKind, UndoTimelineView};
use crate::bottom_pane::CancellationEvent;
use crate::bottom_pane::InputResult;
use crate::bottom_pane::LoginAccountsState;
use crate::bottom_pane::LoginAccountsView;
use crate::bottom_pane::LoginAddAccountState;
use crate::bottom_pane::LoginAddAccountView;
use crate::bottom_pane::UpdateSharedState;
use crate::height_manager::HeightEvent;
use crate::height_manager::HeightManager;
use crate::history_cell;
use crate::history_cell::clean_wait_command;
#[cfg(target_os = "macos")]
use crate::agent_install_helpers::macos_brew_formula_for_command;
use crate::history_cell::ExecCell;
use crate::history_cell::FrozenHistoryCell;
use crate::history_cell::HistoryCell;
use crate::history_cell::HistoryCellType;
use crate::history_cell::PatchEventType;
use crate::history_cell::PlainHistoryCell;
use crate::history_cell::PlanUpdateCell;
use crate::history_cell::DiffCell;
use crate::history_cell::BrowserSessionCell;
use crate::history_cell::{AutoDriveActionKind, AutoDriveStatus};
use sha2::{Digest, Sha256};
use crate::history::state::PatchEventType as HistoryPatchEventType;
use crate::history::state::{
    AssistantMessageState,
    AssistantStreamDelta,
    AssistantStreamState,
    DiffLineKind,
    DiffRecord,
    ExecStatus,
    ExecWaitNote,
    HistoryDomainEvent,
    HistoryDomainRecord,
    HistoryId,
    HistoryRecord,
    HistoryMutation,
    HistorySnapshot,
    HistoryState,
    InlineSpan,
    MessageLine,
    MessageLineKind,
    MessageHeader,
    ImageRecord,
    PlainMessageKind,
    PlainMessageRole,
    PlainMessageState,
    MessageMetadata,
    OrderKeySnapshot,
    PatchFailureMetadata,
    PatchRecord,
    RateLimitLegendEntry,
    RateLimitsRecord,
    TextTone,
    TextEmphasis,
    ToolStatus,
};
use crate::cloud_tasks_service::CloudEnvironment;
use crate::sanitize::{sanitize_for_tui, Mode as SanitizeMode, Options as SanitizeOptions};
use crate::slash_command::{ProcessedCommand, SlashCommand};
use crate::live_wrap::RowBuilder;
use crate::streaming::StreamKind;
use crate::streaming::controller::AppEventHistorySink;
use crate::util::buffer::fill_rect;
use crate::user_approval_widget::ApprovalRequest;
use code_ansi_escape::ansi_escape_line;
pub(crate) use self::terminal::{
    PendingCommand,
    PendingCommandAction,
    PendingManualTerminal,
    TerminalOverlay,
    TerminalState,
};
use code_browser::BrowserManager;
use code_core::config::find_code_home;
use code_core::config::resolve_code_path_for_read;
use code_core::config::set_github_actionlint_on_patch;
use code_core::config::set_validation_group_enabled;
use code_core::config::set_validation_tool_enabled;
use code_file_search::FileMatch;
use code_cloud_tasks_client::{ApplyOutcome, CloudTaskError, CreatedTask, TaskSummary};
use code_protocol::models::ContentItem;
use code_protocol::models::ResponseItem;
use code_core::config_types::{validation_tool_category, ValidationCategory};
use code_core::protocol::RateLimitSnapshotEvent;
use code_core::protocol::ValidationGroup;
use crate::rate_limits_view::{
    build_limits_view, RateLimitDisplayConfig, RateLimitResetInfo, DEFAULT_DISPLAY_CONFIG,
    DEFAULT_GRID_CONFIG,
};
use crate::session_log;
use code_core::review_format::format_review_findings_block;
use chrono::{DateTime, Datelike, Duration as ChronoDuration, Local, TimeZone, Timelike, Utc};
use crossterm::event::KeyCode;
use crossterm::event::KeyModifiers;
use ratatui::style::Stylize;
use ratatui::symbols::scrollbar as scrollbar_symbols;
use ratatui::text::Span;
use ratatui::text::Text as RtText;
use textwrap::wrap;
use unicode_segmentation::UnicodeSegmentation;
use unicode_width::UnicodeWidthStr;
use ratatui::widgets::Block;
use ratatui::widgets::Borders;
use ratatui::widgets::Clear;
use ratatui::widgets::Paragraph;
use ratatui::widgets::Scrollbar;
use ratatui::widgets::ScrollbarOrientation;
use ratatui::widgets::ScrollbarState;
use ratatui::widgets::StatefulWidget;
use serde::Deserialize;
use serde::Serialize;

#[derive(Debug, Serialize, Deserialize)]
struct CachedConnection {
    port: Option<u16>,
    ws: Option<String>,
}

async fn read_cached_connection() -> Option<(Option<u16>, Option<String>)> {
    let code_home = find_code_home().ok()?;
    let path = resolve_code_path_for_read(&code_home, std::path::Path::new("cache.json"));
    let bytes = tokio::fs::read(path).await.ok()?;
    let parsed: CachedConnection = serde_json::from_slice(&bytes).ok()?;
    Some((parsed.port, parsed.ws))
}

async fn write_cached_connection(port: Option<u16>, ws: Option<String>) -> std::io::Result<()> {
    if port.is_none() && ws.is_none() {
        return Ok(());
    }
    if let Ok(code_home) = find_code_home() {
        let path = code_home.join("cache.json");
        let obj = CachedConnection { port, ws };
        let data = serde_json::to_vec_pretty(&obj).unwrap_or_else(|_| b"{}".to_vec());
        if let Some(dir) = path.parent() {
            let _ = tokio::fs::create_dir_all(dir).await;
        }
        tokio::fs::write(path, data).await?;
    }
    Ok(())
}

#[derive(Debug, Serialize, Deserialize, Default, Clone)]
struct WeavePrefs {
    #[serde(default)]
    profiles: HashMap<String, WeaveProfile>,
    // Legacy (v0) fields; retained for backwards compatibility during migration.
    agent_id: Option<String>,
    agent_name: Option<String>,
    agent_accent: Option<u8>,
}

#[derive(Debug, Serialize, Deserialize, Default, Clone)]
struct WeaveProfile {
    agent_id: Option<String>,
    agent_name: Option<String>,
    agent_accent: Option<u8>,
}

fn read_weave_prefs(code_home: &Path) -> WeavePrefs {
    let path = resolve_code_path_for_read(code_home, Path::new("weave.json"));
    let Ok(bytes) = std::fs::read(path) else {
        return WeavePrefs::default();
    };
    serde_json::from_slice(&bytes).unwrap_or_default()
}

async fn write_weave_prefs(code_home: &Path, prefs: &WeavePrefs) -> std::io::Result<()> {
    let path = code_home.join("weave.json");
    if let Some(dir) = path.parent() {
        let _ = tokio::fs::create_dir_all(dir).await;
    }
    // Best-effort merge to avoid clobbering other running Code instances.
    let mut merged = prefs.clone();
    if let Ok(existing_bytes) = tokio::fs::read(&path).await {
        if let Ok(existing) = serde_json::from_slice::<WeavePrefs>(&existing_bytes) {
            for (key, profile) in existing.profiles {
                merged.profiles.entry(key).or_insert(profile);
            }
        }
    }
    // Drop legacy fields once we start writing profiles to avoid sharing identities
    // across terminal instances.
    merged.agent_id = None;
    merged.agent_name = None;
    merged.agent_accent = None;

    let data = serde_json::to_vec_pretty(&merged).unwrap_or_else(|_| b"{}".to_vec());
    tokio::fs::write(path, data).await?;
    Ok(())
}

struct RunningCommand {
    command: Vec<String>,
    parsed: Vec<ParsedCommand>,
    // Index of the in-history Exec cell for this call, if inserted
    history_index: Option<usize>,
    history_id: Option<HistoryId>,
    // Aggregated exploration entry (history index, entry index) when grouped
    explore_entry: Option<(usize, usize)>,
    stdout_offset: usize,
    stderr_offset: usize,
    wait_total: Option<Duration>,
    wait_active: bool,
    wait_notes: Vec<(String, bool)>,
}

const RATE_LIMIT_WARNING_THRESHOLDS: [f64; 3] = [50.0, 75.0, 90.0];
const RATE_LIMIT_REFRESH_INTERVAL: chrono::Duration = chrono::Duration::minutes(10);

const MAX_TRACKED_GHOST_COMMITS: usize = 20;
const GHOST_SNAPSHOT_NOTICE_THRESHOLD: Duration = Duration::from_secs(4);
const GHOST_SNAPSHOT_TIMEOUT: Duration = Duration::from_secs(30);

#[derive(Clone)]
struct RateLimitWarning {
    scope: RateLimitWarningScope,
    threshold: f64,
    message: String,
}

#[derive(Default)]
struct RateLimitWarningState {
    weekly_index: usize,
    hourly_index: usize,
}

impl RateLimitWarningState {
    fn take_warnings(
        &mut self,
        secondary_used_percent: f64,
        primary_used_percent: f64,
    ) -> Vec<RateLimitWarning> {
        let mut warnings = Vec::new();

        let mut next_weekly_index = self.weekly_index;
        while next_weekly_index < RATE_LIMIT_WARNING_THRESHOLDS.len()
            && secondary_used_percent >= RATE_LIMIT_WARNING_THRESHOLDS[next_weekly_index]
        {
            next_weekly_index += 1;
        }
        if next_weekly_index > self.weekly_index {
            let threshold = RATE_LIMIT_WARNING_THRESHOLDS[next_weekly_index - 1];
            warnings.push(RateLimitWarning {
                scope: RateLimitWarningScope::Secondary,
                threshold,
                message: format!(
                    "Secondary usage exceeded {threshold:.0}% of the limit. Run /limits for detailed usage."
                ),
            });
            self.weekly_index = next_weekly_index;
        }

        let mut next_hourly_index = self.hourly_index;
        while next_hourly_index < RATE_LIMIT_WARNING_THRESHOLDS.len()
            && primary_used_percent >= RATE_LIMIT_WARNING_THRESHOLDS[next_hourly_index]
        {
            next_hourly_index += 1;
        }
        if next_hourly_index > self.hourly_index {
            let threshold = RATE_LIMIT_WARNING_THRESHOLDS[next_hourly_index - 1];
            warnings.push(RateLimitWarning {
                scope: RateLimitWarningScope::Primary,
                threshold,
                message: format!(
                    "Hourly usage exceeded {threshold:.0}% of the limit. Run /limits for detailed usage."
                ),
            });
            self.hourly_index = next_hourly_index;
        }

        warnings
    }

    fn reset(&mut self) {
        self.weekly_index = 0;
        self.hourly_index = 0;
    }
}

#[derive(Clone)]
struct GhostSnapshotsDisabledReason {
    message: String,
    hint: Option<String>,
}

#[derive(Clone, Copy)]
struct ConversationSnapshot {
    user_turns: usize,
    assistant_turns: usize,
    history_len: usize,
    order_len: usize,
    order_dbg_len: usize,
}

impl ConversationSnapshot {
    fn new(user_turns: usize, assistant_turns: usize) -> Self {
        Self {
            user_turns,
            assistant_turns,
            history_len: 0,
            order_len: 0,
            order_dbg_len: 0,
        }
    }
}

#[derive(Clone)]
pub(crate) struct GhostState {
    snapshots: Vec<GhostSnapshot>,
    disabled: bool,
    disabled_reason: Option<GhostSnapshotsDisabledReason>,
    queue: VecDeque<(u64, GhostSnapshotRequest)>,
    active: Option<(u64, GhostSnapshotRequest)>,
    next_id: u64,
    queued_user_messages: VecDeque<UserMessage>,
}

#[cfg(any(test, feature = "test-helpers"))]
#[allow(dead_code)]
struct AutoReviewCommitScope {
    commit: String,
    file_count: usize,
}

#[cfg(any(test, feature = "test-helpers"))]
#[allow(dead_code)]
enum AutoReviewOutcome {
    Skip,
    Workspace,
    Commit(AutoReviewCommitScope),
}

#[cfg(test)]
pub(super) type CaptureAutoTurnCommitStub = Box<
    dyn Fn(&'static str, Option<String>) -> Result<GhostCommit, GitToolingError> + Send + Sync,
>;

#[cfg(test)]
pub(super) static CAPTURE_AUTO_TURN_COMMIT_STUB: Lazy<Mutex<Option<CaptureAutoTurnCommitStub>>> =
    Lazy::new(|| Mutex::new(None));

#[cfg(test)]
pub(super) type GitDiffNameOnlyBetweenStub =
    Box<dyn Fn(String, String) -> Result<Vec<String>, String> + Send + Sync>;

#[cfg(test)]
pub(super) static GIT_DIFF_NAME_ONLY_BETWEEN_STUB: Lazy<Mutex<Option<GitDiffNameOnlyBetweenStub>>> =
    Lazy::new(|| Mutex::new(None));

#[cfg(test)]
pub(super) static AUTO_STUB_LOCK: Lazy<Mutex<()>> = Lazy::new(|| Mutex::new(()));

#[derive(Deserialize)]
struct AutoResolveDecision {
    status: String,
    #[serde(default)]
    rationale: Option<String>,
}

const AGENTS_OVERVIEW_STATIC_ROWS: usize = 2; // spacer + "Add new agent" row

#[derive(Clone)]
struct PendingAgentUpdate {
    id: uuid::Uuid,
    cfg: AgentConfig,
}

impl PendingAgentUpdate {
    fn key(&self) -> String { format!("{}:{}", self.cfg.name.to_ascii_lowercase(), self.id) }
}

#[derive(Clone, Debug)]
struct BackgroundReviewState {
    worktree_path: std::path::PathBuf,
    branch: String,
    agent_id: Option<String>,
    snapshot: Option<String>,
    base: Option<GhostCommit>,
    last_seen: std::time::Instant,
}

#[derive(Clone, Debug)]
struct PendingAutoReviewRange {
    base: GhostCommit,
    defer_until_turn: Option<u64>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) enum AutoReviewIndicatorStatus {
    Running,
    Clean,
    Fixed,
    Failed,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct AutoReviewStatus {
    status: AutoReviewIndicatorStatus,
    findings: Option<usize>,
    phase: AutoReviewPhase,
}

fn detect_auto_review_phase(progress: Option<&str>) -> AutoReviewPhase {
    let text = progress.unwrap_or_default().to_ascii_lowercase();
    // Prefer explicit phase markers emitted by exec when available.
    if text.contains("[auto-review] phase: resolving") {
        return AutoReviewPhase::Resolving;
    }
    if text.contains("[auto-review] phase: reviewing") {
        return AutoReviewPhase::Reviewing;
    }

    AutoReviewPhase::Reviewing
}

const SKIP_REVIEW_PROGRESS_SENTINEL: &str = "Another review is already running; skipping this /review.";
const AUTO_REVIEW_SHARED_WORKTREE: &str = "auto-review";
const AUTO_REVIEW_FALLBACK_PREFIX: &str = "auto-review-";
const AUTO_REVIEW_FALLBACK_MAX: usize = 3;
const AUTO_REVIEW_FALLBACK_MAX_AGE_SECS: u64 = 12 * 60 * 60; // 12h
const AUTO_REVIEW_STALE_SECS: u64 = 5 * 60;

fn auto_review_branches_dir(git_root: &Path) -> Result<PathBuf, String> {
    let repo_name = git_root
        .file_name()
        .and_then(|s| s.to_str())
        .unwrap_or("repo");
    let mut code_home = code_core::config::find_code_home()
        .map_err(|e| format!("failed to locate code home: {e}"))?;
    code_home = code_home.join("working").join(repo_name).join("branches");
    std::fs::create_dir_all(&code_home)
        .map_err(|e| format!("failed to create branches dir: {e}"))?;
    Ok(code_home)
}

fn resolve_auto_review_worktree_path(git_root: &Path, branch: &str) -> Option<PathBuf> {
    if branch.is_empty() {
        return None;
    }

    let branches_dir = auto_review_branches_dir(git_root).ok()?;
    let candidate = branches_dir.join(branch);
    candidate.exists().then_some(candidate)
}

async fn remove_worktree_path(git_root: &Path, path: &Path) -> Result<(), String> {
    let path_str = path
        .to_str()
        .ok_or_else(|| "invalid worktree path".to_string())?;
    let remove = tokio::process::Command::new("git")
        .current_dir(git_root)
        .args(["worktree", "remove", "-f", path_str])
        .output()
        .await
        .map_err(|e| format!("failed to remove worktree: {e}"))?;
    if !remove.status.success() {
        let stderr = String::from_utf8_lossy(&remove.stderr);
        tracing::warn!("failed to remove fallback worktree via git: {}", stderr.trim());
    }
    if path.exists() {
        if let Err(e) = tokio::fs::remove_dir_all(path).await {
            tracing::warn!("failed to delete fallback worktree dir {:?}: {}", path, e);
        }
    }
    Ok(())
}

async fn cleanup_fallback_worktrees(git_root: &Path) -> Result<(), String> {
    let branches_dir = auto_review_branches_dir(git_root)?;
    let mut entries: Vec<(PathBuf, SystemTime)> = Vec::new();
    if let Ok(read_dir) = fs::read_dir(&branches_dir) {
        for entry in read_dir.flatten() {
            let path = entry.path();
            let name = entry
                .file_name()
                .into_string()
                .unwrap_or_default();
            if !name.starts_with(AUTO_REVIEW_FALLBACK_PREFIX) || name == AUTO_REVIEW_SHARED_WORKTREE {
                continue;
            }
            let meta = entry.metadata().ok();
            let mtime = meta
                .and_then(|m| m.modified().ok())
                .unwrap_or(SystemTime::UNIX_EPOCH);
            entries.push((path, mtime));
        }
    }

    // Age-based prune
    let now = SystemTime::now();
    for (path, mtime) in entries.iter() {
        if let Ok(elapsed) = now.duration_since(*mtime) {
            if elapsed.as_secs() > AUTO_REVIEW_FALLBACK_MAX_AGE_SECS {
                if let Ok(Some(g)) = try_acquire_lock("review-fallback", path) {
                    drop(g);
                    let _ = remove_worktree_path(git_root, path).await;
                }
            }
        }
    }

    // Count-based prune
    let mut remaining: Vec<(PathBuf, SystemTime)> = entries
        .into_iter()
        .filter(|(p, _)| p.exists())
        .collect();
    remaining.sort_by_key(|(_, t)| *t);
    while remaining.len() > AUTO_REVIEW_FALLBACK_MAX {
        if let Some((path, _)) = remaining.first().cloned() {
            if let Ok(Some(g)) = try_acquire_lock("review-fallback", &path) {
                drop(g);
                let _ = remove_worktree_path(git_root, &path).await;
                remaining.remove(0);
            } else {
                // Busy; skip pruning this one
                break;
            }
        }
    }

    Ok(())
}

async fn allocate_fallback_auto_review_worktree(
    git_root: &Path,
    snapshot_id: &str,
) -> Result<(PathBuf, String, ReviewGuard), String> {
    cleanup_fallback_worktrees(git_root).await?;
    let branches_dir = auto_review_branches_dir(git_root)?;
    let short = snapshot_id.chars().take(8).collect::<String>();

    for attempt in 0..AUTO_REVIEW_FALLBACK_MAX {
        let suffix = if attempt == 0 { String::new() } else { format!("-{}", attempt + 1) };
        let name = format!("{}{}{}", AUTO_REVIEW_FALLBACK_PREFIX, short, suffix);
        let path = branches_dir.join(&name);

        match try_acquire_lock("review-fallback", &path) {
            Ok(Some(guard)) => {
                let worktree_path = code_core::git_worktree::prepare_reusable_worktree(
                    git_root,
                    &name,
                    snapshot_id,
                    true,
                )
                .await
                .map_err(|e| format!("failed to prepare fallback worktree: {e}"))?;
                return Ok((worktree_path, name, guard));
            }
            Ok(None) => continue, // in use, try next suffix
            Err(err) => return Err(format!("could not acquire fallback review lock: {err}")),
        }
    }

    Err("Auto review fallback pool is busy; try again soon.".to_string())
}

#[derive(Clone, Debug)]
struct AutoReviewNotice {
    history_id: HistoryId,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub(crate) enum TurnOrigin {
    User,
    Developer,
}

#[derive(Clone)]
struct RenderRequestSeed {
    history_id: HistoryId,
    use_cache: bool,
    fallback_lines: Option<Rc<Vec<Line<'static>>>>,
    kind: RenderRequestKind,
}

pub(crate) struct ChatWidget<'a> {
    app_event_tx: AppEventSender,
    code_op_tx: UnboundedSender<Op>,
    bottom_pane: BottomPane<'a>,
    auth_manager: Arc<AuthManager>,
    login_view_state: Option<Weak<RefCell<LoginAccountsState>>>,
    login_add_view_state: Option<Weak<RefCell<LoginAddAccountState>>>,
    active_exec_cell: Option<ExecCell>,
    history_cells: Vec<Box<dyn HistoryCell>>, // Store all history in memory
    history_cell_ids: Vec<Option<HistoryId>>,
    history_live_window: Option<(usize, usize)>,
    history_frozen_width: u16,
    history_frozen_count: usize,
    history_render: HistoryRenderState,
    last_render_settings: Cell<RenderSettings>,
    history_virtualization_sync_pending: Cell<bool>,
    render_request_cache: RefCell<Vec<RenderRequestSeed>>,
    render_request_cache_dirty: Cell<bool>,
    history_prefix_append_only: Cell<bool>,
    render_theme_epoch: u64,
    history_state: HistoryState,
    history_snapshot_dirty: bool,
    history_snapshot_last_flush: Option<Instant>,
    context_cell_id: Option<HistoryId>,
    context_summary: Option<ContextSummary>,
    context_last_sequence: Option<u64>,
    context_browser_sequence: Option<u64>,
    config: Config,

    /// Optional remote-merged presets list delivered asynchronously.
    /// When absent, the TUI falls back to built-in presets.
    remote_model_presets: Option<Vec<ModelPreset>>,
    /// Whether remote defaults may be applied to this session.
    /// Captured at startup so later config changes don't retroactively enable it.
    allow_remote_default_at_startup: bool,
    /// Tracks whether the user explicitly selected a chat model in this session.
    chat_model_selected_explicitly: bool,

    planning_restore: Option<(String, ReasoningEffort)>,
    history_debug_events: Option<RefCell<Vec<String>>>,
    latest_upgrade_version: Option<String>,
    reconnect_notice_active: bool,
    initial_user_message: Option<UserMessage>,
    total_token_usage: TokenUsage,
    last_token_usage: TokenUsage,
    rate_limit_snapshot: Option<RateLimitSnapshotEvent>,
    rate_limit_warnings: RateLimitWarningState,
    rate_limit_fetch_inflight: bool,
    rate_limit_last_fetch_at: Option<DateTime<Utc>>,
    rate_limit_primary_next_reset_at: Option<DateTime<Utc>>,
    rate_limit_secondary_next_reset_at: Option<DateTime<Utc>>,
    rate_limit_refresh_scheduled_for: Option<DateTime<Utc>>,
    rate_limit_refresh_schedule_id: Arc<AtomicU64>,
    content_buffer: String,
    // Buffer for streaming assistant answer text; we do not surface partial
    // We wait for the final AgentMessage event and then emit the full text
    // at once into scrollback so the history contains a single message.
    // Cache of the last finalized assistant message to suppress immediate duplicates
    last_assistant_message: Option<String>,
    // Track the most recent finalized Answer output item within the current turn.
    // When a new Answer stream id arrives, we retroactively mark the previous
    // assistant message as a mid-turn update for styling.
    last_answer_stream_id_in_turn: Option<String>,
    last_answer_history_id_in_turn: Option<HistoryId>,
    // Track the most recent Answer stream id we've *seen* in this turn (delta or final).
    // Used to label earlier answers as mid-turn even if their final cell hasn't
    // been inserted yet.
    last_seen_answer_stream_id_in_turn: Option<String>,
    mid_turn_answer_ids_in_turn: HashSet<String>,
    // Cache of the last user text we submitted (for context passing to review/resolve agents)
    last_user_message: Option<String>,
    // Cache of the last developer/system note we injected (hidden messages)
    last_developer_message: Option<String>,
    pending_turn_origin: Option<TurnOrigin>,
    current_turn_origin: Option<TurnOrigin>,
    // Weave collaboration state (optional).
    weave_agent_id: String,
    weave_agent_name: String,
    weave_agent_accent: Option<u8>,
    weave_profile_key: Option<String>,
    selected_weave_session_id: Option<String>,
    selected_weave_session_name: Option<String>,
    weave_agent_connection: Option<crate::weave_client::WeaveAgentConnection>,
    weave_agents: Option<Vec<crate::weave_client::WeaveAgent>>,
    // Tracks whether lingering running exec/tool cells have been cleared for the
    // current turn. Reset on TaskStarted; set after the first assistant message
    // (delta or final) arrives, which is more reliable than TaskComplete.
    cleared_lingering_execs_this_turn: bool,
    // Track the ID of the current streaming message to prevent duplicates
    // Track the ID of the current streaming reasoning to prevent duplicates
    exec: ExecState,
    tools_state: ToolState,
    live_builder: RowBuilder,
    header_wave: HeaderWaveEffect,
    browser_overlay_visible: bool,
    browser_overlay_state: BrowserOverlayState,
    // Store pending image paths keyed by their placeholder text
    pending_images: HashMap<String, PathBuf>,
    // (removed) pending non-image files are no longer tracked; non-image paths remain as plain text
    welcome_shown: bool,
    test_mode: bool,
    // Path to the latest browser screenshot and URL for display
    latest_browser_screenshot: Arc<Mutex<Option<(PathBuf, String)>>>,
    browser_autofix_requested: Arc<AtomicBool>,
    // Cached image protocol to avoid recreating every frame (path, area, protocol)
    cached_image_protocol:
        std::cell::RefCell<Option<(PathBuf, Rect, ratatui_image::protocol::Protocol)>>,
    // Cached picker to avoid recreating every frame
    cached_picker: std::cell::RefCell<Option<Picker>>,

    // Cached cell size (width,height) in pixels
    cached_cell_size: std::cell::OnceCell<(u16, u16)>,
    git_branch_cache: RefCell<GitBranchCache>,

    // Terminal information from startup
    terminal_info: crate::tui::TerminalInfo,
    // Agent tracking for multi-agent tasks
    active_agents: Vec<AgentInfo>,
    agents_ready_to_start: bool,
    last_agent_prompt: Option<String>,
    agent_context: Option<String>,
    agent_task: Option<String>,
    recent_agent_hint: Option<String>,
    suppress_next_agent_hint: bool,
    active_review_hint: Option<String>,
    active_review_prompt: Option<String>,
    auto_resolve_state: Option<AutoResolveState>,
    auto_resolve_attempts_baseline: u32,
    turn_had_code_edits: bool,
    background_review: Option<BackgroundReviewState>,
    auto_review_status: Option<AutoReviewStatus>,
    auto_review_notice: Option<AutoReviewNotice>,
    auto_review_baseline: Option<GhostCommit>,
    auto_review_reviewed_marker: Option<GhostCommit>,
    pending_auto_review_range: Option<PendingAutoReviewRange>,
    turn_sequence: u64,
    review_guard: Option<ReviewGuard>,
    background_review_guard: Option<ReviewGuard>,
    processed_auto_review_agents: HashSet<String>,
    // New: coordinator-provided hints for the next Auto turn
    pending_turn_descriptor: Option<TurnDescriptor>,
    pending_auto_turn_config: Option<TurnConfig>,
    overall_task_status: String,
    active_plan_title: Option<String>,
    /// Runtime timing per-agent (by id) to improve visibility in the HUD
    agent_runtime: HashMap<String, AgentRuntime>,
    pending_agent_updates: HashMap<String, PendingAgentUpdate>,
    // Sparkline data for showing agent activity (using RefCell for interior mutability)
    // Each tuple is (value, is_completed) where is_completed indicates if any agent was complete at that time
    sparkline_data: std::cell::RefCell<Vec<(u64, bool)>>,
    last_sparkline_update: std::cell::RefCell<std::time::Instant>,
    // Stream controller for managing streaming content
    stream: crate::streaming::controller::StreamController,
    // Stream lifecycle state (kind, closures, sequencing, cancel)
    stream_state: StreamState,
    // Interrupt manager for handling cancellations
    interrupts: interrupts::InterruptManager,
    // Guard to avoid spamming flush timers while interrupts wait behind a stalled stream
    interrupt_flush_scheduled: bool,

    // Guard for out-of-order exec events: track call_ids that already ended
    ended_call_ids: HashSet<ExecCallId>,
    /// Exec call_ids that were explicitly cancelled by user interrupt. Used to
    /// drop any late ExecEnd events so we don't render duplicate cells.
    canceled_exec_call_ids: HashSet<ExecCallId>,

    // Accumulated diff/session state
    diffs: DiffsState,

    // Help overlay state
    help: HelpState,

    // Settings overlay state
    settings: SettingsState,
    // When a standalone picker (model selection) closes, optionally reopen the settings overlay
    pending_settings_return: Option<SettingsSection>,

    // Limits overlay state
    limits: LimitsState,

    // Terminal overlay state
    terminal: TerminalState,
    pending_manual_terminal: HashMap<u64, PendingManualTerminal>,

    // Persisted selection for Agents overview
    agents_overview_selected_index: usize,

    // State for the Agents Terminal view
    agents_terminal: AgentsTerminalState,

    pending_git_init_resume: Option<GitInitResume>,
    git_init_inflight: bool,
    git_init_declined: bool,

    pending_upgrade_notice: Option<(u64, String)>,

    // Cached visible rows for the diff overlay body to clamp scrolling (kept within diffs)

    // Centralized height manager (always enabled)
    height_manager: RefCell<HeightManager>,

    // Aggregated layout and scroll state
    layout: LayoutState,

    // True when connected to external Chrome via CDP; affects HUD titles
    browser_is_external: bool,

    // Most recent theme snapshot used to retint pre-rendered lines
    last_theme: crate::theme::Theme,

    // Performance tracing (opt-in via /perf)
    perf_state: PerfState,
    // Current session id (from SessionConfigured)
    session_id: Option<uuid::Uuid>,

    // Pending diagnostics integration
    next_cli_text_format: Option<TextFormat>,

    // Pending jump-back state (reversible until submit)

    // Track active task ids so we don't drop the working status while any
    // agent/sub‑agent is still running (long‑running sessions can interleave).
    active_task_ids: HashSet<String>,

    // --- Queued user message support ---
    // Messages typed while a task is running are kept here and rendered
    // at the bottom as "(queued)" until the next turn begins. At that
    // point we submit one queued message and move its cell into the
    // normal history within the new turn window.
    queued_user_messages: std::collections::VecDeque<UserMessage>,
    pending_dispatched_user_messages: std::collections::VecDeque<String>,
    // Number of user prompts we pre-pended to history just before starting
    // a new turn; used to anchor the next turn window so assistant output
    // appears after them.
    pending_user_prompts_for_next_turn: usize,
    ghost_snapshots: Vec<GhostSnapshot>,
    ghost_snapshots_disabled: bool,
    ghost_snapshots_disabled_reason: Option<GhostSnapshotsDisabledReason>,
    ghost_snapshot_queue: VecDeque<(u64, GhostSnapshotRequest)>,
    active_ghost_snapshot: Option<(u64, GhostSnapshotRequest)>,
    next_ghost_snapshot_id: u64,
    queue_block_started_at: Option<Instant>,

    auto_drive_card_sequence: u64,
    auto_drive_variant: AutoDriveVariant,
    auto_state: AutoDriveController,
    auto_goal_escape_state: AutoGoalEscState,
    auto_handle: Option<AutoCoordinatorHandle>,
    auto_drive_pid_guard: Option<AutoDrivePidFile>,
    auto_history: AutoDriveHistory,
    auto_compaction_overlay: Option<AutoCompactionOverlay>,
    auto_turn_review_state: Option<AutoTurnReviewState>,
    auto_pending_goal_request: bool,
    auto_goal_bootstrap_done: bool,
    cloud_tasks_selected_env: Option<CloudEnvironment>,
    cloud_tasks_environments: Vec<CloudEnvironment>,
    cloud_tasks_last_tasks: Vec<TaskSummary>,
    cloud_tasks_best_of_n: usize,
    cloud_tasks_creation_inflight: bool,
    cloud_task_apply_tickets: HashMap<(String, bool), BackgroundOrderTicket>,
    cloud_task_create_ticket: Option<BackgroundOrderTicket>,

    // Event sequencing to preserve original order across streaming/tool events
    // and stream-related flags moved into stream_state

    // Strict global ordering for history: every cell has a required key
    // (req, out, seq). No unordered inserts and no turn windows.
    cell_order_seq: Vec<OrderKey>,
    // Debug: per-cell order info string rendered in the UI to diagnose ordering.
    cell_order_dbg: Vec<Option<String>>,
    // Routing for reasoning stream ids -> existing CollapsibleReasoningCell index
    reasoning_index: HashMap<String, usize>,
    // Stable per-(kind, stream_id) ordering, derived from OrderMeta.
    stream_order_seq: HashMap<(StreamKind, String), OrderKey>,
    // Resume-aware bias applied to provider request ordinals for restored sessions.
    order_request_bias: u64,
    resume_expected_next_request: Option<u64>,
    resume_provider_baseline: Option<u64>,
    // Track last provider request_ordinal seen so internal messages can be
    // assigned request_index = last_seen + 1 (with out = -1).
    last_seen_request_index: u64,
    // Synthetic request index used for internal-only messages; always >= last_seen_request_index
    current_request_index: u64,
    // Monotonic seq for internal messages to keep intra-request order stable
    internal_seq: u64,
    // Show order overlay when true (from --order)
    show_order_overlay: bool,

    // One-time hint to teach input history navigation
    scroll_history_hint_shown: bool,

    // Track and manage the access-mode background status cell so mode changes
    // replace the existing status instead of stacking multiple entries.
    access_status_idx: Option<usize>,
    /// When true, render without the top status bar and HUD so the normal
    /// terminal scrollback remains usable (Ctrl+T standard terminal mode).
    pub(crate) standard_terminal_mode: bool,
    // Pending system notes to inject into the agent's conversation history
    // before the next user turn. Each entry is sent in order ahead of the
    // user's visible prompt.
    pending_agent_notes: Vec<String>,

    // Stable synthetic request bucket for pre‑turn system notices (set on first use)
    synthetic_system_req: Option<u64>,
    // Map of system notice ids to their history index for in-place replacement
    system_cell_by_id: std::collections::HashMap<String, usize>,
    // Per-request counters for UI-issued background order metadata
    ui_background_seq_counters: HashMap<u64, Arc<AtomicU64>>,
    // Track the largest order key we have assigned so far to keep tail inserts monotonic
    last_assigned_order: Option<OrderKey>,
    replay_history_depth: usize,
    resume_placeholder_visible: bool,
    resume_picker_loading: bool,
}

#[derive(Clone, Debug, Default)]
struct ContextSummary {
    cwd: Option<String>,
    git_branch: Option<String>,
    reasoning_effort: Option<String>,
    browser_session_active: bool,
    deltas: Vec<ContextDeltaRecord>,
    browser_snapshot: Option<ContextBrowserSnapshotRecord>,
    expanded: bool,
}

#[derive(Clone, Debug)]
struct AutoCompactionOverlay {
    /// Snapshot of the conversation prefix (including the latest compact summary)
    /// that should be injected ahead of any history-derived tail when exporting
    /// the next Auto Drive request.
    prefix_items: Vec<code_protocol::models::ResponseItem>,
    /// History cell index that marks the beginning of the still-live tail that
    /// we continue to mirror directly from the UI.
    tail_start_cell: usize,
}

#[derive(Clone)]
pub(crate) struct BackgroundOrderTicket {
    request_ordinal: u64,
    seq_counter: Arc<AtomicU64>,
}

impl BackgroundOrderTicket {
    pub(crate) fn next_order(&self) -> code_core::protocol::OrderMeta {
        let seq = self.seq_counter.fetch_add(1, Ordering::SeqCst);
        code_core::protocol::OrderMeta {
            request_ordinal: self.request_ordinal,
            output_index: Some(i32::MAX as u32),
            sequence_number: Some(seq),
        }
    }
}

#[derive(Clone)]
struct GhostSnapshot {
    commit: GhostCommit,
    captured_at: DateTime<Local>,
    summary: Option<String>,
    conversation: ConversationSnapshot,
    history: HistorySnapshot,
}

#[derive(Clone, Copy)]
enum UndoPreviewRole {
    User,
    Assistant,
}

impl GhostSnapshot {
    fn new(
        commit: GhostCommit,
        summary: Option<String>,
        conversation: ConversationSnapshot,
        history: HistorySnapshot,
    ) -> Self {
        let summary = summary.and_then(|text| {
            let trimmed = text.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        });
        Self {
            commit,
            captured_at: Local::now(),
            summary,
            conversation,
            history,
        }
    }

    fn commit(&self) -> &GhostCommit {
        &self.commit
    }

    fn short_id(&self) -> String {
        self.commit.id().chars().take(8).collect()
    }

    fn summary_snippet(&self, max_len: usize) -> Option<String> {
        let summary = self.summary.as_ref()?;
        let mut snippet = String::new();
        let mut truncated = false;
        for word in summary.split_whitespace() {
            if !snippet.is_empty() {
                snippet.push(' ');
            }
            snippet.push_str(word);
            if snippet.chars().count() > max_len {
                truncated = true;
                break;
            }
        }

        if snippet.chars().count() > max_len {
            truncated = true;
            snippet = snippet.chars().take(max_len).collect();
        }

        if truncated {
            snippet.push('…');
        }

        Some(snippet)
    }

    fn age_from(&self, now: DateTime<Local>) -> Option<std::time::Duration> {
        now.signed_duration_since(self.captured_at).to_std().ok()
    }
}

#[derive(Clone)]
struct GhostSnapshotRequest {
    summary: Option<String>,
    conversation: ConversationSnapshot,
    history: HistorySnapshot,
    started_at: Instant,
}

impl GhostSnapshotRequest {
    fn new(
        summary: Option<String>,
        conversation: ConversationSnapshot,
        history: HistorySnapshot,
    ) -> Self {
        Self {
            summary,
            conversation,
            history,
            started_at: Instant::now(),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum GhostSnapshotJobHandle {
    Scheduled(u64),
    Skipped,
}

#[derive(Default)]
struct GitBranchCache {
    value: Option<String>,
    last_head_mtime: Option<SystemTime>,
    last_refresh: Option<Instant>,
}

#[derive(Debug, Clone, Default)]
struct AgentRuntime {
    /// First time this agent entered Running
    started_at: Option<Instant>,
    /// Time of the latest status update we observed
    last_update: Option<Instant>,
    /// Time the agent reached a terminal state (Completed/Failed)
    completed_at: Option<Instant>,
}

#[derive(Debug, Clone)]
struct AgentTerminalEntry {
    name: String,
    batch_id: Option<String>,
    batch_label: Option<String>,
    batch_prompt: Option<String>,
    batch_context: Option<String>,
    model: Option<String>,
    status: AgentStatus,
    source_kind: Option<AgentSourceKind>,
    last_progress: Option<String>,
    result: Option<String>,
    error: Option<String>,
    logs: Vec<AgentLogEntry>,
}

impl AgentTerminalEntry {
    fn new(
        name: String,
        model: Option<String>,
        status: AgentStatus,
        batch_id: Option<String>,
    ) -> Self {
        Self {
            name,
            batch_id,
            batch_label: None,
            batch_prompt: None,
            batch_context: None,
            model,
            status,
            source_kind: None,
            last_progress: None,
            result: None,
            error: None,
            logs: Vec::new(),
        }
    }

    fn push_log(&mut self, kind: AgentLogKind, message: impl Into<String>) {
        let msg = message.into();
        if self
            .logs
            .last()
            .map(|entry| entry.kind == kind && entry.message == msg)
            .unwrap_or(false)
        {
            return;
        }
        self.logs.push(AgentLogEntry {
            timestamp: Local::now(),
            kind,
            message: msg,
        });
        const MAX_HISTORY: usize = 500;
        if self.logs.len() > MAX_HISTORY {
            let excess = self.logs.len() - MAX_HISTORY;
            self.logs.drain(0..excess);
        }
    }
}

#[derive(Debug, Clone)]
struct AgentLogEntry {
    timestamp: DateTime<Local>,
    kind: AgentLogKind,
    message: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum AgentLogKind {
    Status,
    Progress,
    Result,
    Error,
}

struct AgentsTerminalState {
    active: bool,
    selected_index: usize,
    order: Vec<String>,
    entries: HashMap<String, AgentTerminalEntry>,
    scroll_offsets: HashMap<String, u16>,
    // Last scroll offset used to render the detail view (bottom-anchored)
    last_render_scroll: std::cell::Cell<u16>,
    saved_scroll_offset: u16,
    shared_context: Option<String>,
    shared_task: Option<String>,
    pending_stop: Option<PendingAgentStop>,
    focus: AgentsTerminalFocus,
    active_tab: AgentsTerminalTab,
    sort_mode: AgentsSortMode,
    highlights_collapsed: bool,
    actions_collapsed: bool,
}

#[derive(Clone, Debug)]
struct PendingAgentStop {
    agent_id: String,
    agent_name: String,
}

#[derive(Default, Clone)]
struct AgentBatchMetadata {
    label: Option<String>,
    prompt: Option<String>,
    context: Option<String>,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
enum AgentsSidebarEntry {
    Agent(String),
}

#[derive(Clone, Debug)]
struct AgentsSidebarGroup {
    batch_id: Option<String>,
    label: String,
    agent_ids: Vec<String>,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AgentsTerminalTab {
    All,
    Running,
    Failed,
    Completed,
    Review,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AgentsSortMode {
    Recent,
    RunningFirst,
    Name,
}

fn short_batch_label(batch_id: &str) -> String {
    let compact: String = batch_id.chars().filter(|c| *c != '-').collect();
    let source = if compact.is_empty() { batch_id } else { compact.as_str() };
    let short: String = source.chars().take(8).collect();
    if short.is_empty() {
        "Batch".to_string()
    } else {
        format!("Batch {short}")
    }
}

impl AgentsSidebarEntry {
    fn scroll_key(&self) -> String {
        match self {
            AgentsSidebarEntry::Agent(id) => format!("agent:{id}"),
        }
    }
}

impl AgentsTerminalState {
    fn new() -> Self {
        Self {
            active: false,
            selected_index: 0,
            order: Vec::new(),
            entries: HashMap::new(),
            scroll_offsets: HashMap::new(),
            last_render_scroll: std::cell::Cell::new(0),
            saved_scroll_offset: 0,
            shared_context: None,
            shared_task: None,
            pending_stop: None,
            focus: AgentsTerminalFocus::Sidebar,
            active_tab: AgentsTerminalTab::All,
            sort_mode: AgentsSortMode::Recent,
            highlights_collapsed: false,
            actions_collapsed: false,
        }
    }

    fn reset(&mut self) {
        self.selected_index = 0;
        self.order.clear();
        self.entries.clear();
        self.scroll_offsets.clear();
        self.last_render_scroll.set(0);
        self.shared_context = None;
        self.shared_task = None;
        self.pending_stop = None;
        self.focus = AgentsTerminalFocus::Sidebar;
        self.active_tab = AgentsTerminalTab::All;
    }

    fn current_sidebar_entry(&self) -> Option<AgentsSidebarEntry> {
        let entries = self.sidebar_entries();
        entries.get(self.selected_index).cloned()
    }

    fn focus_sidebar(&mut self) {
        self.focus = AgentsTerminalFocus::Sidebar;
    }

    fn focus_detail(&mut self) {
        self.focus = AgentsTerminalFocus::Detail;
    }

    fn focus(&self) -> AgentsTerminalFocus {
        self.focus
    }

    fn set_stop_prompt(&mut self, agent_id: String, agent_name: String) {
        self.pending_stop = Some(PendingAgentStop { agent_id, agent_name });
    }

    fn clear_stop_prompt(&mut self) {
        self.pending_stop = None;
    }

    fn clamp_selected_index(&mut self) {
        let entries = self.sidebar_entries();
        if entries.is_empty() {
            self.selected_index = 0;
        } else if self.selected_index >= entries.len() {
            self.selected_index = entries.len().saturating_sub(1);
        }
    }

    fn reselect_entry(&mut self, entry: Option<AgentsSidebarEntry>) {
        if let Some(target) = entry {
            if let Some(idx) = self
                .sidebar_entries()
                .iter()
                .position(|candidate| *candidate == target)
            {
                self.selected_index = idx;
                return;
            }
        }
        self.clamp_selected_index();
    }

    fn cycle_sort_mode(&mut self) {
        self.sort_mode = match self.sort_mode {
            AgentsSortMode::Recent => AgentsSortMode::RunningFirst,
            AgentsSortMode::RunningFirst => AgentsSortMode::Name,
            AgentsSortMode::Name => AgentsSortMode::Recent,
        };
    }

    fn toggle_highlights(&mut self) {
        self.highlights_collapsed = !self.highlights_collapsed;
    }

    fn toggle_actions(&mut self) {
        self.actions_collapsed = !self.actions_collapsed;
    }

    fn tab_allows(&self, entry: &AgentTerminalEntry) -> bool {
        match self.active_tab {
            AgentsTerminalTab::All => true,
            AgentsTerminalTab::Running =>
                matches!(entry.status, AgentStatus::Pending | AgentStatus::Running),
            AgentsTerminalTab::Failed => matches!(entry.status, AgentStatus::Failed),
            AgentsTerminalTab::Completed =>
                matches!(entry.status, AgentStatus::Completed | AgentStatus::Cancelled),
            AgentsTerminalTab::Review => matches!(entry.source_kind, Some(AgentSourceKind::AutoReview)),
        }
    }

    fn filtered_order(&self) -> Vec<String> {
        let mut filtered: Vec<String> = self
            .order
            .iter()
            .filter(|id| {
                self.entries
                    .get(*id)
                    .map(|entry| self.tab_allows(entry))
                    .unwrap_or(false)
            })
            .cloned()
            .collect();

        match self.sort_mode {
            AgentsSortMode::Recent => {
                // keep insertion order
            }
            AgentsSortMode::RunningFirst => {
                let mut positions: HashMap<String, usize> = HashMap::new();
                for (idx, id) in self.order.iter().enumerate() {
                    positions.insert(id.clone(), idx);
                }
                filtered.sort_by(|a, b| {
                    let sa = self
                        .entries
                        .get(a)
                        .map(|e| agent_running_priority(e.status.clone()))
                        .unwrap_or(usize::MAX);
                    let sb = self
                        .entries
                        .get(b)
                        .map(|e| agent_running_priority(e.status.clone()))
                        .unwrap_or(usize::MAX);
                    sa.cmp(&sb).then_with(|| positions[a].cmp(&positions[b]))
                });
            }
            AgentsSortMode::Name => {
                filtered.sort_by(|a, b| {
                    let left = self
                        .entries
                        .get(a)
                        .and_then(|e| e.name.split_whitespace().next())
                        .unwrap_or("")
                        .to_lowercase();
                    let right = self
                        .entries
                        .get(b)
                        .and_then(|e| e.name.split_whitespace().next())
                        .unwrap_or("")
                        .to_lowercase();
                    left.cmp(&right).then_with(|| a.cmp(b))
                });
            }
        }

        filtered
    }

    fn sidebar_entries(&self) -> Vec<AgentsSidebarEntry> {
        let mut out = Vec::new();
        for group in self.sidebar_groups() {
            for agent_id in group.agent_ids {
                out.push(AgentsSidebarEntry::Agent(agent_id));
            }
        }
        out
    }

    fn sidebar_groups(&self) -> Vec<AgentsSidebarGroup> {
        let mut groups: Vec<AgentsSidebarGroup> = Vec::new();
        let mut group_lookup: HashMap<Option<String>, usize> = HashMap::new();
        for id in self.filtered_order() {
            if let Some(entry) = self.entries.get(&id) {
                let key = entry.batch_id.clone();
                let idx = if let Some(idx) = group_lookup.get(&key) {
                    *idx
                } else {
                    let label = entry
                        .batch_label
                        .as_ref()
                        .and_then(|value| {
                            let trimmed = value.trim();
                            (!trimmed.is_empty()).then(|| trimmed.to_string())
                        })
                        .or_else(|| {
                            key.as_ref().map(|batch| short_batch_label(batch))
                        })
                        .unwrap_or_else(|| "Ad-hoc Agents".to_string());
                    let idx = groups.len();
                    group_lookup.insert(key.clone(), idx);
                    groups.push(AgentsSidebarGroup {
                        batch_id: key.clone(),
                        label,
                        agent_ids: Vec::new(),
                    });
                    idx
                };
                if let Some(group) = groups.get_mut(idx) {
                    group.agent_ids.push(id.clone());
                }
            }
        }
        groups
    }

    fn set_tab(&mut self, tab: AgentsTerminalTab) {
        if self.active_tab != tab {
            self.active_tab = tab;
            self.selected_index = 0;
        }
        self.clear_stop_prompt();
        self.clamp_selected_index();
    }

    fn jump_batch(&mut self, delta: isize) {
        let groups = self.sidebar_groups();
        if groups.is_empty() {
            return;
        }
        let current_batch = match self.current_sidebar_entry() {
            Some(AgentsSidebarEntry::Agent(id)) => self
                .entries
                .get(id.as_str())
                .and_then(|entry| entry.batch_id.clone()),
            None => None,
        };
        let mut idx: isize = groups
            .iter()
            .position(|group| group.batch_id == current_batch)
            .unwrap_or(0) as isize;
        let len = groups.len() as isize;
        if len == 0 {
            return;
        }
        idx = (idx + delta).rem_euclid(len);
        if let Some(target) = groups.get(idx as usize) {
            if let Some(first_agent) = target.agent_ids.first() {
                if let Some(pos) = self
                    .sidebar_entries()
                    .iter()
                    .position(|entry| matches!(entry, AgentsSidebarEntry::Agent(id) if id == first_agent))
                {
                    self.selected_index = pos;
                    self.focus_sidebar();
                    self.clear_stop_prompt();
                }
            }
        }
        self.clamp_selected_index();
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AgentsTerminalFocus {
    Sidebar,
    Detail,
}

// ---------- Stable ordering & routing helpers ----------
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
struct OrderKey {
    req: u64,
    out: i32,
    seq: u64,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct BrowserSessionOrderKey {
    req: u64,
    out: i32,
}

impl BrowserSessionOrderKey {
    fn from_order_meta(meta: &code_core::protocol::OrderMeta) -> Self {
        let out = meta
            .output_index
            .map(|value| {
                if value > i32::MAX as u32 {
                    i32::MAX
                } else {
                    value as i32
                }
            })
            .unwrap_or(i32::MAX);
        Self {
            req: meta.request_ordinal,
            out,
        }
    }
}

impl Ord for OrderKey {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        match self.req.cmp(&other.req) {
            std::cmp::Ordering::Equal => match self.out.cmp(&other.out) {
                std::cmp::Ordering::Equal => self.seq.cmp(&other.seq),
                o => o,
            },
            o => o,
        }
    }
}

impl PartialOrd for OrderKey {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl From<OrderKeySnapshot> for OrderKey {
    fn from(snapshot: OrderKeySnapshot) -> Self {
        Self {
            req: snapshot.req,
            out: snapshot.out,
            seq: snapshot.seq,
        }
    }
}

impl From<OrderKey> for OrderKeySnapshot {
    fn from(key: OrderKey) -> Self {
        OrderKeySnapshot {
            req: key.req,
            out: key.out,
            seq: key.seq,
        }
    }
}

// Removed legacy turn-window logic; ordering is strictly global.

// Global guard to prevent overlapping background screenshot captures and to rate-limit them
static BG_SHOT_IN_FLIGHT: Lazy<AtomicBool> = Lazy::new(|| AtomicBool::new(false));
static BACKGROUND_REVIEW_LOCKS: Lazy<Mutex<HashMap<String, code_core::review_coord::ReviewGuard>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static BG_SHOT_LAST_START_MS: Lazy<AtomicU64> = Lazy::new(|| AtomicU64::new(0));
static MERGE_LOCKS: Lazy<Mutex<HashMap<PathBuf, Arc<tokio::sync::Mutex<()>>>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static WORKTREE_ROOT_HINTS: Lazy<Mutex<HashMap<PathBuf, PathBuf>>> =
    Lazy::new(|| Mutex::new(HashMap::new()));
static CWD_HISTORY: Lazy<Mutex<Vec<PathBuf>>> = Lazy::new(|| Mutex::new(Vec::new()));
const CWD_HISTORY_LIMIT: usize = 16;

fn remember_worktree_root_hint(worktree: &Path, git_root: &Path) {
    let mut hints = WORKTREE_ROOT_HINTS.lock().unwrap();
    let root = git_root.to_path_buf();
    hints.insert(worktree.to_path_buf(), root.clone());
    if let Ok(real) = std::fs::canonicalize(worktree) {
        hints.insert(real, root);
    }
}

fn worktree_root_hint_for(path: &Path) -> Option<PathBuf> {
    let hints = WORKTREE_ROOT_HINTS.lock().unwrap();
    hints.get(path).cloned()
}

fn remember_cwd_history(path: &Path) {
    let mut history = CWD_HISTORY.lock().unwrap();
    if history.last().map_or(false, |p| p == path) {
        return;
    }
    history.push(path.to_path_buf());
    if history.len() > CWD_HISTORY_LIMIT {
        history.remove(0);
    }
}

fn last_existing_cwd(except: &Path) -> Option<PathBuf> {
    let history = CWD_HISTORY.lock().unwrap();
    history
        .iter()
        .rev()
        .filter(|p| p.as_path() != except)
        .find(|p| p.exists())
        .cloned()
}

use self::diff_ui::DiffBlock;
use self::diff_ui::DiffConfirm;
use self::diff_ui::DiffOverlay;
use self::settings_overlay::{
    AgentOverviewRow,
    AccountsSettingsContent,
    AutoDriveSettingsContent,
    AgentsSettingsContent,
    LimitsSettingsContent,
    ChromeSettingsContent,
    McpSettingsContent,
    ModelSettingsContent,
    PlanningSettingsContent,
    NotificationsSettingsContent,
    PromptsSettingsContent,
    SkillsSettingsContent,
    ReviewSettingsContent,
    ThemeSettingsContent,
    UpdatesSettingsContent,
    ValidationSettingsContent,
    SettingsOverlayView,
    SettingsOverviewRow,
};
use ratatui::text::Line as RtLine;
use ratatui::text::Span as RtSpan;


use self::perf::PerfStats;

#[derive(Debug, Clone)]
struct AgentInfo {
    // Stable id to correlate updates
    id: String,
    // Display name
    name: String,
    // Current status
    status: AgentStatus,
    // Source of the agent (e.g., Auto Review)
    source_kind: Option<AgentSourceKind>,
    // Batch identifier reported by the core (if any)
    batch_id: Option<String>,
    // Optional model name
    model: Option<String>,
    // Final success message when completed
    result: Option<String>,
    // Final error message when failed
    error: Option<String>,
    // Most recent progress line from core
    last_progress: Option<String>,
}

#[derive(Debug, Clone, PartialEq)]
enum AgentStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

fn agent_status_from_str(status: &str) -> AgentStatus {
    match status {
        "pending" => AgentStatus::Pending,
        "running" => AgentStatus::Running,
        "completed" => AgentStatus::Completed,
        "failed" => AgentStatus::Failed,
        "cancelled" => AgentStatus::Cancelled,
        _ => AgentStatus::Pending,
    }
}

fn agent_status_label(status: AgentStatus) -> &'static str {
    match status {
        AgentStatus::Pending => "Pending",
        AgentStatus::Running => "Running",
        AgentStatus::Completed => "Completed",
        AgentStatus::Failed => "Failed",
        AgentStatus::Cancelled => "Cancelled",
    }
}

fn agent_status_icon(status: AgentStatus) -> &'static str {
    match status {
        AgentStatus::Completed => "✔",
        AgentStatus::Running => "▶",
        AgentStatus::Pending => "…",
        AgentStatus::Failed => "✖",
        AgentStatus::Cancelled => "⏹",
    }
}

fn agent_running_priority(status: AgentStatus) -> usize {
    match status {
        AgentStatus::Running => 0,
        AgentStatus::Pending => 1,
        AgentStatus::Failed => 2,
        AgentStatus::Completed => 3,
        AgentStatus::Cancelled => 4,
    }
}

fn agent_status_color(status: AgentStatus) -> ratatui::style::Color {
    match status {
        AgentStatus::Pending => crate::colors::warning(),
        AgentStatus::Running => crate::colors::info(),
        AgentStatus::Completed => crate::colors::success(),
        AgentStatus::Failed => crate::colors::error(),
        AgentStatus::Cancelled => crate::colors::warning(),
    }
}

fn agent_log_label(kind: AgentLogKind) -> &'static str {
    match kind {
        AgentLogKind::Status => "status",
        AgentLogKind::Progress => "progress",
        AgentLogKind::Result => "result",
        AgentLogKind::Error => "error",
    }
}

fn agent_log_color(kind: AgentLogKind) -> ratatui::style::Color {
    match kind {
        AgentLogKind::Status => crate::colors::info(),
        AgentLogKind::Progress => crate::colors::primary(),
        AgentLogKind::Result => crate::colors::success(),
        AgentLogKind::Error => crate::colors::error(),
    }
}

use self::message::create_initial_user_message;

// Newtype IDs for clarity across exec/tools/streams
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct ExecCallId(pub String);
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct ToolCallId(pub String);
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub(super) struct StreamId(pub String);

impl From<String> for ExecCallId {
    fn from(s: String) -> Self {
        ExecCallId(s)
    }
}
impl From<&str> for ExecCallId {
    fn from(s: &str) -> Self {
        ExecCallId(s.to_string())
    }
}

fn wait_target_from_params(params: Option<&String>, call_id: &str) -> String {
    if let Some(raw) = params {
        if let Ok(json) = serde_json::from_str::<serde_json::Value>(raw) {
            if let Some(for_value) = json.get("for").and_then(|v| v.as_str()) {
                let cleaned = clean_wait_command(for_value);
                if !cleaned.is_empty() {
                    return cleaned;
                }
            }
            if let Some(cid) = json.get("call_id").and_then(|v| v.as_str()) {
                return format!("call {}", cid);
            }
        }
    }
    format!("call {}", call_id)
}

fn wait_exec_call_id_from_params(params: Option<&String>) -> Option<ExecCallId> {
    params
        .and_then(|raw| serde_json::from_str::<serde_json::Value>(raw).ok())
        .and_then(|json| json.get("call_id").and_then(|v| v.as_str()).map(|s| ExecCallId(s.to_string())))
}

fn wait_result_missing_background_job(message: &str) -> bool {
    let trimmed = message.trim();
    trimmed.starts_with("No background job found for call_id=")
        || trimmed == "No completed background job found"
}

fn wait_result_interrupted(message: &str) -> bool {
    let trimmed = message.trim();
    if trimmed.is_empty() {
        return false;
    }
    let lower = trimmed.to_ascii_lowercase();
    lower.contains("wait ended due to new user message")
        || lower.contains("wait ended because the session was interrupted")
        || lower.contains("wait interrupted so the assistant can adapt")
        || (lower.contains("background job") && lower.contains("still running"))
}

fn image_mime_from_path(path: &Path) -> Option<String> {
    let ext = path.extension().and_then(|ext| ext.to_str())?;
    let mime = match ext.to_ascii_lowercase().as_str() {
        "png" => "image/png",
        "jpg" | "jpeg" => "image/jpeg",
        "gif" => "image/gif",
        "bmp" => "image/bmp",
        "webp" => "image/webp",
        "svg" => "image/svg+xml",
        "ico" => "image/x-icon",
        "tif" | "tiff" => "image/tiff",
        _ => return None,
    };
    Some(mime.to_string())
}

fn image_record_from_path(path: &Path) -> Option<ImageRecord> {
    let bytes = match std::fs::read(path) {
        Ok(bytes) => bytes,
        Err(err) => {
            tracing::warn!("Failed to read image {}: {err}", path.display());
            return None;
        }
    };
    let (width, height) = match image::image_dimensions(path) {
        Ok((w, h)) => (
            w.min(u16::MAX as u32) as u16,
            h.min(u16::MAX as u32) as u16,
        ),
        Err(err) => {
            tracing::warn!("Failed to read image dimensions for {}: {err}", path.display());
            (0, 0)
        }
    };
    let sha_hex = format!("{:x}", Sha256::digest(&bytes));
    let byte_len = bytes.len().min(u32::MAX as usize) as u32;
    Some(ImageRecord {
        id: HistoryId::ZERO,
        source_path: Some(path.to_path_buf()),
        alt_text: None,
        width,
        height,
        sha256: Some(sha_hex),
        mime_type: image_mime_from_path(path),
        byte_len: Some(byte_len),
    })
}

fn image_view_path_from_params(params: &serde_json::Value, cwd: &Path) -> Option<PathBuf> {
    let path = params.get("path").and_then(|value| value.as_str())?;
    let trimmed = path.trim();
    if trimmed.is_empty() {
        return None;
    }
    let mut resolved = PathBuf::from(trimmed);
    if resolved.is_relative() {
        resolved = cwd.join(&resolved);
    }
    if let Ok(canon) = resolved.canonicalize() {
        resolved = canon;
    }
    Some(resolved)
}

impl std::fmt::Display for ExecCallId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for ExecCallId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for ToolCallId {
    fn from(s: String) -> Self {
        ToolCallId(s)
    }
}
impl From<&str> for ToolCallId {
    fn from(s: &str) -> Self {
        ToolCallId(s.to_string())
    }
}
impl std::fmt::Display for ToolCallId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for ToolCallId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl From<String> for StreamId {
    fn from(s: String) -> Self {
        StreamId(s)
    }
}
impl From<&str> for StreamId {
    fn from(s: &str) -> Self {
        StreamId(s.to_string())
    }
}
impl std::fmt::Display for StreamId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(&self.0)
    }
}
impl AsRef<str> for StreamId {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

// ---- System notice ordering helpers ----
#[derive(Copy, Clone)]
enum SystemPlacement {
    /// Place near the top of the current request (before most provider output)
    EarlyInCurrent,
    /// Place at the end of the current request window (after provider output)
    EndOfCurrent,
    /// Place before the first user prompt of the very first request
    /// (used for pre-turn UI confirmations like theme/spinner changes)
    PrePromptInCurrent,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum AutoDriveRole {
    User,
    Assistant,
}

impl ChatWidget<'_> {
    const MAX_UNDO_CONVERSATION_MESSAGES: usize = 8;
    const MAX_UNDO_PREVIEW_CHARS: usize = 160;
    const MAX_UNDO_FILE_LINES: usize = 24;

    fn fmt_short_duration(&self, d: Duration) -> String {
        let s = d.as_secs();
        let h = s / 3600;
        let m = (s % 3600) / 60;
        let sec = s % 60;
        if h > 0 {
            format!("{}h{}m", h, m)
        } else if m > 0 {
            format!("{}m{}s", m, sec)
        } else {
            format!("{}s", sec)
        }
    }
    fn is_branch_worktree_path(path: &std::path::Path) -> bool {
        for ancestor in path.ancestors() {
            if ancestor
                .file_name()
                .map(|name| name == std::ffi::OsStr::new("branches"))
                .unwrap_or(false)
            {
                let mut higher = ancestor.parent();
                while let Some(dir) = higher {
                    if dir
                        .file_name()
                        .map(|name| name == std::ffi::OsStr::new(".code"))
                        .unwrap_or(false)
                    {
                        return true;
                    }
                    higher = dir.parent();
                }
            }
        }
        false
    }

    fn merge_lock_for_repo(path: &std::path::Path) -> Arc<tokio::sync::Mutex<()>> {
        let key = path.to_path_buf();
        let mut locks = MERGE_LOCKS.lock().unwrap();
        match locks.entry(key) {
            Entry::Occupied(existing) => existing.get().clone(),
            Entry::Vacant(slot) => slot.insert(Arc::new(tokio::sync::Mutex::new(()))).clone(),
        }
    }

    async fn git_short_status(path: &std::path::Path) -> Result<String, String> {
        use tokio::process::Command;
        match Command::new("git")
            .current_dir(path)
            .args(["status", "--short"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => Ok(String::from_utf8_lossy(&out.stdout).to_string()),
            Ok(out) => {
                let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
                let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if !stderr_s.is_empty() {
                    Err(stderr_s)
                } else if !stdout_s.is_empty() {
                    Err(stdout_s)
                } else {
                    let code = out
                        .status
                        .code()
                        .map(|c| format!("exit status {c}"))
                        .unwrap_or_else(|| "terminated by signal".to_string());
                    Err(format!("git status failed: {}", code))
                }
            }
            Err(err) => Err(err.to_string()),
        }
    }

    async fn git_diff_stat(path: &std::path::Path) -> Result<String, String> {
        use tokio::process::Command;
        match Command::new("git")
            .current_dir(path)
            .args(["diff", "--stat"])
            .output()
            .await
        {
            Ok(out) if out.status.success() => Ok(String::from_utf8_lossy(&out.stdout).to_string()),
            Ok(out) => {
                let stderr_s = String::from_utf8_lossy(&out.stderr).trim().to_string();
                let stdout_s = String::from_utf8_lossy(&out.stdout).trim().to_string();
                if !stderr_s.is_empty() {
                    Err(stderr_s)
                } else if !stdout_s.is_empty() {
                    Err(stdout_s)
                } else {
                    let code = out
                        .status
                        .code()
                        .map(|c| format!("exit status {c}"))
                        .unwrap_or_else(|| "terminated by signal".to_string());
                    Err(format!("git diff --stat failed: {code}"))
                }
            }
            Err(err) => Err(err.to_string()),
        }
    }

    /// Compute an OrderKey for system (non‑LLM) notices in a way that avoids
    /// creating multiple synthetic request buckets before the first provider turn.
    fn system_order_key(
        &mut self,
        placement: SystemPlacement,
        order: Option<&code_core::protocol::OrderMeta>,
    ) -> OrderKey {
        // If the provider supplied OrderMeta, honor it strictly.
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }

        // Derive a stable request bucket for system notices when OrderMeta is absent.
        // Default to the current provider request if known; else use a sticky
        // pre-turn synthetic req=1 to group UI confirmations before the first turn.
        // If a user prompt for the next turn is already queued, attach new
        // system notices to the upcoming request to avoid retroactive inserts.
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            if self.synthetic_system_req.is_none() {
                self.synthetic_system_req = Some(1);
            }
            self.synthetic_system_req.unwrap_or(1)
        };
        if order.is_none() && self.pending_user_prompts_for_next_turn > 0 {
            req = req.saturating_add(1);
        }

        self.internal_seq = self.internal_seq.saturating_add(1);
        let mut out = match placement {
            SystemPlacement::EarlyInCurrent => i32::MIN + 2,
            SystemPlacement::EndOfCurrent => i32::MAX,
            SystemPlacement::PrePromptInCurrent => i32::MIN,
        };

        if order.is_none()
            && self.pending_user_prompts_for_next_turn > 0
            && matches!(placement, SystemPlacement::EarlyInCurrent)
        {
            out = i32::MIN;
        }

        let mut key = OrderKey {
            req,
            out,
            seq: self.internal_seq,
        };

        if matches!(placement, SystemPlacement::EndOfCurrent) {
            let reference = self
                .last_assigned_order
                .or_else(|| self.cell_order_seq.iter().copied().max());
            if let Some(max_key) = reference {
                if key <= max_key {
                    key = Self::order_key_successor(max_key);
                }
            }
        }

        self.internal_seq = self.internal_seq.max(key.seq);
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });

        key
    }

    fn background_tail_request_ordinal(&mut self) -> u64 {
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            *self.synthetic_system_req.get_or_insert(1)
        };
        if self.pending_user_prompts_for_next_turn > 0 {
            req = req.saturating_add(1);
        }
        if let Some(last) = self.last_assigned_order {
            req = req.max(last.req);
        }
        if let Some(max_req) = self.ui_background_seq_counters.keys().copied().max() {
            req = req.max(max_req);
        }
        req
    }

    fn background_order_ticket_for_req(&mut self, req: u64) -> BackgroundOrderTicket {
        let seed = self
            .last_assigned_order
            .filter(|key| key.req == req)
            .map(|key| key.seq.saturating_add(1))
            .unwrap_or(0);

        let counter = self
            .ui_background_seq_counters
            .entry(req)
            .or_insert_with(|| Arc::new(AtomicU64::new(seed)))
            .clone();

        if seed > 0 {
            let current = counter.load(Ordering::SeqCst);
            if current < seed {
                counter.store(seed, Ordering::SeqCst);
            }
        }
        BackgroundOrderTicket {
            request_ordinal: req,
            seq_counter: counter,
        }
    }

    fn background_tail_order_ticket_internal(&mut self) -> BackgroundOrderTicket {
        let req = self.background_tail_request_ordinal();
        self.background_order_ticket_for_req(req)
    }

    fn background_before_next_output_request_ordinal(&mut self) -> u64 {
        if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            *self.synthetic_system_req.get_or_insert(1)
        }
    }

    fn background_before_next_output_ticket_internal(&mut self) -> BackgroundOrderTicket {
        let req = self.background_before_next_output_request_ordinal();
        self.background_order_ticket_for_req(req)
    }

    pub(crate) fn make_background_tail_ticket(&mut self) -> BackgroundOrderTicket {
        self.background_tail_order_ticket_internal()
    }

    pub(crate) fn make_background_before_next_output_ticket(&mut self) -> BackgroundOrderTicket {
        self.background_before_next_output_ticket_internal()
    }

    fn auto_card_next_order_key(&mut self) -> OrderKey {
        let ticket = self.make_background_tail_ticket();
        let meta = ticket.next_order();
        self.provider_order_key_from_order_meta(&meta)
    }

    fn auto_card_start(&mut self, goal: Option<String>) {
        let order_key = self.auto_card_next_order_key();
        auto_drive_cards::start_session(self, order_key, goal);
    }

    fn auto_card_add_action(&mut self, message: String, kind: AutoDriveActionKind) {
        let order_key = self.auto_card_next_order_key();
        let had_tracker = self.tools_state.auto_drive_tracker.is_some();
        auto_drive_cards::record_action(self, order_key, message.clone(), kind);
        if !had_tracker {
            self.push_background_tail(message);
        }
    }

    fn auto_card_set_status(&mut self, status: AutoDriveStatus) {
        if self.tools_state.auto_drive_tracker.is_some() {
            let order_key = self.auto_card_next_order_key();
            auto_drive_cards::set_status(self, order_key, status);
        }
    }

    fn auto_card_set_goal(&mut self, goal: Option<String>) {
        if self.tools_state.auto_drive_tracker.is_none() {
            return;
        }
        let order_key = self.auto_card_next_order_key();
        auto_drive_cards::update_goal(self, order_key, goal);
    }

    fn auto_card_finalize(
        &mut self,
        message: Option<String>,
        status: AutoDriveStatus,
        kind: AutoDriveActionKind,
    ) {
        let had_tracker = self.tools_state.auto_drive_tracker.is_some();
        let order_key = self.auto_card_next_order_key();
        let completion_message = if matches!(status, AutoDriveStatus::Stopped) {
            self.auto_state.last_completion_explanation.clone()
        } else {
            None
        };
        auto_drive_cards::finalize(
            self,
            order_key,
            message.clone(),
            status,
            kind,
            completion_message,
        );
        if !had_tracker {
            if let Some(msg) = message {
                self.push_background_tail(msg);
            }
        }
        if matches!(status, AutoDriveStatus::Stopped) {
            self.auto_state.last_completion_explanation = None;
        }
        auto_drive_cards::clear(self);
    }

    fn auto_request_session_summary(&mut self) {
        let prompt = AUTO_DRIVE_SESSION_SUMMARY_PROMPT.trim();
        if prompt.is_empty() {
            tracing::warn!("Auto Drive session summary prompt is empty");
            return;
        }

        self.push_background_tail(AUTO_DRIVE_SESSION_SUMMARY_NOTICE.to_string());
        self.request_redraw();
        self.submit_hidden_text_message_with_preface(prompt.to_string(), String::new());
    }

    fn spawn_conversation_runtime(
        &mut self,
        config: Config,
        auth_manager: Arc<AuthManager>,
        code_op_rx: UnboundedReceiver<Op>,
    ) {
        let ticket = self.make_background_tail_ticket();
        let ticket_for_submit = ticket.clone();
        let app_event_tx_clone = self.app_event_tx.clone();

        tokio::spawn(async move {
            let mut code_op_rx = code_op_rx;
            let conversation_manager = ConversationManager::new(
                auth_manager.clone(),
                SessionSource::Cli,
            );
            let resume_path = config.experimental_resume.clone();
            let new_conversation = match resume_path {
                Some(path) => conversation_manager
                    .resume_conversation_from_rollout(config.clone(), path, auth_manager.clone())
                    .await,
                None => conversation_manager.new_conversation(config).await,
            };

            let new_conversation = match new_conversation {
                Ok(conv) => conv,
                Err(e) => {
                    tracing::error!("failed to initialize conversation: {e}");
                    app_event_tx_clone.send_background_event_with_ticket(
                        &ticket,
                        format!(
                            "❌ Failed to initialize model session: {}.\n• Ensure an OpenAI API key is set (CODE_OPENAI_API_KEY / OPENAI_API_KEY) or run `code login`.\n• Also verify config.cwd is an absolute path.",
                            e
                        ),
                    );
                    return;
                }
            };

            let event = Event {
                id: new_conversation.conversation_id.to_string(),
                event_seq: 0,
                msg: EventMsg::SessionConfigured(new_conversation.session_configured),
                order: None,
            };
            app_event_tx_clone.send(AppEvent::CodexEvent(event));

            let conversation = new_conversation.conversation;
            let conversation_clone = conversation.clone();
            let app_event_tx_submit = app_event_tx_clone.clone();
            let ticket_for_submit = ticket_for_submit.clone();

            tokio::spawn(async move {
                while let Some(op) = code_op_rx.recv().await {
                    if let Err(e) = conversation_clone.submit(op).await {
                        tracing::error!("failed to submit op: {e}");
                        app_event_tx_submit.send_background_event_with_ticket(
                            &ticket_for_submit,
                            format!("⚠️ Failed to submit Op to core: {}", e),
                        );
                    }
                }
            });

            while let Ok(event) = conversation.next_event().await {
                app_event_tx_clone.send(AppEvent::CodexEvent(event));
            }
            // (debug end notice removed)
        });
    }

    fn consume_pending_prompt_for_ui_only_turn(&mut self) {
        if self.pending_user_prompts_for_next_turn > 0 {
            self.pending_user_prompts_for_next_turn -= 1;
        }
        if !self.pending_dispatched_user_messages.is_empty() {
            self.pending_dispatched_user_messages.pop_front();
        }
    }

    fn background_tail_order_meta(&mut self) -> code_core::protocol::OrderMeta {
        self.background_tail_order_ticket_internal().next_order()
    }

    fn send_background_tail_ordered(&mut self, message: impl Into<String>) {
        let order = self.background_tail_order_meta();
        self.app_event_tx
            .send_background_event_with_order(message.into(), order);
    }

    fn rebuild_ui_background_seq_counters(&mut self) {
        self.ui_background_seq_counters.clear();
        let mut next_per_req: HashMap<u64, u64> = HashMap::new();
        for key in &self.cell_order_seq {
            if key.out == i32::MAX {
                let next = key.seq.saturating_add(1);
                let entry = next_per_req.entry(key.req).or_insert(0);
                *entry = (*entry).max(next);
            }
        }
        for (req, next) in next_per_req {
            self.ui_background_seq_counters
                .insert(req, Arc::new(AtomicU64::new(next)));
        }
    }

    /// Insert or replace a system notice cell with consistent ordering.
    /// If `id_for_replace` is provided and we have a prior index for it, replace in place.
    fn push_system_cell(
        &mut self,
        cell: Box<dyn HistoryCell>,
        placement: SystemPlacement,
        id_for_replace: Option<String>,
        order: Option<&code_core::protocol::OrderMeta>,
        tag: &'static str,
        record: Option<HistoryDomainRecord>,
    ) {
        if let Some(id) = id_for_replace.as_ref() {
            if let Some(&idx) = self.system_cell_by_id.get(id) {
                if let Some(record) = record.clone() {
                    self.history_replace_with_record(idx, cell, record);
                } else {
                    self.history_replace_at(idx, cell);
                }
                return;
            }
        }
        let key = self.system_order_key(placement, order);
        let pos = self.history_insert_with_key_global_tagged(cell, key, tag, record);
        if let Some(id) = id_for_replace {
            self.system_cell_by_id.insert(id, pos);
        }
    }

    /// Decide where to place a UI confirmation right now.
    /// If we're truly pre-turn (no provider traffic yet, and no queued prompt),
    /// place before the first user prompt. Otherwise, append to end of current.
    fn ui_placement_for_now(&self) -> SystemPlacement {
        if self.last_seen_request_index == 0 && self.pending_user_prompts_for_next_turn == 0 {
            SystemPlacement::PrePromptInCurrent
        } else {
            SystemPlacement::EndOfCurrent
        }
    }
    pub(crate) fn enable_perf(&mut self, enable: bool) {
        self.perf_state.enabled = enable;
    }
    pub(crate) fn perf_summary(&self) -> String {
        self.perf_state.stats.borrow().summary()
    }
    // Build an ordered key from model-provided OrderMeta. Callers must
    // guarantee presence by passing a concrete reference (compile-time guard).
    fn raw_order_key_from_order_meta(om: &code_core::protocol::OrderMeta) -> OrderKey {
        // sequence_number can be None on some terminal events; treat as 0 for stable placement
        OrderKey {
            req: om.request_ordinal,
            out: om.output_index.map(|v| v as i32).unwrap_or(0),
            seq: om.sequence_number.unwrap_or(0),
        }
    }

    fn provider_order_key_from_order_meta(&mut self, om: &code_core::protocol::OrderMeta) -> OrderKey {
        let mut key = Self::raw_order_key_from_order_meta(om);
        key.req = self.apply_request_bias(key.req);
        key
    }

    fn apply_request_bias(&mut self, provider_req: u64) -> u64 {
        if self.resume_provider_baseline.is_none() {
            if let Some(target) = self.resume_expected_next_request {
                self.resume_provider_baseline = Some(provider_req);
                if provider_req <= target {
                    self.order_request_bias = target.saturating_sub(provider_req);
                } else {
                    self.order_request_bias = 0;
                }
                self.resume_expected_next_request = None;
            }
        }
        provider_req.saturating_add(self.order_request_bias)
    }

    // Track latest request index observed from provider so internal inserts can anchor to it.
    fn note_order(&mut self, order: Option<&code_core::protocol::OrderMeta>) {
        if let Some(om) = order {
            let is_background_sentinel = om.output_index == Some(i32::MAX as u32);
            let is_initial_session = self.last_seen_request_index == 0;
            if is_background_sentinel && is_initial_session {
                return;
            }
            let req = self.apply_request_bias(om.request_ordinal);
            self.last_seen_request_index = self.last_seen_request_index.max(req);
        }
    }

    fn debug_fmt_order_key(ok: OrderKey) -> String {
        format!("O:req={} out={} seq={}", ok.req, ok.out, ok.seq)
    }

    fn order_key_successor(after: OrderKey) -> OrderKey {
        if after.seq != u64::MAX {
            return OrderKey {
                req: after.req,
                out: after.out,
                seq: after.seq.saturating_add(1),
            };
        }

        if after.out != i32::MAX {
            return OrderKey {
                req: after.req,
                out: after.out.saturating_add(1),
                seq: 0,
            };
        }

        OrderKey {
            req: after.req.saturating_add(1),
            out: i32::MIN,
            seq: 0,
        }
    }

    // Allocate a key that places an internal (non‑model) event at the point it
    // occurs during the current request, instead of sinking it to the end.
    //
    // Strategy:
    // - If an OrderMeta is provided, honor it (strict model ordering).
    // - Otherwise, if a new turn is queued (a user prompt was just inserted),
    //   anchor immediately after that prompt within the upcoming request so
    //   the notice appears in the right window.
    // - Otherwise, derive a key within the current request:
    //   * If there is any existing cell in this request, append after the
    //     latest key in this request (req = last_seen, out/seq bumped).
    //   * If no cells exist for this request yet, place near the top of this
    //     request (after headers/prompts) so provider output can follow.
    fn near_time_key(&mut self, order: Option<&code_core::protocol::OrderMeta>) -> OrderKey {
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }

        // If we just staged a user prompt for the next request, keep using the
        // next‑turn anchor so the background item lands with that turn.
        if self.pending_user_prompts_for_next_turn > 0 {
            return self.next_req_key_after_prompt();
        }

        let req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            // No provider traffic yet: allocate a synthetic request bucket.
            // Use the same path as next_internal_key() to keep monotonicity.
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };

        // Scan for the latest key within this request to append after.
        let mut last_in_req: Option<OrderKey> = None;
        for k in &self.cell_order_seq {
            if k.req == req {
                last_in_req = Some(match last_in_req {
                    Some(prev) => {
                        if *k > prev {
                            *k
                        } else {
                            prev
                        }
                    }
                    None => *k,
                });
            }
        }

        self.internal_seq = self.internal_seq.saturating_add(1);
        match last_in_req {
            Some(last) => OrderKey {
                req,
                out: last.out,
                seq: last.seq.saturating_add(1),
            },
            None => OrderKey {
                req,
                out: i32::MIN + 2,
                seq: self.internal_seq,
            },
        }
    }

    /// Like near_time_key but never advances to the next request when a prompt is queued.
    /// Use this for late, provider-origin items that lack OrderMeta (e.g., PlanUpdate)
    /// so they remain attached to the current/last request instead of jumping forward.
    fn near_time_key_current_req(
        &mut self,
        order: Option<&code_core::protocol::OrderMeta>,
    ) -> OrderKey {
        if let Some(om) = order {
            return self.provider_order_key_from_order_meta(om);
        }
        let req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };

        let mut last_in_req: Option<OrderKey> = None;
        for k in &self.cell_order_seq {
            if k.req == req {
                last_in_req = Some(match last_in_req {
                    Some(prev) => {
                        if *k > prev {
                            *k
                        } else {
                            prev
                        }
                    }
                    None => *k,
                });
            }
        }
        self.internal_seq = self.internal_seq.saturating_add(1);
        match last_in_req {
            Some(last) => OrderKey {
                req,
                out: last.out,
                seq: last.seq.saturating_add(1),
            },
            None => OrderKey {
                req,
                out: i32::MIN + 2,
                seq: self.internal_seq,
            },
        }
    }

    // After inserting a non‑reasoning cell during streaming, restore the
    // in‑progress indicator on the latest reasoning cell so the ellipsis
    // remains visible while the model continues.
    fn restore_reasoning_in_progress_if_streaming(&mut self) {
        if !self.stream.is_write_cycle_active() {
            return;
        }
        if let Some(idx) = self.history_cells.iter().rposition(|c| {
            c.as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                .is_some()
        }) {
            if let Some(rc) = self.history_cells[idx]
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                rc.set_in_progress(true);
            }
        }
    }

    fn apply_plan_terminal_title(&mut self, title: Option<String>) {
        if self.active_plan_title == title {
            return;
        }
        self.active_plan_title = title.clone();
        self.app_event_tx
            .send(AppEvent::SetTerminalTitle { title });
    }
    // Allocate a new synthetic key for internal (non-LLM) messages at the bottom of the
    // current (active) request: (req = last_seen, out = +∞, seq = monotonic).
    fn next_internal_key(&mut self) -> OrderKey {
        // Anchor to the current provider request if known; otherwise step a synthetic counter.
        let mut req = if self.last_seen_request_index > 0 {
            self.last_seen_request_index
        } else {
            // Ensure current_request_index always moves forward
            if self.current_request_index < self.last_seen_request_index {
                self.current_request_index = self.last_seen_request_index;
            }
            self.current_request_index = self.current_request_index.saturating_add(1);
            self.current_request_index
        };
        if self.pending_user_prompts_for_next_turn > 0 {
            let next_req = self.last_seen_request_index.saturating_add(1);
            if req < next_req {
                req = next_req;
            }
        }
        if self.current_request_index < req {
            self.current_request_index = req;
        }
        self.internal_seq = self.internal_seq.saturating_add(1);
        // Place internal notices at the end of the current request window by using
        // a maximal out so they sort after any model-provided output_index.
        OrderKey {
            req,
            out: i32::MAX,
            seq: self.internal_seq,
        }
    }

    const fn context_order_key() -> OrderKey {
        OrderKey {
            req: 0,
            out: -50,
            seq: 0,
        }
    }

    /// Show the "Shift+Up/Down" input history hint the first time the user scrolls.
    pub(super) fn maybe_show_history_nav_hint_on_first_scroll(&mut self) {
        if self.scroll_history_hint_shown {
            return;
        }
        self.scroll_history_hint_shown = true;
        self.bottom_pane.flash_footer_notice_for(
            "Use Shift+Up/Down to use previous input".to_string(),
            std::time::Duration::from_secs(6),
        );
    }

    pub(super) fn perf_track_scroll_delta(&self, before: u16, after: u16) {
        if !self.perf_state.enabled {
            return;
        }
        if before == after {
            return;
        }
        let delta = before.abs_diff(after) as u64;
        {
            let mut stats = self.perf_state.stats.borrow_mut();
            stats.record_scroll_trigger(delta);
        }
        let pending = self
            .perf_state
            .pending_scroll_rows
            .get()
            .saturating_add(delta);
        self.perf_state.pending_scroll_rows.set(pending);
    }

    // Synthetic key for internal content that should appear at the TOP of the NEXT request
    // (e.g., the user’s prompt preceding the model’s output for that turn).
    fn next_req_key_top(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN,
            seq: self.internal_seq,
        }
    }

    // Synthetic key for a user prompt that should appear just after banners but
    // still before any model output within the next request.
    fn next_req_key_prompt(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN + 1,
            seq: self.internal_seq,
        }
    }

    // Synthetic key for internal notices tied to the upcoming turn that
    // should appear immediately after the user prompt but still before any
    // model output for that turn.
    fn next_req_key_after_prompt(&mut self) -> OrderKey {
        let req = self.last_seen_request_index.saturating_add(1);
        self.internal_seq = self.internal_seq.saturating_add(1);
        OrderKey {
            req,
            out: i32::MIN + 2,
            seq: self.internal_seq,
        }
    }
    /// Returns true if any agents are actively running (Pending or Running), or we're about to start them.
    /// Agents in terminal states (Completed/Failed) do not keep the spinner visible.
    fn agents_are_actively_running(&self) -> bool {
        let has_running_non_auto_review = self
            .active_agents
            .iter()
            .any(|a| {
                matches!(a.status, AgentStatus::Pending | AgentStatus::Running)
                    && !matches!(a.source_kind, Some(AgentSourceKind::AutoReview))
            });

        if has_running_non_auto_review {
            return true;
        }

        // If only Auto Review agents are active, don't drive the spinner.
        let has_running_auto_review = self
            .active_agents
            .iter()
            .any(|a| {
                matches!(a.status, AgentStatus::Pending | AgentStatus::Running)
                    && matches!(a.source_kind, Some(AgentSourceKind::AutoReview))
            });

        if has_running_auto_review {
            return false;
        }

        // Fall back to preparatory state (e.g., Auto Drive about to launch agents)
        self.agents_ready_to_start
    }

    fn has_cancelable_agents(&self) -> bool {
        self
            .active_agents
            .iter()
            .any(Self::agent_is_cancelable)
    }

    fn agent_is_cancelable(agent: &AgentInfo) -> bool {
        matches!(agent.status, AgentStatus::Pending | AgentStatus::Running)
            && !matches!(agent.source_kind, Some(AgentSourceKind::AutoReview))
    }

    fn collect_cancelable_agents(&self) -> (Vec<String>, Vec<String>) {
        let mut batch_ids: BTreeSet<String> = BTreeSet::new();
        let mut agent_ids: BTreeSet<String> = BTreeSet::new();

        for agent in &self.active_agents {
            if !Self::agent_is_cancelable(agent) {
                continue;
            }

            if let Some(batch) = agent.batch_id.as_ref() {
                let trimmed = batch.trim();
                if !trimmed.is_empty() {
                    batch_ids.insert(trimmed.to_string());
                    continue;
                }
            }

            let trimmed_id = agent.id.trim();
            if !trimmed_id.is_empty() {
                agent_ids.insert(trimmed_id.to_string());
            }
        }

        (
            batch_ids.into_iter().collect(),
            agent_ids.into_iter().collect(),
        )
    }

    fn cancel_active_agents(&mut self) -> bool {
        let (batch_ids, agent_ids) = self.collect_cancelable_agents();
        if batch_ids.is_empty() && agent_ids.is_empty() {
            return false;
        }

        let mut status_parts = Vec::new();
        if !batch_ids.is_empty() {
            let count = batch_ids.len();
            status_parts.push(if count == 1 {
                "1 batch".to_string()
            } else {
                format!("{count} batches")
            });
        }
        if !agent_ids.is_empty() {
            let count = agent_ids.len();
            status_parts.push(if count == 1 {
                "1 agent".to_string()
            } else {
                format!("{count} agents")
            });
        }

        let descriptor = if status_parts.is_empty() {
            "agents".to_string()
        } else {
            status_parts.join(", ")
        };
        let auto_active = self.auto_state.is_active();
        self.push_background_tail(format!("Cancelling {descriptor}…"));
        self.bottom_pane
            .update_status_text("Cancelling agents…".to_string());
        self.bottom_pane.set_task_running(true);
        self.submit_op(Op::CancelAgents { batch_ids, agent_ids });

        self.agents_ready_to_start = false;

        if auto_active {
            self.show_auto_drive_exit_hint();
        } else if self
            .bottom_pane
            .standard_terminal_hint()
            .is_some_and(|hint| hint == AUTO_ESC_EXIT_HINT)
        {
            self.bottom_pane.set_standard_terminal_hint(None);
        }
        self.request_redraw();

        true
    }

    /// Hide the bottom spinner/status if the UI is idle (no streams, tools, agents, or tasks).
    fn maybe_hide_spinner(&mut self) {
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
        let any_streaming = self.stream.is_write_cycle_active();
        let any_agents_active = self.agents_are_actively_running();
        let mut any_tasks_active = !self.active_task_ids.is_empty();
        let final_answer_seen =
            self.last_answer_history_id_in_turn.is_some() || self.stream_state.seq_answer_final.is_some();
        let terminal_running = self.terminal_is_running();

        // If the backend never emits TaskComplete but we already received the
        // final answer and no other activity is running, clear the spinner so
        // we don't stay stuck on "Thinking...".
        let stuck_on_completed_turn = any_tasks_active
            && final_answer_seen
            && !any_tools_running
            && !any_streaming
            && !any_agents_active
            && !terminal_running;
        if stuck_on_completed_turn {
            self.active_task_ids.clear();
            any_tasks_active = false;
            self.overall_task_status = "complete".to_string();
        }
        if !(any_tools_running
            || any_streaming
            || any_agents_active
            || any_tasks_active
            || terminal_running)
        {
            self.bottom_pane.set_task_running(false);
            self.bottom_pane.update_status_text(String::new());
        }
    }

    /// Ensure we show progress when work is visible but the spinner state drifted.
    fn ensure_spinner_for_activity(&mut self, reason: &'static str) {
        if self.bottom_pane.auto_drive_style_active()
            && !self.bottom_pane.auto_drive_view_active()
            && !self.bottom_pane.has_active_modal_view()
        {
            tracing::debug!(
                "Auto Drive style active without view; releasing style (reason: {reason})"
            );
            self.bottom_pane.release_auto_drive_style();
        }
        if !self.bottom_pane.is_task_running() {
            tracing::debug!("Activity without spinner; re-enabling (reason: {reason})");
            self.bottom_pane.set_task_running(true);
        }
    }

    #[inline]
    fn stop_spinner(&mut self) {
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());
        self.maybe_hide_spinner();
    }

    #[cfg(any(test, feature = "test-helpers"))]
    fn seed_test_mode_greeting(&mut self) {
        if !self.test_mode {
            return;
        }
        let has_assistant = self
            .history_cells
            .iter()
            .any(|cell| matches!(cell.kind(), history_cell::HistoryCellType::Assistant));
        if has_assistant {
            return;
        }

        let sections = [
            "Hello! How can I help you today?",
            "I can help with various tasks including:\n\n- Writing code\n- Reading files\n- Running commands",
        ];

        for markdown in sections {
            let greeting_state = AssistantMessageState {
                id: HistoryId::ZERO,
                stream_id: None,
                markdown: markdown.to_string(),
                citations: Vec::new(),
                metadata: None,
                token_usage: None,
                mid_turn: false,
                created_at: SystemTime::now(),
            };
            let greeting_cell =
                history_cell::AssistantMarkdownCell::from_state(greeting_state, &self.config);
            self.history_push_top_next_req(greeting_cell);
        }
    }

    #[inline]
    fn overall_task_status_for(agents: &[AgentInfo]) -> &'static str {
        if agents.is_empty() {
            "preparing"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Running))
        {
            "running"
        } else if agents
            .iter()
            .all(|a| matches!(a.status, AgentStatus::Completed))
        {
            "complete"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Failed))
        {
            "failed"
        } else if agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Cancelled))
        {
            "cancelled"
        } else {
            "planning"
        }
    }

    /// Mark all tracked agents as having reached a terminal state when a turn finishes.
    fn finalize_agent_activity(&mut self) {
        if self.active_agents.is_empty()
            && self.agent_runtime.is_empty()
            && self.agents_terminal.entries.is_empty()
        {
            self.agents_ready_to_start = false;
            return;
        }

        for agent in self.active_agents.iter_mut() {
            if matches!(agent.status, AgentStatus::Pending | AgentStatus::Running) {
                agent.status = AgentStatus::Completed;
            }
        }

        for entry in self.agents_terminal.entries.values_mut() {
            if matches!(entry.status, AgentStatus::Pending | AgentStatus::Running) {
                entry.status = AgentStatus::Completed;
                entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(AgentStatus::Completed)),
                );
            }
        }

        self.agents_ready_to_start = false;
        let status = Self::overall_task_status_for(&self.active_agents);
        self.overall_task_status = status.to_string();
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());
        self.maybe_hide_spinner();
    }


    fn remove_background_completion_message(&mut self, call_id: &str) {
        if let Some(idx) = self.history_cells.iter().rposition(|cell| {
            matches!(cell.kind(), HistoryCellType::BackgroundEvent)
                && cell
                    .as_any()
                    .downcast_ref::<PlainHistoryCell>()
                    .map(|plain| {
                        plain.state().lines.iter().any(|line| {
                            line.spans
                                .iter()
                                .any(|span| span.text.contains(call_id))
                        })
                    })
                    .unwrap_or(false)
        }) {
            self.history_remove_at(idx);
        }
    }


    /// Flush any ExecEnd events that arrived before their matching ExecBegin.
    /// We briefly stash such ends to allow natural pairing when the Begin shows up
    /// shortly after. If the pairing window expires, render a fallback completed
    /// Exec cell so users still see the output in history.
    pub(crate) fn flush_pending_exec_ends(&mut self) {
        use std::time::Duration;
        use std::time::Instant;
        let now = Instant::now();
        // Collect keys to avoid holding a mutable borrow while iterating
        let mut ready: Vec<ExecCallId> = Vec::new();
        for (k, (_ev, _order, t0)) in self.exec.pending_exec_ends.iter() {
            if now.saturating_duration_since(*t0) >= Duration::from_millis(110) {
                ready.push(k.clone());
            }
        }
        for key in &ready {
            if let Some((ev, order, _t0)) = self.exec.pending_exec_ends.remove(&key) {
                // Regardless of whether a Begin has arrived by now, handle the End;
                // handle_exec_end_now pairs with a running Exec if present, or falls back.
                self.handle_exec_end_now(ev, &order);
            }
        }
        if !ready.is_empty() {
            self.request_redraw();
        }
    }

    /// Schedule a short-delay check to flush queued interrupts if the current
    /// stream stalls in an idle state. Avoids the UI appearing frozen when the
    /// model stops streaming before sending TaskComplete.
    fn schedule_interrupt_flush_check(&mut self) {
        if self.interrupt_flush_scheduled || !self.interrupts.has_queued() {
            return;
        }
        self.interrupt_flush_scheduled = true;
        let tx = self.app_event_tx.clone();
        let fallback_tx = tx.clone();
        if thread_spawner::spawn_lightweight("interrupt-flush", move || {
            std::thread::sleep(std::time::Duration::from_millis(180));
            tx.send(AppEvent::FlushInterruptsIfIdle);
        })
        .is_none()
        {
            let _ = fallback_tx.send(AppEvent::FlushInterruptsIfIdle);
        }
    }

    /// Finalize a stalled stream and flush queued interrupts once the stream is idle.
    /// Re-arms itself until either the stream clears or the queue drains.
    pub(crate) fn flush_interrupts_if_stream_idle(&mut self) {
        self.interrupt_flush_scheduled = false;
        if !self.stream.is_write_cycle_active() {
            if self.interrupts.has_queued() {
                self.flush_interrupt_queue();
                self.request_redraw();
            }
            return;
        }
        if self.stream.is_current_stream_idle() {
            streaming::finalize_active_stream(self);
            self.flush_interrupt_queue();
            self.request_redraw();
        } else if self.interrupts.has_queued() {
            // Still busy; try again shortly so we don't leave Exec/Tool updates stuck.
            self.schedule_interrupt_flush_check();
        }
    }

    fn finalize_all_running_as_interrupted(&mut self) {
        exec_tools::finalize_all_running_as_interrupted(self);
    }

    fn finalize_all_running_due_to_answer(&mut self) {
        exec_tools::finalize_all_running_due_to_answer(self);
    }

    fn ensure_lingering_execs_cleared(&mut self) {
        if self.cleared_lingering_execs_this_turn {
            return;
        }

        let nothing_running = self.exec.running_commands.is_empty()
            && self.tools_state.running_custom_tools.is_empty()
            && self.tools_state.running_wait_tools.is_empty()
            && self.tools_state.running_kill_tools.is_empty()
            && self.tools_state.web_search_sessions.is_empty();

        if nothing_running {
            self.cleared_lingering_execs_this_turn = true;
            return;
        }

        self.finalize_all_running_due_to_answer();
        self.cleared_lingering_execs_this_turn = true;
    }
    fn perf_label_for_item(&self, item: &dyn HistoryCell) -> String {
        use crate::history_cell::ExecKind;
        use crate::history::state::ExecStatus;
        use crate::history_cell::HistoryCellType;
        use crate::history_cell::PatchKind;
        use crate::history_cell::ToolCellStatus;
        match item.kind() {
            HistoryCellType::Plain => "Plain".to_string(),
            HistoryCellType::User => "User".to_string(),
            HistoryCellType::Assistant => "Assistant".to_string(),
            HistoryCellType::Reasoning => "Reasoning".to_string(),
            HistoryCellType::Error => "Error".to_string(),
            HistoryCellType::Exec { kind, status } => {
                let k = match kind {
                    ExecKind::Read => "Read",
                    ExecKind::Search => "Search",
                    ExecKind::List => "List",
                    ExecKind::Run => "Run",
                };
                let s = match status {
                    ExecStatus::Running => "Running",
                    ExecStatus::Success => "Success",
                    ExecStatus::Error => "Error",
                };
                format!("Exec:{}:{}", k, s)
            }
            HistoryCellType::Tool { status } => {
                let s = match status {
                    ToolCellStatus::Running => "Running",
                    ToolCellStatus::Success => "Success",
                    ToolCellStatus::Failed => "Failed",
                };
                format!("Tool:{}", s)
            }
            HistoryCellType::Patch { kind } => {
                let k = match kind {
                    PatchKind::Proposed => "Proposed",
                    PatchKind::ApplyBegin => "ApplyBegin",
                    PatchKind::ApplySuccess => "ApplySuccess",
                    PatchKind::ApplyFailure => "ApplyFailure",
                };
                format!("Patch:{}", k)
            }
            HistoryCellType::PlanUpdate => "PlanUpdate".to_string(),
            HistoryCellType::BackgroundEvent => "BackgroundEvent".to_string(),
            HistoryCellType::Notice => "Notice".to_string(),
            HistoryCellType::CompactionSummary => "CompactionSummary".to_string(),
            HistoryCellType::Diff => "Diff".to_string(),
            HistoryCellType::Image => "Image".to_string(),
            HistoryCellType::Context => "Context".to_string(),
            HistoryCellType::AnimatedWelcome => "AnimatedWelcome".to_string(),
            HistoryCellType::Loading => "Loading".to_string(),
        }
    }

    pub(crate) fn show_resume_picker(&mut self) {
        if self.resume_picker_loading {
            self.bottom_pane
                .flash_footer_notice("Still loading past sessions…".to_string());
            return;
        }
        self.resume_picker_loading = true;
        self.bottom_pane.flash_footer_notice_for(
            "Loading past sessions…".to_string(),
            std::time::Duration::from_secs(30),
        );
        self.request_redraw();

        let cwd = self.config.cwd.clone();
        let code_home = self.config.code_home.clone();
        let exclude_path = self.config.experimental_resume.clone();
        let tx = self.app_event_tx.clone();

        tokio::spawn(async move {
            let fetch_cwd = cwd.clone();
            let fetch_code_home = code_home.clone();
            let fetch_exclude = exclude_path.clone();
            let result = tokio::task::spawn_blocking(move || {
                crate::resume::discovery::list_sessions_for_cwd(
                    &fetch_cwd,
                    &fetch_code_home,
                    fetch_exclude.as_deref(),
                )
            })
            .await;

            match result {
                Ok(candidates) => {
                    tx.send(AppEvent::ResumePickerLoaded { cwd, candidates });
                }
                Err(err) => {
                    tx.send(AppEvent::ResumePickerLoadFailed {
                        message: format!("Failed to load past sessions: {}", err),
                    });
                }
            }
        });
    }

    fn resume_rows_from_candidates(
        candidates: Vec<crate::resume::discovery::ResumeCandidate>,
    ) -> Vec<crate::bottom_pane::resume_selection_view::ResumeRow> {
        fn human_ago(ts: &str) -> String {
            use chrono::{DateTime, Local};
            if let Ok(dt) = DateTime::parse_from_rfc3339(ts) {
                let local_dt = dt.with_timezone(&Local);
                let now = Local::now();
                let delta = now.signed_duration_since(local_dt);
                let secs = delta.num_seconds().max(0);
                let mins = secs / 60;
                let hours = mins / 60;
                let days = hours / 24;
                if days >= 7 {
                    return local_dt.format("%Y-%m-%d %H:%M").to_string();
                }
                if days >= 1 {
                    return format!("{}d ago", days);
                }
                if hours >= 1 {
                    return format!("{}h ago", hours);
                }
                if mins >= 1 {
                    return format!("{}m ago", mins);
                }
                return "just now".to_string();
            }
            ts.to_string()
        }

        candidates
            .into_iter()
            .map(|c| {
                let modified = human_ago(&c.modified_ts.unwrap_or_default());
                let created = human_ago(&c.created_ts.unwrap_or_default());
                let user_msgs = format!("{}", c.user_message_count);
                let branch = c.branch.unwrap_or_else(|| "-".to_string());
                let mut summary = c.snippet.unwrap_or_else(|| c.subtitle.unwrap_or_default());
                const SNIPPET_MAX: usize = 64;
                if summary.chars().count() > SNIPPET_MAX {
                    summary = summary.chars().take(SNIPPET_MAX).collect::<String>() + "…";
                }
                crate::bottom_pane::resume_selection_view::ResumeRow {
                    modified,
                    created,
                    user_msgs,
                    branch,
                    last_user_message: summary,
                    path: c.path,
                }
            })
            .collect()
    }

    pub(crate) fn present_resume_picker(
        &mut self,
        cwd: std::path::PathBuf,
        candidates: Vec<crate::resume::discovery::ResumeCandidate>,
    ) {
        self.resume_picker_loading = false;
        if candidates.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No past sessions found for this folder".to_string());
            self.request_redraw();
            return;
        }
        let rows = Self::resume_rows_from_candidates(candidates);
        let count = rows.len();
        let title = format!("Resume Session — {}", cwd.display());
        self.bottom_pane
            .show_resume_selection(title, Some(String::new()), rows);
        self.bottom_pane
            .flash_footer_notice(format!("Loaded {} past sessions.", count));
        self.request_redraw();
    }

    pub(crate) fn handle_resume_picker_load_failed(&mut self, message: String) {
        self.resume_picker_loading = false;
        self.bottom_pane.flash_footer_notice(message);
        self.request_redraw();
    }

    /// Render a single recorded ResponseItem into history without executing tools
    fn render_replay_item(&mut self, item: ResponseItem) {
        match item {
            ResponseItem::Message { id, role, content } => {
                let message_id = id;
                let mut text = String::new();
                for c in content {
                    match c {
                        ContentItem::OutputText { text: t }
                        | ContentItem::InputText { text: t } => {
                            if !text.is_empty() {
                                text.push('\n');
                            }
                            text.push_str(&t);
                        }
                        _ => {}
                    }
                }
                let text = text.trim();
                if text.is_empty() {
                    return;
                }
                if role == "user" {
                    if text.starts_with("<user_action>") {
                        return;
                    }
                    if let Some(expected) = self.pending_dispatched_user_messages.front() {
                        if expected.trim() == text {
                            self.pending_dispatched_user_messages.pop_front();
                            return;
                        }
                    }
                }
                if text.starts_with("== System Status ==") {
                    return;
            }
            if role == "assistant" {
                let normalized_new = Self::normalize_text(text);
                if let Some(last_cell) = self.history_cells.last() {
                    if let Some(existing) = last_cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::AssistantMarkdownCell>()
                    {
                        let normalized_existing =
                            Self::normalize_text(existing.markdown());
                        if normalized_existing == normalized_new {
                            tracing::debug!(
                                "replay: skipping duplicate assistant message"
                            );
                            return;
                        }
                    }
                }
                let mut lines: Vec<ratatui::text::Line<'static>> = Vec::new();
                crate::markdown::append_markdown(text, &mut lines, &self.config);
                self.insert_final_answer_with_id(message_id, lines, text.to_string());
                return;
            }
                if role == "user" {
                    let key = self.next_internal_key();
                    let state = history_cell::new_user_prompt(text.to_string());
                    let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");

                    if let Some(front) = self.queued_user_messages.front() {
                        if front.display_text.trim() == text.trim() {
                            self.queued_user_messages.pop_front();
                            self.refresh_queued_user_messages(false);
                        }
                    }
                } else {
                    let mut lines = Vec::new();
                    crate::markdown::append_markdown(text, &mut lines, &self.config);
                    let key = self.next_internal_key();
                    let state = history_cell::plain_message_state_from_lines(
                        lines,
                        history_cell::HistoryCellType::Assistant,
                    );
                    let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");
                }
            }
            ResponseItem::FunctionCall { name, arguments, call_id, .. } => {
                let mut message = self
                    .format_tool_call_preview(&name, &arguments)
                    .unwrap_or_else(|| {
                        let pretty_args = serde_json::from_str::<JsonValue>(&arguments)
                            .and_then(|v| serde_json::to_string_pretty(&v))
                            .unwrap_or_else(|_| arguments.clone());
                        let mut m = format!("🔧 Tool call: {}", name);
                        if !pretty_args.trim().is_empty() {
                            m.push_str("\n");
                            m.push_str(&pretty_args);
                        }
                        m
                    });
                if !call_id.is_empty() {
                    message.push_str(&format!("\ncall_id: {}", call_id));
                }
                let key = self.next_internal_key();
                let _ = self.history_insert_with_key_global_tagged(
                    Box::new(crate::history_cell::new_background_event(message)),
                    key,
                    "background",
                    None,
                );
            }
            ResponseItem::Reasoning { summary, .. } => {
                for s in summary {
                    let code_protocol::models::ReasoningItemReasoningSummary::SummaryText { text } =
                        s;
                    // Reasoning cell – use the existing reasoning output styling
                    let sink = crate::streaming::controller::AppEventHistorySink(
                        self.app_event_tx.clone(),
                    );
                    streaming::begin(self, StreamKind::Reasoning, None);
                    let _ = self.stream.apply_final_reasoning(&text, &sink);
                    // finalize immediately for static replay
                    self.stream
                        .finalize(crate::streaming::StreamKind::Reasoning, true, &sink);
                }
            }
            ResponseItem::FunctionCallOutput { output, call_id, .. } => {
                let mut content = output.content.clone();
                let mut metadata_summary = String::new();
                if let Ok(v) = serde_json::from_str::<JsonValue>(&content) {
                    if let Some(s) = v.get("output").and_then(|x| x.as_str()) {
                        content = s.to_string();
                    }
                    if let Some(meta) = v.get("metadata").and_then(|m| m.as_object()) {
                        let mut parts = Vec::new();
                        if let Some(code) = meta.get("exit_code").and_then(|x| x.as_i64()) {
                            parts.push(format!("exit_code={}", code));
                        }
                        if let Some(duration) =
                            meta.get("duration_seconds").and_then(|x| x.as_f64())
                        {
                            parts.push(format!("duration={:.2}s", duration));
                        }
                        if !parts.is_empty() {
                            metadata_summary = parts.join(", ");
                        }
                    }
                }
                let mut message = String::new();
                if !content.trim().is_empty() {
                    message.push_str(content.trim_end());
                }
                if !metadata_summary.is_empty() {
                    if !message.is_empty() {
                        message.push_str("\n\n");
                    }
                    message.push_str(&format!("({})", metadata_summary));
                }
                if !call_id.is_empty() {
                    if !message.is_empty() {
                        message.push_str("\n");
                    }
                    message.push_str(&format!("call_id: {}", call_id));
                }
                if message.trim().is_empty() {
                    return;
                }
                let key = self.next_internal_key();
                let _ = self.history_insert_with_key_global_tagged(
                    Box::new(crate::history_cell::new_background_event(message)),
                    key,
                    "background",
                    None,
                );
            }
            _ => {
                // Ignore other item kinds for replay (tool calls, etc.)
            }
        }
    }

    fn is_auto_review_cell(item: &dyn HistoryCell) -> bool {
        item.as_any()
            .downcast_ref::<crate::history_cell::PlainHistoryCell>()
            .map(|plain| plain.is_auto_review_notice())
            .unwrap_or(false)
    }

    fn render_cached_lines(
        &self,
        item: &dyn HistoryCell,
        layout: &CachedLayout,
        area: Rect,
        buf: &mut Buffer,
        skip_rows: u16,
    ) {
        if area.width == 0 || area.height == 0 {
            return;
        }

        let total = layout.lines.len() as u16;
        if skip_rows >= total {
            return;
        }

        debug_assert_eq!(layout.lines.len(), layout.rows.len());

        let is_assistant = matches!(item.kind(), crate::history_cell::HistoryCellType::Assistant);
        let is_auto_review = ChatWidget::is_auto_review_cell(item);
        let cell_bg = if is_assistant {
            crate::colors::assistant_bg()
        } else if is_auto_review {
            crate::history_cell::PlainHistoryCell::auto_review_bg()
        } else {
            crate::colors::background()
        };

        if is_assistant || is_auto_review {
            let bg_style = Style::default()
                .bg(cell_bg)
                .fg(crate::colors::text());
            fill_rect(buf, area, Some(' '), bg_style);
        }

        let max_rows = area.height.min(total.saturating_sub(skip_rows));
        let buf_width = buf.area.width as usize;
        let offset_x = area.x.saturating_sub(buf.area.x) as usize;
        let offset_y = area.y.saturating_sub(buf.area.y) as usize;
        let row_width = area.width as usize;

        for (visible_offset, src_index) in (skip_rows as usize..skip_rows as usize + max_rows as usize)
            .enumerate()
        {
            let src_row = layout
                .rows
                .get(src_index)
                .map(|row| row.as_ref())
                .unwrap_or(&[]);

            let dest_y = offset_y + visible_offset;
            if dest_y >= buf.area.height as usize {
                break;
            }
            let start = dest_y * buf_width + offset_x;
            if start >= buf.content.len() {
                break;
            }
            let max_width = row_width.min(buf_width.saturating_sub(offset_x));
            let end = (start + max_width).min(buf.content.len());
            if end <= start {
                continue;
            }
            let dest_slice = &mut buf.content[start..end];

            let copy_len = src_row.len().min(dest_slice.len());
            if copy_len == dest_slice.len() {
                if copy_len > 0 {
                    dest_slice.clone_from_slice(&src_row[..copy_len]);
                }
            } else {
                for (dst, src) in dest_slice.iter_mut().zip(src_row.iter()).take(copy_len) {
                    dst.clone_from(src);
                }
                for cell in dest_slice.iter_mut().skip(copy_len) {
                    cell.reset();
                }
            }

            for cell in dest_slice.iter_mut() {
                if cell.bg == ratatui::style::Color::Reset {
                    cell.bg = cell_bg;
                }
            }
        }
    }
    /// Trigger fade on the welcome cell when the composer expands (e.g., slash popup).
    pub(crate) fn on_composer_expanded(&mut self) {
        for cell in &self.history_cells {
            cell.trigger_fade();
        }
        self.request_redraw();
    }
    /// If the user is at or near the bottom, keep following new messages.
    /// We treat "near" as within 3 rows, matching our scroll step.
    fn autoscroll_if_near_bottom(&mut self) {
        layout_scroll::autoscroll_if_near_bottom(self);
    }

    fn clear_reasoning_in_progress(&mut self) {
        let last_reasoning_index = self
            .history_cells
            .iter()
            .enumerate()
            .rev()
            .find_map(|(idx, cell)| {
                cell.as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    .map(|_| idx)
            });

        let mut changed = false;
        for (idx, cell) in self.history_cells.iter().enumerate() {
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                if !reasoning_cell.is_in_progress() {
                    continue;
                }

                let keep_in_progress = !self.config.tui.show_reasoning
                    && Some(idx) == last_reasoning_index
                    && reasoning_cell.is_collapsed()
                    && !reasoning_cell.collapsed_has_summary();

                if keep_in_progress {
                    continue;
                }

                reasoning_cell.set_in_progress(false);
                changed = true;
            }
        }

        if changed {
            self.invalidate_height_cache();
        }
    }

    fn reasoning_preview(lines: &[Line<'static>]) -> String {
        const MAX_LINES: usize = 3;
        const MAX_CHARS: usize = 120;
        let mut previews: Vec<String> = Vec::new();
        for line in lines.iter().take(MAX_LINES) {
            let mut text = String::new();
            for span in &line.spans {
                text.push_str(span.content.as_ref());
            }
            if text.chars().count() > MAX_CHARS {
                let mut truncated: String = text.chars().take(MAX_CHARS).collect();
                truncated.push('…');
                previews.push(truncated);
            } else {
                previews.push(text);
            }
        }
        if previews.is_empty() {
            String::new()
        } else {
            previews.join(" ⏐ ")
        }
    }

    fn refresh_reasoning_collapsed_visibility(&mut self) {
        let show = self.config.tui.show_reasoning;
        let mut needs_invalidate = false;
        if show {
            for cell in &self.history_cells {
                if let Some(reasoning_cell) = cell
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                {
                    if reasoning_cell.set_hide_when_collapsed(false) {
                        needs_invalidate = true;
                    }
                }
            }
        } else {
            // When reasoning is hidden (collapsed), we still show a single summary
            // line for the most recent reasoning in any consecutive run. Earlier
            // reasoning cells in the run are hidden entirely.
            use std::collections::HashSet;
            let mut hide_indices: HashSet<usize> = HashSet::new();
            let len = self.history_cells.len();
            let mut idx = 0usize;
            while idx < len {
                let cell = &self.history_cells[idx];
                let is_reasoning = cell
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    .is_some();
                if !is_reasoning {
                    idx += 1;
                    continue;
                }

                let mut reasoning_indices: Vec<usize> = vec![idx];
                let mut j = idx + 1;
                while j < len {
                    let cell = &self.history_cells[j];

                    if cell.should_remove() {
                        j += 1;
                        continue;
                    }

                    if cell
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                    {
                        reasoning_indices.push(j);
                        j += 1;
                        continue;
                    }

                    match cell.kind() {
                        history_cell::HistoryCellType::PlanUpdate
                        | history_cell::HistoryCellType::Loading => {
                            j += 1;
                            continue;
                        }
                        _ => {}
                    }

                    if cell
                        .as_any()
                        .downcast_ref::<history_cell::WaitStatusCell>()
                        .is_some()
                    {
                        j += 1;
                        continue;
                    }

                    if self.cell_lines_trimmed_is_empty(j, cell.as_ref()) {
                        j += 1;
                        continue;
                    }

                    break;
                }

                if reasoning_indices.len() > 1 {
                    for &ri in &reasoning_indices[..reasoning_indices.len() - 1] {
                        hide_indices.insert(ri);
                    }
                }

                idx = j;
            }

            for (i, cell) in self.history_cells.iter().enumerate() {
                if let Some(reasoning_cell) = cell
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                {
                    let hide = hide_indices.contains(&i);
                    if reasoning_cell.set_hide_when_collapsed(hide) {
                        needs_invalidate = true;
                    }
                }
            }
        }

        if needs_invalidate {
            self.invalidate_height_cache();
            self.request_redraw();
        }

        self.refresh_explore_trailing_flags();
    }

    /// Handle streaming delta for both answer and reasoning
    // Legacy helper removed: streaming now requires explicit sequence numbers.
    // Call sites should invoke `streaming::delta_text(self, kind, id, delta, seq)` directly.

    /// Defer or handle an interrupt based on whether we're streaming
    fn defer_or_handle<F1, F2>(&mut self, defer_fn: F1, handle_fn: F2)
    where
        F1: FnOnce(&mut interrupts::InterruptManager),
        F2: FnOnce(&mut Self),
    {
        if self.is_write_cycle_active() {
            defer_fn(&mut self.interrupts);
            self.schedule_interrupt_flush_check();
        } else {
            handle_fn(self);
        }
    }

    // removed: next_sequence; plan updates are inserted immediately

    // Removed order-adjustment helpers; ordering now uses stable order keys on insert.

    /// Mark that the widget needs to be redrawn
    fn mark_needs_redraw(&mut self) {
        // Clean up fully faded cells before redraw. If any are removed,
        // invalidate the height cache since indices shift and our cache is
        // keyed by (idx,width).
        let before_len = self.history_cells.len();
        if before_len > 0 {
            let old_cells = std::mem::take(&mut self.history_cells);
            let old_ids = std::mem::take(&mut self.history_cell_ids);
            debug_assert_eq!(
                old_cells.len(),
                old_ids.len(),
                "history ids out of sync with cells"
            );
            let mut removed_any = false;
            let mut kept_cells = Vec::with_capacity(old_cells.len());
            let mut kept_ids = Vec::with_capacity(old_ids.len());
            for (cell, id) in old_cells.into_iter().zip(old_ids.into_iter()) {
                if cell.should_remove() {
                    removed_any = true;
                    continue;
                }
                kept_ids.push(id);
                kept_cells.push(cell);
            }
            self.history_cells = kept_cells;
            self.history_cell_ids = kept_ids;
            if removed_any {
                self.invalidate_height_cache();
            }
        } else if !self.history_cell_ids.is_empty() {
            self.history_cell_ids.clear();
        }

        // Send a redraw event to trigger UI update
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    /// Clear memoized cell heights (called when history/content changes)
    fn invalidate_height_cache(&mut self) {
        self.history_render.invalidate_height_cache();
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        self.history_virtualization_sync_pending.set(true);
    }

    fn mark_render_requests_dirty(&self) {
        self.render_request_cache_dirty.set(true);
    }

    fn update_welcome_height_hint(&self, height: u16) {
        for cell in self.history_cells.iter() {
            if let Some(welcome) = cell
                .as_any()
                .downcast_ref::<crate::history_cell::AnimatedWelcomeCell>()
            {
                welcome.set_available_height(height);
            }
        }
    }

    fn is_frozen_cell(cell: &dyn HistoryCell) -> bool {
        cell.as_any().downcast_ref::<FrozenHistoryCell>().is_some()
    }

    fn history_record_for_index(&self, idx: usize) -> Option<&HistoryRecord> {
        if let Some(record) = self
            .history_cell_ids
            .get(idx)
            .and_then(|entry| entry.map(|id| self.history_state.record(id)))
            .flatten()
        {
            return Some(record);
        }

        self.history_cells
            .get(idx)
            .and_then(|cell| cell.as_any().downcast_ref::<FrozenHistoryCell>())
            .and_then(|frozen| self.history_state.record(frozen.history_id()))
    }

    fn record_from_cell_or_state(&self, idx: usize, cell: &dyn HistoryCell) -> Option<HistoryRecord> {
        history_cell::record_from_cell(cell)
            .or_else(|| self.history_record_for_index(idx).cloned())
    }

    fn render_request_seed_for_cell(&self, idx: usize, cell: &dyn HistoryCell) -> RenderRequestSeed {
        let (history_id, has_record) = if let Some(Some(id)) = self.history_cell_ids.get(idx) {
            let exists = self.history_state.index_of(*id).is_some();
            (*id, exists)
        } else {
            (HistoryId::ZERO, false)
        };

        let cell_has_custom_render = cell.has_custom_render();
        let is_streaming = cell
            .as_any()
            .downcast_ref::<crate::history_cell::StreamingContentCell>()
            .is_some();

        let mut use_cache = history_id != HistoryId::ZERO
            && has_record
            && !cell_has_custom_render
            && !cell.is_animating()
            && !is_streaming;

        let is_frozen = Self::is_frozen_cell(cell);
        let mut kind = RenderRequestKind::Legacy;
        if history_id != HistoryId::ZERO && !is_frozen {
            if let Some(record) = self.history_state.record(history_id) {
                match record {
                    HistoryRecord::Exec(_) => {
                        kind = RenderRequestKind::Exec { id: history_id };
                    }
                    HistoryRecord::MergedExec(_) => {
                        kind = RenderRequestKind::MergedExec { id: history_id };
                    }
                    HistoryRecord::Explore(_) => {
                        let hold_header = self.rendered_explore_should_hold(idx);
                        kind = RenderRequestKind::Explore {
                            id: history_id,
                            hold_header,
                            full_detail: self.is_reasoning_shown(),
                        };
                    }
                    HistoryRecord::Diff(_) => {
                        kind = RenderRequestKind::Diff { id: history_id };
                    }
                    HistoryRecord::AssistantStream(stream_state) => {
                        kind = RenderRequestKind::Streaming { id: history_id };
                        if stream_state.in_progress {
                            use_cache = false;
                        }
                    }
                    HistoryRecord::AssistantMessage(_) => {
                        kind = RenderRequestKind::Assistant { id: history_id };
                    }
                    _ => {}
                }
            }
        }

        let mut fallback_lines: Option<Rc<Vec<Line<'static>>>> = None;
        if !cell_has_custom_render && !is_streaming {
            if history_id != HistoryId::ZERO {
                if let Some(record) = self.history_state.record(history_id) {
                    if let Some(lines) = self.fallback_lines_for_record(cell, record) {
                        let cached = self.history_render.cached_fallback_lines(history_id, || lines);
                        fallback_lines = Some(cached);
                    }
                }
            } else {
                let lines = cell.display_lines_trimmed();
                if !lines.is_empty() {
                    fallback_lines = Some(Rc::new(lines));
                }
            }
        }

        RenderRequestSeed {
            history_id,
            use_cache,
            fallback_lines,
            kind,
        }
    }

    fn update_render_request_seed(&self, idx: usize) {
        let cache_len = self.render_request_cache.borrow().len();
        if cache_len != self.history_cells.len() {
            self.render_request_cache_dirty.set(true);
            return;
        }

        if let Some(cell) = self.history_cells.get(idx) {
            let seed = self.render_request_seed_for_cell(idx, cell.as_ref());
            self.render_request_cache.borrow_mut()[idx] = seed;
        }
    }

    fn rebuild_render_request_cache(&self) {
        let mut cache = self.render_request_cache.borrow_mut();
        cache.clear();
        cache.reserve(self.history_cells.len());

        for (idx, cell) in self.history_cells.iter().enumerate() {
            let seed = self.render_request_seed_for_cell(idx, cell.as_ref());
            cache.push(seed);
        }

        self.render_request_cache_dirty.set(false);
    }

    fn ensure_render_request_cache(&self) {
        if self.render_request_cache_dirty.get()
            || self.render_request_cache.borrow().len() != self.history_cells.len()
        {
            self.rebuild_render_request_cache();
        }
    }

    fn fallback_lines_for_record(
        &self,
        cell: &dyn HistoryCell,
        record: &HistoryRecord,
    ) -> Option<Vec<Line<'static>>> {
        if cell.has_custom_render() {
            return None;
        }

        let lines = cell.display_lines_trimmed();
        if !lines.is_empty() || matches!(record, HistoryRecord::Reasoning(_)) {
            Some(lines)
        } else {
            Some(history_cell::lines_from_record(record, &self.config))
        }
    }

    fn cell_lines_for_index(&self, idx: usize, cell: &dyn HistoryCell) -> Vec<Line<'static>> {
        if Self::is_frozen_cell(cell) {
            if let Some(record) = self.history_record_for_index(idx) {
                return history_cell::lines_from_record(record, &self.config);
            }
        }
        cell.display_lines()
    }

    fn cell_lines_trimmed_is_empty(&self, idx: usize, cell: &dyn HistoryCell) -> bool {
        if Self::is_frozen_cell(cell) {
            if let Some(record) = self.history_record_for_index(idx) {
                return history_cell::lines_from_record(record, &self.config).is_empty();
            }
        }
        cell.display_lines_trimmed().is_empty()
    }

    fn cell_lines_for_terminal_index(
        &self,
        idx: usize,
        cell: &dyn HistoryCell,
    ) -> Vec<Line<'static>> {
        if Self::is_frozen_cell(cell) {
            if let Some(record) = self.history_record_for_index(idx) {
                return history_cell::cell_from_record(record, &self.config).display_lines();
            }
        }
        cell.display_lines()
    }

    fn freeze_eligible_record(&self, record: &HistoryRecord) -> bool {
        match record {
            HistoryRecord::PlainMessage(_)
            | HistoryRecord::AssistantMessage(_)
            | HistoryRecord::BackgroundEvent(_)
            | HistoryRecord::Notice(_)
            | HistoryRecord::Diff(_)
            | HistoryRecord::Patch(_)
            | HistoryRecord::Image(_)
            | HistoryRecord::UpgradeNotice(_)
            | HistoryRecord::RateLimits(_) => true,
            HistoryRecord::Exec(state) => !matches!(state.status, ExecStatus::Running),
            HistoryRecord::MergedExec(_) => true,
            HistoryRecord::ToolCall(state) => state.status != ToolStatus::Running,
            HistoryRecord::AssistantStream(state) => !state.in_progress,
            _ => false,
        }
    }

    fn freeze_history_cell_at(&mut self, idx: usize, render_settings: RenderSettings) -> bool {
        if idx >= self.history_cells.len() {
            return false;
        }
        let Some(Some(history_id)) = self.history_cell_ids.get(idx) else {
            return false;
        };
        let Some(record) = self.history_state.record(*history_id) else {
            return false;
        };
        if !self.freeze_eligible_record(record) {
            return false;
        }
        let cell = &self.history_cells[idx];
        if Self::is_frozen_cell(cell.as_ref()) || cell.is_animating() {
            return false;
        }

        let cached_height = self
            .history_render
            .cached_height(*history_id, render_settings)
            .unwrap_or_else(|| cell.desired_height(render_settings.width));
        let frozen = FrozenHistoryCell::new(
            *history_id,
            cell.kind(),
            render_settings.width,
            cached_height,
        );
        self.history_cells[idx] = Box::new(frozen);
        self.history_frozen_count = self.history_frozen_count.saturating_add(1);
        self.update_render_request_seed(idx);
        true
    }

    fn thaw_history_cell_at(&mut self, idx: usize) -> bool {
        if idx >= self.history_cells.len() {
            return false;
        }
        let Some(frozen) = self.history_cells[idx]
            .as_any()
            .downcast_ref::<FrozenHistoryCell>()
        else {
            return false;
        };

        let history_id = frozen.history_id();
        let Some(record) = self.history_state.record(history_id).cloned() else {
            return false;
        };
        let mut cell = match self.build_cell_from_record(&record) {
            Some(cell) => cell,
            None => return false,
        };
        Self::assign_history_id_inner(&mut cell, history_id);
        self.history_cells[idx] = cell;
        if idx < self.history_cell_ids.len() {
            self.history_cell_ids[idx] = Some(history_id);
        }
        self.history_frozen_count = self.history_frozen_count.saturating_sub(1);
        self.update_render_request_seed(idx);
        true
    }

    fn refresh_frozen_heights(&mut self, render_settings: RenderSettings) {
        let width = render_settings.width;
        if self.history_frozen_width == width {
            return;
        }

        for idx in 0..self.history_cells.len() {
            let (history_id, cached_width, cached_height) = match self.history_cells[idx]
                .as_any()
                .downcast_ref::<FrozenHistoryCell>()
            {
                Some(frozen) => (frozen.history_id(), frozen.cached_width(), frozen.cached_height()),
                None => continue,
            };

            if cached_width == width {
                continue;
            }

            let height = self
                .history_render
                .cached_height(history_id, render_settings)
                .or_else(|| {
                    self.history_state.record(history_id).cloned().and_then(|record| {
                        self.build_cell_from_record(&record)
                            .map(|cell| cell.desired_height(width))
                    })
                })
                .unwrap_or(cached_height);

            if let Some(frozen) = self.history_cells[idx]
                .as_any_mut()
                .downcast_mut::<FrozenHistoryCell>()
            {
                frozen.update_cached_height(width, height);
            }
        }

        self.history_frozen_width = width;
    }

    fn thaw_range(&mut self, start: usize, end: usize) -> bool {
        let mut changed = false;
        let upper = end.min(self.history_cells.len());
        for idx in start.min(self.history_cells.len())..upper {
            if self.thaw_history_cell_at(idx) {
                changed = true;
            }
        }
        changed
    }

    fn freeze_range(&mut self, start: usize, end: usize, render_settings: RenderSettings) -> bool {
        let mut changed = false;
        let upper = end.min(self.history_cells.len());
        for idx in start.min(self.history_cells.len())..upper {
            if self.freeze_history_cell_at(idx, render_settings) {
                changed = true;
            }
        }
        changed
    }

    fn update_history_live_window(
        &mut self,
        scroll_pos: u16,
        viewport_rows: u16,
        total_height: u16,
        render_settings: RenderSettings,
    ) -> bool {
        if self.history_cells.is_empty() || viewport_rows == 0 {
            self.history_live_window = None;
            return false;
        }
        let history_len = self.history_cells.len();
        let new_range = if scroll_pos >= total_height {
            // Tail-only content fills the viewport; keep all history frozen.
            (history_len, history_len)
        } else {
            let live_margin = viewport_rows / 2;
            let live_start = scroll_pos.saturating_sub(live_margin);
            let live_end = scroll_pos
                .saturating_add(viewport_rows)
                .saturating_add(live_margin)
                .min(total_height);

            let (mut start_idx, mut end_idx) = {
                let ps_ref = self.history_render.prefix_sums.borrow();
                let ps: &Vec<u16> = &ps_ref;
                if ps.len() <= 1 {
                    return false;
                }

                let start_idx = match ps.binary_search(&live_start) {
                    Ok(i) => i,
                    Err(i) => i.saturating_sub(1),
                };
                let end_idx = match ps.binary_search(&live_end) {
                    Ok(i) => i,
                    Err(i) => i,
                };

                (start_idx, end_idx)
            };

            start_idx = start_idx.min(history_len);
            end_idx = end_idx.min(history_len);
            if start_idx > end_idx {
                start_idx = end_idx;
            }

            (start_idx, end_idx)
        };
        if self.history_live_window == Some(new_range) {
            return false;
        }

        let mut changed = false;
        if let Some((prev_start, prev_end)) = self.history_live_window {
            if new_range.0 < prev_start {
                changed |= self.thaw_range(new_range.0, prev_start);
            }
            if prev_end < new_range.1 {
                changed |= self.thaw_range(prev_end, new_range.1);
            }
            if prev_start < new_range.0 {
                changed |= self.freeze_range(prev_start, new_range.0, render_settings);
            }
            if new_range.1 < prev_end {
                changed |= self.freeze_range(new_range.1, prev_end, render_settings);
            }
        } else {
            changed |= self.thaw_range(new_range.0, new_range.1);
            changed |= self.freeze_range(0, new_range.0, render_settings);
            changed |= self.freeze_range(new_range.1, history_len, render_settings);
        }

        self.history_live_window = Some(new_range);
        changed
    }

    pub(crate) fn sync_history_virtualization(&mut self) {
        self.history_virtualization_sync_pending.set(false);
        self.ensure_render_request_cache();
        let render_settings = self.last_render_settings.get();
        if render_settings.width == 0 {
            self.history_virtualization_sync_pending.set(true);
            return;
        }

        if self.history_cells.is_empty() {
            self.history_live_window = None;
            return;
        }

        self.refresh_frozen_heights(render_settings);

        let viewport_rows = self.layout.last_history_viewport_height.get();
        if viewport_rows == 0 {
            self.history_virtualization_sync_pending.set(true);
            return;
        }
        let total_height = self.history_render.last_total_height();
        let max_scroll = total_height.saturating_sub(viewport_rows);
        let clamped_offset = self.layout.scroll_offset.min(max_scroll);
        let scroll_pos = max_scroll.saturating_sub(clamped_offset);
        let history_len = self.history_cells.len();
        let history_total = {
            let ps_ref = self.history_render.prefix_sums.borrow();
            if ps_ref.len() <= history_len {
                self.history_virtualization_sync_pending.set(true);
                return;
            }
            ps_ref[history_len]
        };
        self.update_history_live_window(
            scroll_pos,
            viewport_rows,
            history_total,
            render_settings,
        );
    }
    /// Handle exec approval request immediately
    fn handle_exec_approval_now(&mut self, _id: String, ev: ExecApprovalRequestEvent) {
        // Use call_id as the approval correlation id so responses map to the
        // exact pending approval in core (supports multiple approvals per turn).
        let approval_id = ev.call_id.clone();
        let ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane
            .push_approval_request(ApprovalRequest::Exec {
                id: approval_id,
                command: ev.command,
                reason: ev.reason,
            }, ticket);
    }

    /// Handle apply patch approval request immediately
    fn handle_apply_patch_approval_now(&mut self, _id: String, ev: ApplyPatchApprovalRequestEvent) {
        let ApplyPatchApprovalRequestEvent {
            call_id,
            changes,
            reason,
            grant_root,
        } = ev;

        // Clone for session storage before moving into history
        let changes_clone = changes.clone();
        // Surface the patch summary in the main conversation
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global(
            Box::new(history_cell::new_patch_event(
                history_cell::PatchEventType::ApprovalRequest,
                changes,
            )),
            key,
        );
        // Record change set for session diff popup (latest last)
        self.diffs.session_patch_sets.push(changes_clone);
        // For any new paths, capture an original baseline snapshot the first time we see them
        if let Some(last) = self.diffs.session_patch_sets.last() {
            for (src_path, chg) in last.iter() {
                match chg {
                    code_core::protocol::FileChange::Update {
                        move_path: Some(dest_path),
                        ..
                    } => {
                        if let Some(baseline) =
                            self.diffs.baseline_file_contents.get(src_path).cloned()
                        {
                            // Mirror baseline under destination so tabs use the new path
                            self.diffs
                                .baseline_file_contents
                                .entry(dest_path.clone())
                                .or_insert(baseline);
                        } else if !self.diffs.baseline_file_contents.contains_key(dest_path) {
                            // Snapshot from source (pre-apply)
                            let baseline = std::fs::read_to_string(src_path).unwrap_or_default();
                            self.diffs
                                .baseline_file_contents
                                .insert(dest_path.clone(), baseline);
                        }
                    }
                    _ => {
                        if !self.diffs.baseline_file_contents.contains_key(src_path) {
                            let baseline = std::fs::read_to_string(src_path).unwrap_or_default();
                            self.diffs
                                .baseline_file_contents
                                .insert(src_path.clone(), baseline);
                        }
                    }
                }
            }
        }
        // Enable Ctrl+D footer hint now that we have diffs to show
        self.bottom_pane.set_diffs_hint(true);

        // Push the approval request to the bottom pane, keyed by call_id
        let request = ApprovalRequest::ApplyPatch {
            id: call_id,
            reason,
            grant_root,
        };
        let ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane.push_approval_request(request, ticket);
    }

    /// Handle exec command begin immediately
    fn handle_exec_begin_now(
        &mut self,
        ev: ExecCommandBeginEvent,
        order: &code_core::protocol::OrderMeta,
    ) {
        exec_tools::handle_exec_begin_now(self, ev, order);
    }

    /// Common exec-begin handling used for both immediate and deferred paths.
    /// Ensures we finalize any active stream, create the running cell, and
    /// immediately apply a pending end if it arrived first.
    fn handle_exec_begin_ordered(
        &mut self,
        ev: ExecCommandBeginEvent,
        order: code_core::protocol::OrderMeta,
        seq: u64,
    ) {
        self.finalize_active_stream();
        tracing::info!(
            "[order] ExecCommandBegin call_id={} seq={}",
            ev.call_id,
            seq
        );
        self.handle_exec_begin_now(ev.clone(), &order);
        self.ensure_spinner_for_activity("exec-begin");
        if let Some((pending_end, order2, _ts)) = self
            .exec
            .pending_exec_ends
            .remove(&ExecCallId(ev.call_id.clone()))
        {
            self.handle_exec_end_now(pending_end, &order2);
        }
        if self.interrupts.has_queued() {
            self.flush_interrupt_queue();
        }
    }

    /// Handle exec command end immediately
    fn handle_exec_end_now(
        &mut self,
        ev: ExecCommandEndEvent,
        order: &code_core::protocol::OrderMeta,
    ) {
        exec_tools::handle_exec_end_now(self, ev, order);
    }

    /// Handle or defer an exec end based on whether the matching begin has
    /// already been seen. When no running entry exists yet, stash the end so
    /// it can be paired once the begin arrives, falling back to a timed flush.
    fn enqueue_or_handle_exec_end(
        &mut self,
        ev: ExecCommandEndEvent,
        order: code_core::protocol::OrderMeta,
    ) {
        let call_id = ExecCallId(ev.call_id.clone());
        let has_running = self.exec.running_commands.contains_key(&call_id);
        if has_running {
            self.handle_exec_end_now(ev, &order);
            return;
        }

        // If the history already knows about this call_id (e.g., Begin was handled
        // but running_commands was cleared), finish it immediately to avoid leaving
        // the cell stuck in a running state.
        if self
            .history_state
            .history_id_for_exec_call(call_id.as_ref())
            .is_some()
        {
            self.handle_exec_end_now(ev, &order);
            return;
        }

        self.exec
            .pending_exec_ends
            .insert(call_id, (ev, order.clone(), std::time::Instant::now()));
        let tx = self.app_event_tx.clone();
        let fallback_tx = tx.clone();
        if thread_spawner::spawn_lightweight("exec-flush", move || {
            std::thread::sleep(std::time::Duration::from_millis(120));
            tx.send(crate::app_event::AppEvent::FlushPendingExecEnds);
        })
        .is_none()
        {
            let _ = fallback_tx.send(crate::app_event::AppEvent::FlushPendingExecEnds);
        }
    }

    fn build_patch_failure_metadata(stdout: &str, stderr: &str) -> PatchFailureMetadata {
        fn sanitize(text: &str) -> String {
            let normalized = history_cell::normalize_overwrite_sequences(text);
            sanitize_for_tui(
                &normalized,
                SanitizeMode::AnsiPreserving,
                SanitizeOptions {
                    expand_tabs: true,
                    tabstop: 4,
                    debug_markers: false,
                },
            )
        }

        fn excerpt(input: &str) -> Option<String> {
            let trimmed = input.trim();
            if trimmed.is_empty() {
                return None;
            }
            const MAX_CHARS: usize = 2_000;
            const MAX_LINES: usize = 20;
            let mut excerpt = String::new();
            let mut remaining = MAX_CHARS;
            for (idx, line) in trimmed.lines().enumerate() {
                if idx >= MAX_LINES || remaining == 0 {
                    break;
                }
                let line = line.trim_end_matches('\r');
                let mut line_chars = line.chars();
                let mut chunk = String::new();
                while remaining > 0 {
                    if let Some(ch) = line_chars.next() {
                        let width = ch.len_utf8();
                        if width > remaining {
                            break;
                        }
                        chunk.push(ch);
                        remaining -= width;
                    } else {
                        break;
                    }
                }
                if chunk.len() < line.len() {
                    chunk.push('…');
                    remaining = 0;
                }
                if !excerpt.is_empty() {
                    excerpt.push('\n');
                }
                excerpt.push_str(&chunk);
                if remaining == 0 {
                    break;
                }
            }
            Some(excerpt)
        }

        let sanitized_stdout = sanitize(stdout);
        let sanitized_stderr = sanitize(stderr);
        let message = sanitized_stderr
            .lines()
            .map(str::trim)
            .find(|line| !line.is_empty())
            .map(|line| line.to_string())
            .unwrap_or_else(|| "Patch application failed".to_string());

        PatchFailureMetadata {
            message,
            stdout_excerpt: excerpt(&sanitized_stdout),
            stderr_excerpt: excerpt(&sanitized_stderr),
        }
    }

    /// If a completed exec cell sits at `idx`, attempt to merge it into the
    /// previous cell when they represent the same action header (e.g., Search, Read).

    // MCP tool call handlers now live in chatwidget::tools

    /// Handle patch apply end immediately
    fn handle_patch_apply_end_now(&mut self, ev: PatchApplyEndEvent) {
        if ev.success {
            if let Some(idx) = self.history_cells.iter().rposition(|cell| {
                matches!(
                    cell.kind(),
                    crate::history_cell::HistoryCellType::Patch {
                        kind: crate::history_cell::PatchKind::ApplyBegin
                    } | crate::history_cell::HistoryCellType::Patch {
                        kind: crate::history_cell::PatchKind::Proposed
                    }
                )
            }) {
                if let Some(record) = self
                    .history_cells
                    .get(idx)
                    .and_then(|existing| self.record_from_cell_or_state(idx, existing.as_ref()))
                {
                    if let HistoryRecord::Patch(mut patch_record) = record {
                        patch_record.patch_type = HistoryPatchEventType::ApplySuccess;
                        let record_index = self
                            .record_index_for_cell(idx)
                            .unwrap_or_else(|| self.record_index_for_position(idx));
                        let mutation = self
                            .history_state
                            .apply_domain_event(HistoryDomainEvent::Replace {
                                index: record_index,
                                record: HistoryDomainRecord::Patch(patch_record.clone()),
                            });
                        if let Some(id) = self.apply_mutation_to_cell_index(idx, mutation) {
                            if idx < self.history_cell_ids.len() {
                                self.history_cell_ids[idx] = Some(id);
                            }
                            self.maybe_hide_spinner();
                            return;
                        }
                    }
                }
            }
            self.maybe_hide_spinner();
            return;
        }

        let failure_meta = Self::build_patch_failure_metadata(&ev.stdout, &ev.stderr);
        if let Some(idx) = self.history_cells.iter().rposition(|cell| {
            matches!(
                cell.kind(),
                crate::history_cell::HistoryCellType::Patch {
                    kind: crate::history_cell::PatchKind::ApplyBegin
                } | crate::history_cell::HistoryCellType::Patch {
                    kind: crate::history_cell::PatchKind::Proposed
                }
            )
        }) {
            if let Some(record) = self
                .history_cells
                .get(idx)
                .and_then(|existing| self.record_from_cell_or_state(idx, existing.as_ref()))
            {
                if let HistoryRecord::Patch(mut patch_record) = record {
                    patch_record.patch_type = HistoryPatchEventType::ApplyFailure;
                    patch_record.failure = Some(failure_meta.clone());
                    let record_index = self
                        .record_index_for_cell(idx)
                        .unwrap_or_else(|| self.record_index_for_position(idx));
                    let mutation = self
                        .history_state
                        .apply_domain_event(HistoryDomainEvent::Replace {
                            index: record_index,
                            record: HistoryDomainRecord::Patch(patch_record.clone()),
                        });
                    if let Some(_id) = self.apply_mutation_to_cell_index(idx, mutation) {
                        self.maybe_hide_spinner();
                        return;
                    }
                }
            }
        }

        let record = PatchRecord {
            id: HistoryId::ZERO,
            patch_type: HistoryPatchEventType::ApplyFailure,
            changes: HashMap::new(),
            failure: Some(failure_meta),
        };
        let cell = history_cell::PatchSummaryCell::from_record(record.clone());
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            "patch-failure",
            Some(HistoryDomainRecord::Patch(record)),
        );
        self.maybe_hide_spinner();
    }

    fn context_ui_enabled(&self) -> bool {
        self.config.env_ctx_v2
    }

    fn set_context_summary(
        &mut self,
        mut summary: ContextSummary,
        sequence: Option<u64>,
        is_baseline: bool,
    ) {
        if let Some(seq) = sequence {
            if let Some(prev_seq) = self.context_last_sequence {
                if seq < prev_seq {
                    return;
                }
            }
            self.context_last_sequence = Some(seq);
        }

        let previous = self.context_summary.clone();

        if let Some(prev) = previous.as_ref() {
            summary.expanded = prev.expanded;
        }

        if is_baseline {
            summary.deltas.clear();
        } else if let Some(prev) = previous.as_ref() {
            summary.deltas = prev.deltas.clone();
            for delta in Self::compute_context_deltas(prev, &summary, sequence) {
                Self::push_context_delta(&mut summary.deltas, delta);
            }
        }

        if let Some(current_seq) = self.context_last_sequence {
            if let Some(browser_seq) = self.context_browser_sequence {
                if browser_seq < current_seq {
                    summary.browser_session_active = false;
                }
            } else if summary.browser_snapshot.is_none() {
                summary.browser_session_active = false;
            }
        }

        self.context_summary = Some(summary.clone());
        self.update_context_cell(summary);
    }

    fn strict_stream_ids_enabled(&self) -> bool {
        self.config.env_ctx_v2 && (self.test_mode || cfg!(debug_assertions))
    }

    fn warn_missing_stream_id(&mut self, stream_kind: &str) {
        tracing::warn!("missing stream id for {stream_kind}");
        if cfg!(debug_assertions) || self.test_mode {
            let warning = format!("Missing stream id for {stream_kind}");
            self.push_background_tail(warning);
        }
    }

    pub(crate) fn toggle_context_expansion(&mut self) {
        if !self.context_ui_enabled() {
            self.bottom_pane
                .update_status_text("Context UI disabled".to_string());
            return;
        }

        let Some(mut summary) = self.context_summary.clone() else {
            self.bottom_pane
                .update_status_text("No context available yet".to_string());
            return;
        };

        summary.expanded = !summary.expanded;
        let expanded = summary.expanded;
        self.context_summary = Some(summary.clone());
        self.update_context_cell(summary);
        self.invalidate_height_cache();
        self.request_redraw();

        let status = if expanded {
            "Context expanded"
        } else {
            "Context collapsed"
        };
        self.bottom_pane.update_status_text(status.to_string());

        if self.standard_terminal_mode {
            let mut lines = Vec::new();
            lines.push(ratatui::text::Line::from(""));
            lines.extend(self.export_transcript_lines_for_buffer());
            self.app_event_tx
                .send(crate::app_event::AppEvent::InsertHistory(lines));
        }
    }

    fn update_context_cell(&mut self, summary: ContextSummary) {
        let record = ContextRecord {
            id: HistoryId::ZERO,
            cwd: summary.cwd.clone(),
            git_branch: summary.git_branch.clone(),
            reasoning_effort: summary.reasoning_effort.clone(),
            browser_session_active: summary.browser_session_active,
            deltas: summary.deltas.clone(),
            browser_snapshot: summary.browser_snapshot.clone(),
            expanded: summary.expanded,
        };

        if let Some(id) = self.context_cell_id {
            if let Some(index) = self.history_state.index_of(id) {
                let mutation = self.history_state.apply_domain_event(HistoryDomainEvent::Replace {
                    index,
                    record: HistoryDomainRecord::Context(record.clone()),
                });
                if let Some(cell_idx) = self.cell_index_for_history_id(id) {
                    if let Some(new_id) = self.apply_mutation_to_cell_index(cell_idx, mutation) {
                        self.context_cell_id = Some(new_id);
                    }
                }
                self.mark_history_dirty();
                self.request_redraw();
                return;
            }
        }

        let insertion = self.history_state.apply_domain_event(HistoryDomainEvent::Insert {
            index: 0,
            record: HistoryDomainRecord::Context(record.clone()),
        });

        if let HistoryMutation::Inserted { id, record, .. } = insertion {
            if let Some(mut cell) = self.build_cell_from_record(&record) {
                self.assign_history_id(&mut cell, id);
                let idx = self.history_insert_existing_record(
                    cell,
                    Self::context_order_key(),
                    "context",
                    id,
                );
                if idx < self.history_cell_ids.len() {
                    self.history_cell_ids[idx] = Some(id);
                } else {
                    self.history_cell_ids.push(Some(id));
                }
                self.context_cell_id = Some(id);
                self.mark_history_dirty();
                self.request_redraw();
            }
        }
    }

    fn compute_context_deltas(
        previous: &ContextSummary,
        current: &ContextSummary,
        sequence: Option<u64>,
    ) -> Vec<ContextDeltaRecord> {
        let mut deltas = Vec::new();

        if previous.cwd != current.cwd {
            deltas.push(ContextDeltaRecord {
                field: ContextDeltaField::Cwd,
                previous: previous.cwd.clone(),
                current: current.cwd.clone(),
                sequence,
            });
        }

        if previous.git_branch != current.git_branch {
            deltas.push(ContextDeltaRecord {
                field: ContextDeltaField::GitBranch,
                previous: previous.git_branch.clone(),
                current: current.git_branch.clone(),
                sequence,
            });
        }

        if previous.reasoning_effort != current.reasoning_effort {
            deltas.push(ContextDeltaRecord {
                field: ContextDeltaField::ReasoningEffort,
                previous: previous.reasoning_effort.clone(),
                current: current.reasoning_effort.clone(),
                sequence,
            });
        }

        if previous.browser_snapshot != current.browser_snapshot {
            let prev_label = previous
                .browser_snapshot
                .as_ref()
                .and_then(Self::context_snapshot_label);
            let next_label = current
                .browser_snapshot
                .as_ref()
                .and_then(Self::context_snapshot_label);
            deltas.push(ContextDeltaRecord {
                field: ContextDeltaField::BrowserSnapshot,
                previous: prev_label,
                current: next_label,
                sequence,
            });
        }

        deltas
    }

    fn push_context_delta(deltas: &mut Vec<ContextDeltaRecord>, mut delta: ContextDeltaRecord) {
        if delta.previous == delta.current {
            return;
        }

        if let Some(last) = deltas.last() {
            if last.field == delta.field && last.current == delta.current {
                return;
            }
        }

        if deltas.len() >= CONTEXT_DELTA_HISTORY {
            let excess = deltas.len() + 1 - CONTEXT_DELTA_HISTORY;
            deltas.drain(0..excess);
        }

        if delta.field == ContextDeltaField::BrowserSnapshot
            && delta.current.is_none()
            && delta.previous.is_some()
        {
            delta.current = Some("inactive".to_string());
        }

        deltas.push(delta);
    }

    fn context_snapshot_label(snapshot: &ContextBrowserSnapshotRecord) -> Option<String> {
        if let Some(title) = snapshot.title.as_ref().filter(|s| !s.is_empty()) {
            Some(title.clone())
        } else {
            snapshot.url.clone()
        }
    }

    fn handle_environment_context_full_event(
        &mut self,
        payload: &EnvironmentContextFullEvent,
    ) {
        if !self.context_ui_enabled() {
            return;
        }

        let mut summary = ContextSummary::default();
        if let Some(obj) = payload.snapshot.as_object() {
            if let Some(cwd) = obj.get("cwd").and_then(|v| v.as_str()) {
                summary.cwd = Some(cwd.to_string());
            }
            if let Some(branch) = obj.get("git_branch").and_then(|v| v.as_str()) {
                summary.git_branch = Some(branch.to_string());
            }
            if let Some(reason) = obj.get("reasoning_effort").and_then(|v| v.as_str()) {
                summary.reasoning_effort = Some(reason.to_string());
            }
        }

        summary.browser_session_active = false;
        self.context_browser_sequence = None;
        summary.deltas.clear();
        summary.browser_snapshot = None;
        self.set_context_summary(summary, payload.sequence, true);
    }

    fn handle_environment_context_delta_event(
        &mut self,
        payload: &EnvironmentContextDeltaEvent,
    ) {
        if !self.context_ui_enabled() {
            return;
        }

        let mut summary = self.context_summary.clone().unwrap_or_default();
        if let Some(obj) = payload.delta.as_object() {
            if let Some(changes) = obj.get("changes").and_then(|v| v.as_object()) {
                self.apply_context_changes(&mut summary, changes);
            }
        }

        self.set_context_summary(summary, payload.sequence, false);
    }

    fn handle_browser_snapshot_event(&mut self, payload: &BrowserSnapshotEvent) {
        if !self.context_ui_enabled() {
            return;
        }

        let mut summary = self.context_summary.clone().unwrap_or_default();
        summary.browser_session_active = true;
        summary.browser_snapshot = Some(Self::browser_snapshot_from_event(payload));
        self.context_browser_sequence = self.context_last_sequence;
        self.set_context_summary(summary, None, false);
    }

    fn apply_context_changes(
        &self,
        summary: &mut ContextSummary,
        changes: &serde_json::Map<String, serde_json::Value>,
    ) {
        if let Some(value) = changes.get("cwd") {
            summary.cwd = Self::value_to_optional_string(value);
        }
        if let Some(value) = changes.get("git_branch") {
            summary.git_branch = Self::value_to_optional_string(value);
        }
        if let Some(value) = changes.get("reasoning_effort") {
            summary.reasoning_effort = Self::value_to_optional_string(value);
        }
    }

    fn value_to_optional_string(value: &serde_json::Value) -> Option<String> {
        match value {
            serde_json::Value::Null => None,
            serde_json::Value::String(s) => Some(s.clone()),
            other => Some(other.to_string()),
        }
    }

    fn browser_snapshot_from_event(payload: &BrowserSnapshotEvent) -> ContextBrowserSnapshotRecord {
        use std::collections::BTreeMap;

        let mut record = ContextBrowserSnapshotRecord::default();

        if let Some(obj) = payload.snapshot.as_object() {
            if let Some(version_url) = obj.get("url").and_then(|v| v.as_str()) {
                record.url = Some(version_url.to_string());
            }
            if let Some(title) = obj.get("title").and_then(|v| v.as_str()) {
                record.title = Some(title.to_string());
            }
            if let Some(captured) = obj.get("captured_at").and_then(|v| v.as_str()) {
                record.captured_at = Some(captured.to_string());
            }
            if let Some(viewport) = obj.get("viewport").and_then(|v| v.as_object()) {
                record.width = viewport
                    .get("width")
                    .and_then(|v| v.as_u64())
                    .map(|v| v as u32);
                record.height = viewport
                    .get("height")
                    .and_then(|v| v.as_u64())
                    .map(|v| v as u32);
            }
            if let Some(meta) = obj.get("metadata").and_then(|v| v.as_object()) {
                let mut map = BTreeMap::new();
                for (key, value) in meta.iter() {
                    if let Some(v) = value.as_str() {
                        map.insert(key.clone(), v.to_string());
                    } else {
                        map.insert(key.clone(), value.to_string());
                    }
                }
                if !map.is_empty() {
                    record.metadata = map;
                }
            }
        }

        if record.url.is_none() {
            record.url = payload.url.clone();
        }

        if record.captured_at.is_none() {
            record.captured_at = payload.captured_at.clone();
        }

        record
    }

    /// Get or create the global browser manager
    async fn get_browser_manager() -> Arc<BrowserManager> {
        code_browser::global::get_or_create_browser_manager().await
    }

    pub(crate) fn insert_str(&mut self, s: &str) {
        if self.auto_state.should_show_goal_entry()
            && matches!(self.auto_goal_escape_state, AutoGoalEscState::Inactive)
            && !s.trim().is_empty()
        {
            self.auto_goal_escape_state = AutoGoalEscState::NeedsEnableEditing;
        }
        self.bottom_pane.insert_str(s);
    }

    // Removed: pending insert sequencing is not used under strict ordering.

    pub(crate) fn register_pasted_image(&mut self, placeholder: String, path: std::path::PathBuf) {
        let persisted = self
            .persist_user_image_if_needed(&path)
            .unwrap_or_else(|| path.clone());
        if persisted.exists() && persisted.is_file() {
            self.pending_images.insert(placeholder, persisted);
            self.request_redraw();
            return;
        }

        // Some terminals (notably on macOS) can drop a "promised" file path
        // (e.g., from Preview) that doesn't actually exist on disk. Fall back
        // to reading the image directly from the clipboard.
        match crate::clipboard_paste::paste_image_to_temp_png() {
            Ok((clipboard_path, _info)) => {
                let clipboard_persisted = self
                    .persist_user_image_if_needed(&clipboard_path)
                    .unwrap_or(clipboard_path);
                self.pending_images.insert(placeholder, clipboard_persisted);
                self.push_background_tail("Used clipboard image (dropped file path was missing).");
                self.request_redraw();
            }
            Err(err) => {
                tracing::warn!(
                    "dropped/pasted image path missing ({}); clipboard fallback failed: {}",
                    persisted.display(),
                    err
                );
            }
        }
    }

    fn persist_user_image_if_needed(&self, path: &std::path::Path) -> Option<PathBuf> {
        if !path.exists() || !path.is_file() {
            return None;
        }

        let temp_dir = std::env::temp_dir();
        let path_lossy = path.to_string_lossy();
        let looks_ephemeral = path.starts_with(&temp_dir)
            || path_lossy.contains("/TemporaryItems/")
            || path_lossy.contains("\\TemporaryItems\\");
        if !looks_ephemeral {
            return None;
        }

        let ext = path
            .extension()
            .and_then(|s| s.to_str())
            .unwrap_or("png")
            .to_string();

        let mut dir = self
            .config
            .code_home
            .join("working")
            .join("_pasted_images");
        if let Some(session_id) = self.session_id {
            dir = dir.join(session_id.to_string());
        }

        if let Err(err) = std::fs::create_dir_all(&dir) {
            tracing::warn!(
                "failed to create pasted image dir {}: {}",
                dir.display(),
                err
            );
            return None;
        }

        let file_name = format!("dropped-{}.{}", Uuid::new_v4(), ext);
        let dest = dir.join(file_name);

        match std::fs::copy(path, &dest) {
            Ok(_) => Some(dest),
            Err(err) => {
                tracing::warn!(
                    "failed to persist dropped image {} -> {}: {}",
                    path.display(),
                    dest.display(),
                    err
                );
                None
            }
        }
    }

    fn parse_message_with_images(&mut self, text: String) -> UserMessage {
        use std::path::Path;

        // Common image extensions
        const IMAGE_EXTENSIONS: &[&str] = &[
            ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif",
        ];
        // We keep a visible copy of the original (normalized) text for history
        let mut display_text = text.clone();
        let mut ordered_items: Vec<InputItem> = Vec::new();

        // First, handle [image: ...] placeholders from drag-and-drop
        let placeholder_regex = regex_lite::Regex::new(r"\[image: [^\]]+\]").unwrap();
        let mut cursor = 0usize;
        for mat in placeholder_regex.find_iter(&text) {
            // Push preceding text as a text item (if any)
            if mat.start() > cursor {
                let chunk = &text[cursor..mat.start()];
                if !chunk.trim().is_empty() {
                    ordered_items.push(InputItem::Text {
                        text: chunk.to_string(),
                    });
                }
            }


            let placeholder = mat.as_str();
            if placeholder.starts_with("[image:") {
                if let Some(path) = self.pending_images.remove(placeholder) {
                    if path.exists() && path.is_file() {
                        // Emit the placeholder marker verbatim followed by the image so the LLM sees placement
                        ordered_items.push(InputItem::Text {
                            text: placeholder.to_string(),
                        });
                        ordered_items.push(InputItem::LocalImage { path });
                    } else {
                        tracing::warn!(
                            "pending image placeholder {} resolved to missing path {}",
                            placeholder,
                            path.display()
                        );
                        self.push_background_tail(format!(
                            "Dropped image file went missing; not attaching ({})",
                            path.display()
                        ));
                        ordered_items.push(InputItem::Text {
                            text: placeholder.to_string(),
                        });
                    }
                } else {
                    // Unknown placeholder: preserve as text
                    ordered_items.push(InputItem::Text {
                        text: placeholder.to_string(),
                    });
                }
            } else {
                // Unknown placeholder type; preserve
                ordered_items.push(InputItem::Text {
                    text: placeholder.to_string(),
                });
            }
            cursor = mat.end();
        }
        // Push any remaining trailing text
        if cursor < text.len() {
            let chunk = &text[cursor..];
            if !chunk.trim().is_empty() {
                ordered_items.push(InputItem::Text {
                    text: chunk.to_string(),
                });
            }
        }

        // Then check for direct file paths typed into the message (no placeholder).
        // We conservatively append these at the end to avoid mis-ordering text.
        // This keeps the behavior consistent while still including the image.
        // We do NOT strip them from display_text so the user sees what they typed.
        let words: Vec<String> = text.split_whitespace().map(String::from).collect();
        for word in &words {
            if word.starts_with("[image:") {
                continue;
            }
            let is_image_path = IMAGE_EXTENSIONS
                .iter()
                .any(|ext| word.to_lowercase().ends_with(ext));
            if !is_image_path {
                continue;
            }
            let path = Path::new(word);
            if path.exists() {
                // Add a marker then the image so the LLM has contextual placement info
                let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("image");
                let persisted_path = self
                    .persist_user_image_if_needed(path)
                    .unwrap_or_else(|| path.to_path_buf());
                ordered_items.push(InputItem::Text {
                    text: format!("[image: {}]", filename),
                });
                ordered_items.push(InputItem::LocalImage {
                    path: persisted_path,
                });
            }
        }

        // Non-image paths are left as-is in the text; the model may choose to read them.

        // Preserve user formatting (retain newlines) but normalize whitespace:
        // - Normalize CRLF -> LF
        // - Trim trailing spaces per line
        // - Remove any completely blank lines at the start and end
        display_text = display_text.replace("\r\n", "\n");
        let mut _lines_tmp: Vec<String> = display_text
            .lines()
            .map(|l| l.trim_end().to_string())
            .collect();
        while _lines_tmp.first().map_or(false, |s| s.trim().is_empty()) {
            _lines_tmp.remove(0);
        }
        while _lines_tmp.last().map_or(false, |s| s.trim().is_empty()) {
            _lines_tmp.pop();
        }
        display_text = _lines_tmp.join("\n");

        UserMessage {
            display_text,
            ordered_items,
            suppress_persistence: false,
        }
    }

    /// Periodic tick to commit at most one queued line to history,
    /// animating the output.
    pub(crate) fn on_commit_tick(&mut self) {
        streaming::on_commit_tick(self);
    }
    fn is_write_cycle_active(&self) -> bool {
        streaming::is_write_cycle_active(self)
    }

    fn flush_interrupt_queue(&mut self) {
        let mut mgr = std::mem::take(&mut self.interrupts);
        mgr.flush_all(self);
        self.interrupts = mgr;
    }

    fn on_error(&mut self, message: String) {
        // Treat transient stream errors (which the core will retry) differently
        // from fatal errors so the status spinner remains visible while we wait.
        let lower = message.to_lowercase();
        let is_transient = lower.contains("retrying")
            || lower.contains("reconnecting")
            || lower.contains("disconnected")
            || lower.contains("stream error")
            || lower.contains("stream closed")
            || lower.contains("timeout")
            || lower.contains("temporar")
            || lower.contains("transport")
            || lower.contains("network")
            || lower.contains("connection")
            || lower.contains("failed to start stream");

        if is_transient {
            self.mark_reconnecting(message);
            return;
        }

        // Ensure reconnect banners are cleared once we pivot to a fatal error
        // without emitting the "Reconnected" toast (which would be misleading).
        if self.reconnect_notice_active {
            self.reconnect_notice_active = false;
            self.bottom_pane.update_status_text(String::new());
            self.request_redraw();
        }

        // Error path: show an error cell and clear running state.
        self.clear_resume_placeholder();
        let key = self.next_internal_key();
        let state = history_cell::new_error_event(message.clone());
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            "epilogue",
            Some(HistoryDomainRecord::Plain(state)),
        );
        let should_recover_auto = self.auto_state.is_active();
        self.bottom_pane.set_task_running(false);
        // Ensure any running exec/tool cells are finalized so spinners don't linger
        // after errors.
        self.finalize_all_running_as_interrupted();
        self.stream.clear_all();
        self.stream_state.drop_streaming = false;
        self.agents_ready_to_start = false;
        self.active_task_ids.clear();
        self.maybe_hide_spinner();
        if should_recover_auto {
            self.auto_pause_for_transient_failure(message);
        }
        self.mark_needs_redraw();
    }

    fn mark_reconnecting(&mut self, message: String) {
        // Keep task running and surface a concise status in the input header.
        self.bottom_pane.set_task_running(true);
        self.bottom_pane.update_status_text("Retrying...".to_string());

        if !self.reconnect_notice_active {
            self.reconnect_notice_active = true;
            self.push_background_tail(format!("Auto-retrying… ({message})"));
        }

        // Do NOT clear running state or streams; the retry will resume them.
        self.request_redraw();
    }

    fn clear_reconnecting(&mut self) {
        if !self.reconnect_notice_active {
            return;
        }
        self.reconnect_notice_active = false;
        self.bottom_pane.update_status_text(String::new());
        self.bottom_pane
            .flash_footer_notice_for("Resuming".to_string(), Duration::from_secs(2));
        self.request_redraw();
    }

    fn interrupt_running_task(&mut self) {
        let bottom_running = self.bottom_pane.is_task_running();
        let exec_related_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty();

        if !(bottom_running || exec_related_running) {
            return;
        }

        // If the user cancels mid-turn while Auto Review is enabled, preserve the
        // captured baseline so a review still runs after the next turn completes.
        if self.config.tui.auto_review_enabled
            && self.pending_auto_review_range.is_none()
            && self.background_review.is_none()
        {
            if let Some(base) = self.auto_review_baseline.take() {
                self.pending_auto_review_range = Some(PendingAutoReviewRange {
                    base,
                    // Defer to the next turn so cancellation doesn’t immediately
                    // trigger auto-review in the same (cancelled) turn.
                    defer_until_turn: Some(self.turn_sequence),
                });
            }
        }

        let mut has_wait_running = false;
        for (call_id, entry) in self.tools_state.running_custom_tools.iter() {
            if let Some(idx) = running_tools::resolve_entry_index(self, entry, &call_id.0)
            {
                if let Some(cell) = self.history_cells.get(idx).and_then(|c| c
                    .as_any()
                    .downcast_ref::<history_cell::RunningToolCallCell>())
                {
                    if cell.has_title("Waiting") {
                        has_wait_running = true;
                        break;
                    }
                }
            }
        }

        self.active_exec_cell = None;
        // Finalize any visible running indicators as interrupted (Exec/Web/Custom)
        self.finalize_all_running_as_interrupted();
        if bottom_running {
            self.bottom_pane.clear_ctrl_c_quit_hint();
        }
        // Stop any active UI streams immediately so output ceases at once.
        self.finalize_active_stream();
        self.stream_state.drop_streaming = true;
        // Surface an explicit notice in history so users see confirmation.
        if !has_wait_running {
            self.push_background_tail("Cancelled by user.".to_string());
        }
        self.submit_op(Op::Interrupt);
        // Immediately drop the running status so the next message can be typed/run,
        // even if backend cleanup (and Error event) arrives slightly later.
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.clear_live_ring();
        // Reset with max width to disable wrapping
        self.live_builder = RowBuilder::new(usize::MAX);
        // Stream state is now managed by StreamController
        self.content_buffer.clear();
        // Defensive: clear transient flags so UI can quiesce
        self.agents_ready_to_start = false;
        self.active_task_ids.clear();
        // Restore any queued messages back into the composer so the user can
        // immediately press Enter to resume the conversation where they left off.
        if !self.queued_user_messages.is_empty() {
            let existing_input = self.bottom_pane.composer_text();
            let mut segments: Vec<String> = Vec::new();

            let mut queued_block = String::new();
            for (i, qm) in self.queued_user_messages.iter().enumerate() {
                if i > 0 {
                    queued_block.push_str("\n\n");
                }
                queued_block.push_str(qm.display_text.trim_end());
            }
            if !queued_block.trim().is_empty() {
                segments.push(queued_block);
            }

            if !existing_input.trim().is_empty() {
                segments.push(existing_input);
            }

            let combined = segments.join("\n\n");
            self.clear_composer();
            if !combined.is_empty() {
                self.insert_str(&combined);
            }
            self.queued_user_messages.clear();
            self.bottom_pane.update_status_text(String::new());
            self.pending_dispatched_user_messages.clear();
            self.refresh_queued_user_messages(false);
        }
        self.maybe_hide_spinner();
        self.request_redraw();
    }
    fn layout_areas(&self, area: Rect) -> Vec<Rect> {
        layout_scroll::layout_areas(self, area)
    }
    fn finalize_active_stream(&mut self) {
        streaming::finalize_active_stream(self);
    }
    // Strict stream order key helpers
    fn seed_stream_order_key(&mut self, kind: StreamKind, id: &str, key: OrderKey) {
        self.stream_order_seq.insert((kind, id.to_string()), key);
    }
    // Try to fetch a seeded stream order key. Callers must handle None.
    fn try_stream_order_key(&self, kind: StreamKind, id: &str) -> Option<OrderKey> {
        self.stream_order_seq.get(&(kind, id.to_string())).copied()
    }

    fn default_weave_agent_name(agent_id: &str) -> String {
        let short = agent_id.split('-').next().unwrap_or(agent_id);
        format!("code-{short}")
    }

    fn resolve_weave_profile_key() -> Option<String> {
        fn read_env(key: &str) -> Option<String> {
            std::env::var(key)
                .ok()
                .as_deref()
                .map(str::trim)
                .filter(|value| !value.is_empty())
                .map(ToString::to_string)
        }

        if let Some(profile) = read_env("CODE_WEAVE_PROFILE") {
            return Some(format!("profile:{profile}"));
        }
        if let Some(iterm_session) = read_env("ITERM_SESSION_ID") {
            return Some(format!("iterm:{iterm_session}"));
        }
        if let Some(term_session) = read_env("TERM_SESSION_ID") {
            return Some(format!("term:{term_session}"));
        }
        None
    }

    fn load_weave_identity(code_home: &Path, profile_key: Option<&str>) -> (String, String, Option<u8>) {
        let prefs = read_weave_prefs(code_home);
        let mut profile = profile_key
            .and_then(|key| prefs.profiles.get(key))
            .cloned()
            .unwrap_or_default();

        // Backwards compatibility: if we have legacy (v0) values and no profile entry,
        // seed the current profile and drop the legacy fields on write.
        if profile_key.is_some()
            && profile.agent_id.is_none()
            && profile.agent_name.is_none()
            && profile.agent_accent.is_none()
        {
            profile.agent_id = prefs.agent_id.clone();
            profile.agent_name = prefs.agent_name.clone();
            profile.agent_accent = prefs.agent_accent;
        }

        let agent_id = profile
            .agent_id
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .map(ToString::to_string)
            .unwrap_or_else(|| Uuid::new_v4().to_string());

        let agent_name = profile
            .agent_name
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
            .map(ToString::to_string)
            .unwrap_or_else(|| Self::default_weave_agent_name(&agent_id));

        let accent = profile.agent_accent;

        if let Some(profile_key) = profile_key {
            let existing = prefs.profiles.get(profile_key);
            let needs_persist = existing
                .and_then(|p| {
                    let id = p.agent_id.as_deref().map(str::trim).filter(|v| !v.is_empty());
                    let name = p
                        .agent_name
                        .as_deref()
                        .map(str::trim)
                        .filter(|v| !v.is_empty());
                    let accent = p.agent_accent;
                    Some((id, name, accent))
                })
                != Some((Some(agent_id.as_str()), Some(agent_name.as_str()), accent));

            if needs_persist {
                let mut update = WeavePrefs::default();
                update.profiles.insert(
                    profile_key.to_string(),
                    WeaveProfile {
                        agent_id: Some(agent_id.clone()),
                        agent_name: Some(agent_name.clone()),
                        agent_accent: accent,
                    },
                );
                let code_home = code_home.to_path_buf();
                tokio::spawn(async move {
                    if let Err(err) = write_weave_prefs(&code_home, &update).await {
                        tracing::warn!("failed to persist weave prefs: {err}");
                    }
                });
            }
        }

        (agent_id, agent_name, accent)
    }

    fn persist_weave_identity(&self) {
        let Some(profile_key) = self.weave_profile_key.as_deref() else {
            return;
        };

        let mut prefs = WeavePrefs::default();
        prefs.profiles.insert(
            profile_key.to_string(),
            WeaveProfile {
                agent_id: Some(self.weave_agent_id.clone()),
                agent_name: Some(self.weave_agent_name.clone()),
                agent_accent: self.weave_agent_accent,
            },
        );
        let code_home = self.config.code_home.clone();
        tokio::spawn(async move {
            if let Err(err) = write_weave_prefs(&code_home, &prefs).await {
                tracing::warn!("failed to persist weave prefs: {err}");
            }
        });
    }

    fn refresh_weave_footer_status(&mut self) {
        let status = if let Some(label) = self.selected_weave_session_name.clone() {
            let conn = if self.weave_agent_connection.is_some() {
                "connected"
            } else {
                "connecting…"
            };
            format!("{} • {} ({conn})", self.weave_agent_name, label)
        } else {
            format!("{} • not connected", self.weave_agent_name)
        };
        self.bottom_pane.set_weave_status(Some(status));
    }

    pub(crate) fn new(
        mut config: Config,
        app_event_tx: AppEventSender,
        initial_prompt: Option<String>,
        initial_images: Vec<PathBuf>,
        enhanced_keys_supported: bool,
        terminal_info: crate::tui::TerminalInfo,
        show_order_overlay: bool,
        latest_upgrade_version: Option<String>,
    ) -> Self {
        let mapped_theme = crate::theme::map_theme_for_palette(
            config.tui.theme.name,
            config.tui.theme.is_dark,
        );
        config.tui.theme.name = mapped_theme;
        remember_cwd_history(&config.cwd);

        let (code_op_tx, code_op_rx) = unbounded_channel::<Op>();

        let auth_manager = AuthManager::shared_with_mode_and_originator(
            config.code_home.clone(),
            AuthMode::ApiKey,
            config.responses_originator_header.clone(),
        );

        // Browser manager is now handled through the global state
        // The core session will use the same global manager when browser tools are invoked

        // Add initial animated welcome message to history (top of first request)
        let history_cells: Vec<Box<dyn HistoryCell>> = Vec::new();
        // Insert later via history_push_top_next_req once struct is constructed

        // Removed the legacy startup tip for /resume.

        // Initialize image protocol for rendering screenshots

        let auto_drive_variant = AutoDriveVariant::from_env();
        let test_mode = is_test_mode();
        let weave_profile_key = Self::resolve_weave_profile_key();
        let (weave_agent_id, weave_agent_name, weave_agent_accent) =
            Self::load_weave_identity(&config.code_home, weave_profile_key.as_deref());
        if let Some(accent) = weave_agent_accent {
            crate::history_cell::weave::set_weave_agent_accent_override(
                weave_agent_id.clone(),
                accent,
            );
        } else {
            crate::history_cell::weave::clear_weave_agent_accent_override(&weave_agent_id);
        }

        let bottom_pane = BottomPane::new(BottomPaneParams {
            app_event_tx: app_event_tx.clone(),
            has_input_focus: true,
            enhanced_keys_supported,
            using_chatgpt_auth: config.using_chatgpt_auth,
            auto_drive_variant,
        });

        let mut new_widget = Self {
            app_event_tx: app_event_tx.clone(),
            code_op_tx,
            bottom_pane,
            auth_manager: auth_manager.clone(),
            login_view_state: None,
            login_add_view_state: None,
            active_exec_cell: None,
            history_cells,
            config: config.clone(),
            remote_model_presets: None,
            allow_remote_default_at_startup: !config.model_explicit,
            chat_model_selected_explicitly: false,
            planning_restore: None,
            history_debug_events: if history_cell_logging_enabled() {
                Some(RefCell::new(Vec::new()))
            } else {
                None
            },
            latest_upgrade_version: latest_upgrade_version.clone(),
            reconnect_notice_active: false,
            initial_user_message: create_initial_user_message(
                initial_prompt.unwrap_or_default(),
                initial_images,
            ),
            total_token_usage: TokenUsage::default(),
            last_token_usage: TokenUsage::default(),
            rate_limit_snapshot: None,
            rate_limit_warnings: RateLimitWarningState::default(),
            rate_limit_fetch_inflight: false,
            rate_limit_last_fetch_at: None,
            rate_limit_primary_next_reset_at: None,
            rate_limit_secondary_next_reset_at: None,
            rate_limit_refresh_scheduled_for: None,
            rate_limit_refresh_schedule_id: Arc::new(AtomicU64::new(0)),
            content_buffer: String::new(),
            last_assistant_message: None,
            last_answer_stream_id_in_turn: None,
            last_answer_history_id_in_turn: None,
            last_seen_answer_stream_id_in_turn: None,
            mid_turn_answer_ids_in_turn: HashSet::new(),
            last_user_message: None,
            last_developer_message: None,
            pending_turn_origin: None,
            current_turn_origin: None,
            weave_agent_id,
            weave_agent_name,
            weave_agent_accent,
            weave_profile_key,
            selected_weave_session_id: None,
            selected_weave_session_name: None,
            weave_agent_connection: None,
            weave_agents: None,
            cleared_lingering_execs_this_turn: true,
            exec: ExecState {
                running_commands: HashMap::new(),
                running_explore_agg_index: None,
                pending_exec_ends: HashMap::new(),
                suppressed_exec_end_call_ids: HashSet::new(),
                suppressed_exec_end_order: VecDeque::new(),
            },
            canceled_exec_call_ids: HashSet::new(),
            tools_state: ToolState::default(),
            // Use max width to disable wrapping during streaming
            // Text will be properly wrapped when displayed based on terminal width
            live_builder: RowBuilder::new(usize::MAX),
            header_wave: {
                let effect = HeaderWaveEffect::new();
                if ENABLE_WARP_STRIPES {
                    effect.set_enabled(true, Instant::now());
                } else {
                    effect.set_enabled(false, Instant::now());
                }
                effect
            },
            browser_overlay_visible: false,
            browser_overlay_state: BrowserOverlayState::default(),
            pending_images: HashMap::new(),
            welcome_shown: false,
            test_mode,
            latest_browser_screenshot: Arc::new(Mutex::new(None)),
            browser_autofix_requested: Arc::new(AtomicBool::new(false)),
            cached_image_protocol: RefCell::new(None),
            cached_picker: RefCell::new(terminal_info.picker.clone()),
            cached_cell_size: std::cell::OnceCell::new(),
            git_branch_cache: RefCell::new(GitBranchCache::default()),
            terminal_info,
            active_agents: Vec::new(),
            agents_ready_to_start: false,
            last_agent_prompt: None,
            agent_context: None,
            agent_task: None,
            recent_agent_hint: None,
            suppress_next_agent_hint: false,
            active_review_hint: None,
            active_review_prompt: None,
            auto_resolve_state: None,
            auto_resolve_attempts_baseline: config.auto_drive.auto_resolve_review_attempts.get(),
            turn_had_code_edits: false,
            background_review: None,
            auto_review_status: None,
            auto_review_notice: None,
            auto_review_baseline: None,
            auto_review_reviewed_marker: None,
            pending_auto_review_range: None,
            turn_sequence: 0,
            review_guard: None,
            background_review_guard: None,
            processed_auto_review_agents: HashSet::new(),
            pending_turn_descriptor: None,
            render_request_cache: RefCell::new(Vec::new()),
            render_request_cache_dirty: Cell::new(true),
            history_prefix_append_only: Cell::new(true),
            pending_auto_turn_config: None,
            overall_task_status: "preparing".to_string(),
            active_plan_title: None,
            agent_runtime: HashMap::new(),
            pending_agent_updates: HashMap::new(),
            sparkline_data: std::cell::RefCell::new(Vec::new()),
            last_sparkline_update: std::cell::RefCell::new(std::time::Instant::now()),
            stream: crate::streaming::controller::StreamController::new(config.clone()),
            stream_state: StreamState {
                current_kind: None,
                closed_answer_ids: HashSet::new(),
                closed_reasoning_ids: HashSet::new(),
                seq_answer_final: None,
                drop_streaming: false,
            },
            interrupts: interrupts::InterruptManager::new(),
            interrupt_flush_scheduled: false,
            ended_call_ids: HashSet::new(),
            diffs: DiffsState {
                session_patch_sets: Vec::new(),
                baseline_file_contents: HashMap::new(),
                overlay: None,
                confirm: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            help: HelpState {
                overlay: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            settings: SettingsState::default(),
            limits: LimitsState::default(),
            terminal: TerminalState::default(),
            pending_settings_return: None,
            pending_manual_terminal: HashMap::new(),
            agents_overview_selected_index: 0,
            agents_terminal: AgentsTerminalState::new(),
            pending_git_init_resume: None,
            git_init_inflight: false,
            git_init_declined: false,
            pending_upgrade_notice: None,
            history_render: HistoryRenderState::new(),
            last_render_settings: Cell::new(RenderSettings::new(0, 0, false)),
            render_theme_epoch: 0,
            history_state: HistoryState::new(),
            history_snapshot_dirty: false,
            history_snapshot_last_flush: None,
            context_cell_id: None,
            context_summary: None,
            context_last_sequence: None,
            context_browser_sequence: None,
            history_cell_ids: Vec::new(),
            history_live_window: None,
            history_frozen_width: 0,
            history_frozen_count: 0,
            height_manager: RefCell::new(HeightManager::new(
                crate::height_manager::HeightManagerConfig::default(),
            )),
            layout: LayoutState {
                scroll_offset: 0,
                last_max_scroll: std::cell::Cell::new(0),
                last_history_viewport_height: std::cell::Cell::new(0),
                vertical_scrollbar_state: std::cell::RefCell::new(ScrollbarState::default()),
                scrollbar_visible_until: std::cell::Cell::new(None),
                last_bottom_reserved_rows: std::cell::Cell::new(0),
                last_frame_height: std::cell::Cell::new(0),
                last_frame_width: std::cell::Cell::new(0),
            },
            last_theme: crate::theme::current_theme(),
            perf_state: PerfState {
                enabled: false,
                stats: RefCell::new(PerfStats::default()),
                pending_scroll_rows: Cell::new(0),
            },
            session_id: None,
            active_task_ids: HashSet::new(),
            queued_user_messages: std::collections::VecDeque::new(),
            pending_dispatched_user_messages: std::collections::VecDeque::new(),
            pending_user_prompts_for_next_turn: 0,
            queue_block_started_at: None,
            ghost_snapshots: Vec::new(),
            ghost_snapshots_disabled: false,
            ghost_snapshots_disabled_reason: None,
            ghost_snapshot_queue: VecDeque::new(),
            active_ghost_snapshot: None,
            next_ghost_snapshot_id: 0,
            history_virtualization_sync_pending: Cell::new(false),
            auto_drive_card_sequence: 0,
            auto_drive_variant,
            auto_state: AutoDriveController::default(),
            auto_goal_escape_state: AutoGoalEscState::Inactive,
            auto_handle: None,
            auto_drive_pid_guard: None,
            auto_history: AutoDriveHistory::new(),
            auto_compaction_overlay: None,
            auto_turn_review_state: None,
            auto_pending_goal_request: false,
            auto_goal_bootstrap_done: false,
            cloud_tasks_selected_env: None,
            cloud_tasks_environments: Vec::new(),
            cloud_tasks_last_tasks: Vec::new(),
            cloud_tasks_best_of_n: 1,
            cloud_tasks_creation_inflight: false,
            cloud_task_apply_tickets: HashMap::new(),
            cloud_task_create_ticket: None,
            browser_is_external: false,
            next_cli_text_format: None,
            // Stable ordering & routing init
            cell_order_seq: vec![OrderKey {
                req: 0,
                out: -1,
                seq: 0,
            }],
            cell_order_dbg: vec![None; 1],
            reasoning_index: HashMap::new(),
            stream_order_seq: HashMap::new(),
            order_request_bias: 0,
            resume_expected_next_request: None,
            resume_provider_baseline: None,
            last_seen_request_index: 0,
            current_request_index: 0,
            internal_seq: 0,
            show_order_overlay,
            scroll_history_hint_shown: false,
            access_status_idx: None,
            pending_agent_notes: Vec::new(),
            synthetic_system_req: None,
            system_cell_by_id: HashMap::new(),
            ui_background_seq_counters: HashMap::new(),
            last_assigned_order: None,
            standard_terminal_mode: !config.tui.alternate_screen,
            replay_history_depth: 0,
            resume_placeholder_visible: false,
            resume_picker_loading: false,
        };
        new_widget.spawn_conversation_runtime(config.clone(), auth_manager.clone(), code_op_rx);
        if let Ok(Some(active_id)) = auth_accounts::get_active_account_id(&config.code_home) {
            if let Ok(records) = account_usage::list_rate_limit_snapshots(&config.code_home) {
                if let Some(record) = records.into_iter().find(|r| r.account_id == active_id) {
                    new_widget.rate_limit_primary_next_reset_at = record.primary_next_reset_at;
                    new_widget.rate_limit_secondary_next_reset_at = record.secondary_next_reset_at;
                    new_widget.maybe_schedule_rate_limit_refresh();
                }
            }
        }
        // Seed footer access indicator based on current config
        new_widget.apply_access_mode_indicator_from_config();
        // Insert the welcome cell as top-of-first-request so future model output
        // appears below it. Also insert the Popular commands immediately so users
        // don't wait for MCP initialization to finish.
        let mut w = new_widget;
        w.refresh_weave_footer_status();
        let auto_defaults = w.config.auto_drive.clone();
        w.auto_state.review_enabled = auto_defaults.review_enabled;
        w.auto_state.subagents_enabled = auto_defaults.agents_enabled;
        w.auto_state.cross_check_enabled = auto_defaults.cross_check_enabled;
        w.auto_state.qa_automation_enabled = auto_defaults.qa_automation_enabled;
        w.auto_state.continue_mode = auto_continue_from_config(auto_defaults.continue_mode);
        w.auto_state.reset_countdown();
        w.auto_goal_escape_state = AutoGoalEscState::Inactive;
        w.set_standard_terminal_mode(!config.tui.alternate_screen);
        if config.experimental_resume.is_none() {
            w.history_push_top_next_req(history_cell::new_animated_welcome()); // tag: prelude
            let connecting_mcp = !w.config.mcp_servers.is_empty();
            if !w.config.auto_upgrade_enabled {
                if let Some(upgrade_cell) =
                    history_cell::new_upgrade_prelude(w.latest_upgrade_version.as_deref())
                {
                    w.history_push_top_next_req(upgrade_cell);
                }
            }
            let notice_state = history_cell::new_popular_commands_notice(
                false,
                w.latest_upgrade_version.as_deref(),
            );
            let notice_key = w.next_req_key_top();
            let _ = w.history_insert_plain_state_with_key(notice_state, notice_key, "prelude");
            if connecting_mcp && !w.test_mode {
                // Render connecting status as a separate cell with standard gutter and spacing
                w.history_push_top_next_req(history_cell::new_connecting_mcp_status());
            }
            // Mark welcome as shown to avoid duplicating the Popular commands section
            // when SessionConfigured arrives shortly after.
            w.welcome_shown = true;
        } else {
            w.welcome_shown = true;
            w.insert_resume_placeholder();
        }
        if w.test_mode {
            w.bottom_pane.set_task_running(false);
            w.bottom_pane.update_status_text(String::new());
            #[cfg(any(test, feature = "test-helpers"))]
            w.seed_test_mode_greeting();
        }
        w.maybe_start_auto_upgrade_task();
        w
    }

    /// Construct a ChatWidget from an existing conversation (forked session).
    pub(crate) fn new_from_existing(
        config: Config,
        conversation: std::sync::Arc<code_core::CodexConversation>,
        session_configured: SessionConfiguredEvent,
        app_event_tx: AppEventSender,
        enhanced_keys_supported: bool,
        terminal_info: crate::tui::TerminalInfo,
        show_order_overlay: bool,
        latest_upgrade_version: Option<String>,
        auth_manager: Arc<AuthManager>,
        show_welcome: bool,
    ) -> Self {
        remember_cwd_history(&config.cwd);
        let (code_op_tx, mut code_op_rx) = unbounded_channel::<Op>();

        let auto_drive_variant = AutoDriveVariant::from_env();
        let weave_profile_key = Self::resolve_weave_profile_key();
        let (weave_agent_id, weave_agent_name, weave_agent_accent) =
            Self::load_weave_identity(&config.code_home, weave_profile_key.as_deref());
        if let Some(accent) = weave_agent_accent {
            crate::history_cell::weave::set_weave_agent_accent_override(
                weave_agent_id.clone(),
                accent,
            );
        } else {
            crate::history_cell::weave::clear_weave_agent_accent_override(&weave_agent_id);
        }

        // Forward events from existing conversation
        let app_event_tx_clone = app_event_tx.clone();
        tokio::spawn(async move {
            // Send the provided SessionConfigured to the UI first
            let event = Event {
                id: "fork".to_string(),
                event_seq: 0,
                msg: EventMsg::SessionConfigured(session_configured),
                order: None,
            };
            app_event_tx_clone.send(AppEvent::CodexEvent(event));

            let conversation_clone = conversation.clone();
            tokio::spawn(async move {
                while let Some(op) = code_op_rx.recv().await {
                    let id = conversation_clone.submit(op).await;
                    if let Err(e) = id {
                        tracing::error!("failed to submit op: {e}");
                    }
                }
            });

            while let Ok(event) = conversation.next_event().await {
                app_event_tx_clone.send(AppEvent::CodexEvent(event));
            }
        });

        // Basic widget state mirrors `new`
        let history_cells: Vec<Box<dyn HistoryCell>> = Vec::new();

        let bottom_pane = BottomPane::new(BottomPaneParams {
            app_event_tx: app_event_tx.clone(),
            has_input_focus: true,
            enhanced_keys_supported,
            using_chatgpt_auth: config.using_chatgpt_auth,
            auto_drive_variant,
        });

        let mut w = Self {
            app_event_tx: app_event_tx.clone(),
            code_op_tx,
            bottom_pane,
            auth_manager: auth_manager.clone(),
            login_view_state: None,
            login_add_view_state: None,
            active_exec_cell: None,
            history_cells,
            config: config.clone(),
            remote_model_presets: None,
            allow_remote_default_at_startup: !config.model_explicit,
            chat_model_selected_explicitly: false,
            planning_restore: None,
            history_debug_events: if history_cell_logging_enabled() {
                Some(RefCell::new(Vec::new()))
            } else {
                None
            },
            latest_upgrade_version: latest_upgrade_version.clone(),
            reconnect_notice_active: false,
            initial_user_message: None,
            total_token_usage: TokenUsage::default(),
            last_token_usage: TokenUsage::default(),
            rate_limit_snapshot: None,
            rate_limit_warnings: RateLimitWarningState::default(),
            rate_limit_fetch_inflight: false,
            rate_limit_last_fetch_at: None,
            rate_limit_primary_next_reset_at: None,
            rate_limit_secondary_next_reset_at: None,
            rate_limit_refresh_scheduled_for: None,
            rate_limit_refresh_schedule_id: Arc::new(AtomicU64::new(0)),
            content_buffer: String::new(),
            last_assistant_message: None,
            last_answer_stream_id_in_turn: None,
            last_answer_history_id_in_turn: None,
            last_seen_answer_stream_id_in_turn: None,
            mid_turn_answer_ids_in_turn: HashSet::new(),
            last_user_message: None,
            last_developer_message: None,
            pending_turn_origin: None,
            current_turn_origin: None,
            weave_agent_id,
            weave_agent_name,
            weave_agent_accent,
            weave_profile_key,
            selected_weave_session_id: None,
            selected_weave_session_name: None,
            weave_agent_connection: None,
            weave_agents: None,
            cleared_lingering_execs_this_turn: true,
            exec: ExecState {
                running_commands: HashMap::new(),
                running_explore_agg_index: None,
                pending_exec_ends: HashMap::new(),
                suppressed_exec_end_call_ids: HashSet::new(),
                suppressed_exec_end_order: VecDeque::new(),
            },
            canceled_exec_call_ids: HashSet::new(),
            tools_state: ToolState {
                running_custom_tools: HashMap::new(),
                web_search_sessions: HashMap::new(),
                web_search_by_call: HashMap::new(),
                web_search_by_order: HashMap::new(),
                running_wait_tools: HashMap::new(),
                running_kill_tools: HashMap::new(),
                image_viewed_calls: HashSet::new(),
                browser_sessions: HashMap::new(),
                browser_session_by_call: HashMap::new(),
                browser_session_by_order: HashMap::new(),
                browser_last_key: None,
                agent_runs: HashMap::new(),
                agent_run_by_call: HashMap::new(),
                agent_run_by_order: HashMap::new(),
                agent_run_by_batch: HashMap::new(),
                agent_run_by_agent: HashMap::new(),
                agent_last_key: None,
                auto_drive_tracker: None,
            },
            live_builder: RowBuilder::new(usize::MAX),
            header_wave: {
                let effect = HeaderWaveEffect::new();
                if ENABLE_WARP_STRIPES {
                    effect.set_enabled(true, Instant::now());
                } else {
                    effect.set_enabled(false, Instant::now());
                }
                effect
            },
            browser_overlay_visible: false,
            browser_overlay_state: BrowserOverlayState::default(),
            pending_images: HashMap::new(),
            welcome_shown: false,
            test_mode: is_test_mode(),
            latest_browser_screenshot: Arc::new(Mutex::new(None)),
            browser_autofix_requested: Arc::new(AtomicBool::new(false)),
            cached_image_protocol: RefCell::new(None),
            cached_picker: RefCell::new(terminal_info.picker.clone()),
            cached_cell_size: std::cell::OnceCell::new(),
            git_branch_cache: RefCell::new(GitBranchCache::default()),
            terminal_info,
            active_agents: Vec::new(),
            agents_ready_to_start: false,
            last_agent_prompt: None,
            agent_context: None,
            agent_task: None,
            recent_agent_hint: None,
            suppress_next_agent_hint: false,
            active_review_hint: None,
            active_review_prompt: None,
            auto_resolve_state: None,
            auto_resolve_attempts_baseline: config.auto_drive.auto_resolve_review_attempts.get(),
            turn_had_code_edits: false,
            background_review: None,
            auto_review_status: None,
            auto_review_notice: None,
            auto_review_baseline: None,
            auto_review_reviewed_marker: None,
            pending_auto_review_range: None,
            turn_sequence: 0,
            review_guard: None,
            background_review_guard: None,
            processed_auto_review_agents: HashSet::new(),
            pending_turn_descriptor: None,
            render_request_cache: RefCell::new(Vec::new()),
            render_request_cache_dirty: Cell::new(true),
            history_prefix_append_only: Cell::new(true),
            pending_auto_turn_config: None,
            overall_task_status: "preparing".to_string(),
            active_plan_title: None,
            agent_runtime: HashMap::new(),
            pending_agent_updates: HashMap::new(),
            sparkline_data: std::cell::RefCell::new(Vec::new()),
            last_sparkline_update: std::cell::RefCell::new(std::time::Instant::now()),
            stream: crate::streaming::controller::StreamController::new(config.clone()),
            stream_state: StreamState {
                current_kind: None,
                closed_answer_ids: HashSet::new(),
                closed_reasoning_ids: HashSet::new(),
                seq_answer_final: None,
                drop_streaming: false,
            },
            interrupts: interrupts::InterruptManager::new(),
            interrupt_flush_scheduled: false,
            ended_call_ids: HashSet::new(),
            diffs: DiffsState {
                session_patch_sets: Vec::new(),
                baseline_file_contents: HashMap::new(),
                overlay: None,
                confirm: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            help: HelpState {
                overlay: None,
                body_visible_rows: std::cell::Cell::new(0),
            },
            settings: SettingsState::default(),
            pending_settings_return: None,
            limits: LimitsState::default(),
            terminal: TerminalState::default(),
            pending_manual_terminal: HashMap::new(),
            agents_overview_selected_index: 0,
            agents_terminal: AgentsTerminalState::new(),
            pending_git_init_resume: None,
            git_init_inflight: false,
            git_init_declined: false,
            pending_upgrade_notice: None,
            history_render: HistoryRenderState::new(),
            last_render_settings: Cell::new(RenderSettings::new(0, 0, false)),
            render_theme_epoch: 0,
            history_state: HistoryState::new(),
            history_snapshot_dirty: false,
            history_snapshot_last_flush: None,
            context_cell_id: None,
            context_summary: None,
            context_last_sequence: None,
            context_browser_sequence: None,
            history_cell_ids: Vec::new(),
            history_live_window: None,
            history_frozen_width: 0,
            history_frozen_count: 0,
            height_manager: RefCell::new(HeightManager::new(
                crate::height_manager::HeightManagerConfig::default(),
            )),
            layout: LayoutState {
                scroll_offset: 0,
                last_max_scroll: std::cell::Cell::new(0),
                last_history_viewport_height: std::cell::Cell::new(0),
                vertical_scrollbar_state: std::cell::RefCell::new(ScrollbarState::default()),
                scrollbar_visible_until: std::cell::Cell::new(None),
                last_bottom_reserved_rows: std::cell::Cell::new(0),
                last_frame_height: std::cell::Cell::new(0),
                last_frame_width: std::cell::Cell::new(0),
            },
            last_theme: crate::theme::current_theme(),
            perf_state: PerfState {
                enabled: false,
                stats: RefCell::new(PerfStats::default()),
                pending_scroll_rows: Cell::new(0),
            },
            session_id: None,
            active_task_ids: HashSet::new(),
            queued_user_messages: std::collections::VecDeque::new(),
            pending_dispatched_user_messages: std::collections::VecDeque::new(),
            pending_user_prompts_for_next_turn: 0,
            queue_block_started_at: None,
            ghost_snapshots: Vec::new(),
            ghost_snapshots_disabled: false,
            ghost_snapshots_disabled_reason: None,
            ghost_snapshot_queue: VecDeque::new(),
            active_ghost_snapshot: None,
            next_ghost_snapshot_id: 0,
            history_virtualization_sync_pending: Cell::new(false),
            auto_drive_card_sequence: 0,
            auto_drive_variant,
            auto_state: AutoDriveController::default(),
            auto_goal_escape_state: AutoGoalEscState::Inactive,
            auto_handle: None,
            auto_drive_pid_guard: None,
            auto_history: AutoDriveHistory::new(),
            auto_compaction_overlay: None,
            auto_turn_review_state: None,
            auto_pending_goal_request: false,
            auto_goal_bootstrap_done: false,
            cloud_tasks_selected_env: None,
            cloud_tasks_environments: Vec::new(),
            cloud_tasks_last_tasks: Vec::new(),
            cloud_tasks_best_of_n: 1,
            cloud_tasks_creation_inflight: false,
            cloud_task_apply_tickets: HashMap::new(),
            cloud_task_create_ticket: None,
            browser_is_external: false,
            next_cli_text_format: None,
            // Strict ordering init for forked widget
            cell_order_seq: vec![OrderKey {
                req: 0,
                out: -1,
                seq: 0,
            }],
            cell_order_dbg: vec![None; 1],
            reasoning_index: HashMap::new(),
            stream_order_seq: HashMap::new(),
            order_request_bias: 0,
            resume_expected_next_request: None,
            resume_provider_baseline: None,
            last_seen_request_index: 0,
            current_request_index: 0,
            internal_seq: 0,
            show_order_overlay,
            scroll_history_hint_shown: false,
            access_status_idx: None,
            standard_terminal_mode: !config.tui.alternate_screen,
            pending_agent_notes: Vec::new(),
            synthetic_system_req: None,
            system_cell_by_id: HashMap::new(),
            ui_background_seq_counters: HashMap::new(),
            last_assigned_order: None,
            replay_history_depth: 0,
            resume_placeholder_visible: false,
            resume_picker_loading: false,
        };
        if let Ok(Some(active_id)) = auth_accounts::get_active_account_id(&config.code_home) {
            if let Ok(records) = account_usage::list_rate_limit_snapshots(&config.code_home) {
                if let Some(record) = records.into_iter().find(|r| r.account_id == active_id) {
                    w.rate_limit_primary_next_reset_at = record.primary_next_reset_at;
                    w.rate_limit_secondary_next_reset_at = record.secondary_next_reset_at;
                    w.maybe_schedule_rate_limit_refresh();
                }
            }
        }
        w.set_standard_terminal_mode(!config.tui.alternate_screen);
        if show_welcome {
            w.history_push_top_next_req(history_cell::new_animated_welcome());
        }
        if w.test_mode {
            w.bottom_pane.set_task_running(false);
            w.bottom_pane.update_status_text(String::new());
            #[cfg(any(test, feature = "test-helpers"))]
            w.seed_test_mode_greeting();
        }
        w.maybe_start_auto_upgrade_task();
        w
    }

    fn auto_drive_lines_to_string(lines: Vec<Line<'static>>) -> String {
        let mut rows: Vec<String> = Vec::new();
        for line in lines {
            let mut row = String::new();
            for span in line.spans {
                row.push_str(span.content.as_ref());
            }
            rows.push(row);
        }
        while rows
            .last()
            .map(|line| line.trim().is_empty())
            .unwrap_or(false)
        {
            rows.pop();
        }
        rows.join("\n")
    }

    fn auto_drive_role_for_kind(kind: HistoryCellType) -> Option<AutoDriveRole> {
        use AutoDriveRole::{Assistant, User};
        match kind {
            HistoryCellType::User => Some(Assistant),
            HistoryCellType::Assistant
            | HistoryCellType::Reasoning
            | HistoryCellType::Error
            | HistoryCellType::Exec { .. }
            | HistoryCellType::Patch { .. }
            | HistoryCellType::PlanUpdate
            | HistoryCellType::BackgroundEvent
            | HistoryCellType::Notice
            | HistoryCellType::CompactionSummary
            | HistoryCellType::Diff
            | HistoryCellType::Plain
            | HistoryCellType::Image => Some(User),
            HistoryCellType::Context => None,
            HistoryCellType::Tool { status } => match status {
                crate::history_cell::ToolCellStatus::Running => None,
                crate::history_cell::ToolCellStatus::Success
                | crate::history_cell::ToolCellStatus::Failed => Some(User),
            },
            HistoryCellType::AnimatedWelcome | HistoryCellType::Loading => None,
        }
    }

    fn auto_drive_cell_text_for_index(&self, idx: usize, cell: &dyn HistoryCell) -> Option<String> {
        let lines = self.cell_lines_for_index(idx, cell);
        let text = Self::auto_drive_lines_to_string(lines);
        if text.trim().is_empty() {
            None
        } else {
            Some(text)
        }
    }

    fn auto_drive_make_user_message(
        text: String,
    ) -> Option<code_protocol::models::ResponseItem> {
        if text.trim().is_empty() {
            return None;
        }
        use code_protocol::models::{ContentItem, ResponseItem};
        Some(ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText { text }],
        })
    }

    fn auto_drive_browser_screenshot_items(
        cell: &BrowserSessionCell,
    ) -> Option<Vec<code_protocol::models::ContentItem>> {
        use code_protocol::models::ContentItem;

        let record = cell.screenshot_history().last()?;
        let bytes = match std::fs::read(&record.path) {
            Ok(bytes) if !bytes.is_empty() => bytes,
            Ok(_) => return None,
            Err(err) => {
                tracing::warn!(
                    "Failed to read browser screenshot for Auto Drive export: {} ({err})",
                    record.path.display()
                );
                return None;
            }
        };

        let mime = record
            .path
            .extension()
            .and_then(|ext| ext.to_str())
            .map(|ext| {
                let ext_lower = ext.to_ascii_lowercase();
                match ext_lower.as_str() {
                    "png" => "image/png",
                    "jpg" | "jpeg" => "image/jpeg",
                    "gif" => "image/gif",
                    "bmp" => "image/bmp",
                    "webp" => "image/webp",
                    "svg" => "image/svg+xml",
                    "ico" => "image/x-icon",
                    "tif" | "tiff" => "image/tiff",
                    _ => "application/octet-stream",
                }
            })
            .unwrap_or("application/octet-stream")
            .to_string();
        let encoded = BASE64_STANDARD.encode(bytes);

        let timestamp_ms = record.timestamp.as_millis();
        let raw_url = record.url.as_deref().unwrap_or("browser");
        let sanitized = raw_url.replace('\n', " ").replace('\r', " ");
        let trimmed = sanitized.trim();
        let mut url_meta = if trimmed.is_empty() {
            "browser".to_string()
        } else {
            trimmed.to_string()
        };
        if url_meta.len() > 240 {
            let mut truncated: String = url_meta.chars().take(240).collect();
            truncated.push_str("...");
            url_meta = truncated;
        }

        let metadata = format!("browser-screenshot:{}:{}", timestamp_ms, url_meta);

        let mut items = Vec::with_capacity(2);
        items.push(ContentItem::InputText {
            text: format!("[EPHEMERAL:{}]", metadata),
        });
        items.push(ContentItem::InputImage {
            image_url: format!("data:{mime};base64,{encoded}"),
        });

        Some(items)
    }

    fn auto_drive_make_assistant_message(
        text: String,
    ) -> Option<code_protocol::models::ResponseItem> {
        if text.trim().is_empty() {
            return None;
        }
        use code_protocol::models::{ContentItem, ResponseItem};
        Some(ResponseItem::Message {
            id: None,
            role: "assistant".to_string(),
            content: vec![ContentItem::OutputText { text }],
        })
    }

    fn reset_auto_compaction_overlay(&mut self) {
        self.auto_compaction_overlay = None;
    }

    fn auto_drive_normalize_diff_path(raw: &str) -> Option<String> {
        let trimmed = raw.trim();
        if trimmed == "/dev/null" {
            return None;
        }
        let normalized = trimmed
            .strip_prefix("a/")
            .or_else(|| trimmed.strip_prefix("b/"))
            .unwrap_or(trimmed);
        Some(normalized.to_string())
    }

    fn auto_drive_diff_summary(record: &DiffRecord) -> Option<String> {
        use std::collections::BTreeMap;

        let mut stats: BTreeMap<String, (u32, u32)> = BTreeMap::new();
        let mut current_file: Option<String> = None;

        for hunk in &record.hunks {
            for line in &hunk.lines {
                match line.kind {
                    DiffLineKind::Context => {
                        let content = line.content.trim();
                        if let Some(rest) = content.strip_prefix("diff --git ") {
                            let mut parts = rest.split_whitespace();
                            let _old = parts.next();
                            if let Some(new_path) = parts.next() {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(new_path) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                        } else {
                            if let Some(rest) = content.strip_prefix("--- ") {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(rest) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                            if let Some(rest) = content.strip_prefix("+++ ") {
                                if let Some(path) = Self::auto_drive_normalize_diff_path(rest) {
                                    stats.entry(path.clone()).or_insert((0, 0));
                                    current_file = Some(path);
                                }
                            }
                        }
                    }
                    DiffLineKind::Addition => {
                        if let Some(file) = current_file.as_ref() {
                            let entry = stats.entry(file.clone()).or_insert((0, 0));
                            entry.0 += 1;
                        }
                    }
                    DiffLineKind::Removal => {
                        if let Some(file) = current_file.as_ref() {
                            let entry = stats.entry(file.clone()).or_insert((0, 0));
                            entry.1 += 1;
                        }
                    }
                }
            }
        }

        if stats.is_empty() {
            return None;
        }

        let mut lines = Vec::with_capacity(stats.len() + 1);
        lines.push("Files changed".to_string());
        for (path, (added, removed)) in stats {
            lines.push(format!("- {} (+{} / -{})", path, added, removed));
        }
        Some(lines.join("\n"))
    }

    pub(crate) fn export_auto_drive_items(&self) -> Vec<code_protocol::models::ResponseItem> {
        let (items, _) = self.export_auto_drive_items_with_indices();
        items
    }

    fn export_auto_drive_items_with_indices(
        &self,
    ) -> (
        Vec<code_protocol::models::ResponseItem>,
        Vec<Option<usize>>,
    ) {
        if let Some(overlay) = &self.auto_compaction_overlay {
            let mut items = overlay.prefix_items.clone();
            let mut indices = vec![None; overlay.prefix_items.len()];
            let tail = self.export_auto_drive_items_from_index_with_indices(overlay.tail_start_cell);
            for (cell_idx, item) in tail {
                indices.push(Some(cell_idx));
                items.push(item);
            }
            (items, indices)
        } else {
            let tail = self.export_auto_drive_items_from_index_with_indices(0);
            let mut items = Vec::with_capacity(tail.len());
            let mut indices = Vec::with_capacity(tail.len());
            for (cell_idx, item) in tail {
                indices.push(Some(cell_idx));
                items.push(item);
            }
            (items, indices)
        }
    }

    fn export_auto_drive_items_from_index_with_indices(
        &self,
        start_idx: usize,
    ) -> Vec<(usize, code_protocol::models::ResponseItem)> {
        let mut items = Vec::new();
        for (idx, cell) in self.history_cells.iter().enumerate().skip(start_idx) {
            let Some(role) = Self::auto_drive_role_for_kind(cell.kind()) else {
                continue;
            };

            let text = match cell.kind() {
                HistoryCellType::Reasoning => self
                    .auto_drive_cell_text_for_index(idx, cell.as_ref())
                    .map(|text| (text, true)),
                HistoryCellType::PlanUpdate => {
                    if let Some(plan) = cell.as_any().downcast_ref::<PlanUpdateCell>() {
                        let state = plan.state();
                        let mut lines: Vec<String> = Vec::new();
                        if !state.name.trim().is_empty() {
                            lines.push(format!("Plan update: {}", state.name.trim()));
                        } else {
                            lines.push("Plan update".to_string());
                        }
                        if state.progress.total > 0 {
                            lines.push(format!(
                                "Progress: {}/{}",
                                state.progress.completed, state.progress.total
                            ));
                        }
                        if state.steps.is_empty() {
                            lines.push("(no steps recorded)".to_string());
                        } else {
                            for step in &state.steps {
                                let status_label = match step.status {
                                    StepStatus::Completed => "[completed]",
                                    StepStatus::InProgress => "[in_progress]",
                                    StepStatus::Pending => "[pending]",
                                };
                                lines.push(format!("{} {}", status_label, step.description));
                            }
                        }
                        let text = lines.join("\n");
                        Some((text, false))
                    } else {
                        self.auto_drive_cell_text_for_index(idx, cell.as_ref())
                            .map(|text| (text, false))
                    }
                }
                HistoryCellType::Diff => {
                    if let Some(diff_cell) = cell.as_any().downcast_ref::<DiffCell>() {
                        Self::auto_drive_diff_summary(diff_cell.record()).map(|text| (text, false))
                    } else {
                        self.auto_drive_cell_text_for_index(idx, cell.as_ref())
                            .map(|text| (text, false))
                    }
                }
                _ => self
                    .auto_drive_cell_text_for_index(idx, cell.as_ref())
                    .map(|text| (text, false)),
            };

            let Some((text, is_reasoning)) = text else {
                continue;
            };

            let mut extra_content = None;
            if !is_reasoning && matches!(role, AutoDriveRole::User) {
                if let Some(browser_cell) = cell
                    .as_ref()
                    .as_any()
                    .downcast_ref::<BrowserSessionCell>()
                {
                    extra_content = Self::auto_drive_browser_screenshot_items(browser_cell);
                }
            }

            let mut item = if is_reasoning {
                code_protocol::models::ResponseItem::Message {
                    id: Some("auto-drive-reasoning".to_string()),
                    role: "user".to_string(),
                    content: vec![code_protocol::models::ContentItem::InputText { text }],
                }
            } else {
                match role {
                    AutoDriveRole::Assistant => match Self::auto_drive_make_assistant_message(text) {
                        Some(item) => item,
                        None => continue,
                    },
                    AutoDriveRole::User => match Self::auto_drive_make_user_message(text) {
                        Some(item) => item,
                        None => continue,
                    },
                }
            };

            if let Some(extra) = extra_content {
                if let code_protocol::models::ResponseItem::Message { content, .. } = &mut item {
                    content.extend(extra);
                }
            }

            items.push((idx, item));
        }
        items
    }

    fn derive_compaction_overlay(
        &self,
        previous_items: &[code_protocol::models::ResponseItem],
        previous_indices: &[Option<usize>],
        new_items: &[code_protocol::models::ResponseItem],
    ) -> Option<AutoCompactionOverlay> {
        if previous_items == new_items {
            return self.auto_compaction_overlay.clone();
        }

        if new_items.is_empty() {
            return Some(AutoCompactionOverlay {
                prefix_items: Vec::new(),
                tail_start_cell: self.history_cells.len(),
            });
        }

        let max_prefix = previous_items.len().min(new_items.len());
        let mut prefix_len = 0;
        while prefix_len < max_prefix && previous_items[prefix_len] == new_items[prefix_len] {
            prefix_len += 1;
        }

        let remaining_prev = previous_items.len().saturating_sub(prefix_len);
        let remaining_new = new_items.len().saturating_sub(prefix_len);
        let mut suffix_len = 0;
        while suffix_len < remaining_prev && suffix_len < remaining_new {
            let prev_idx = previous_items.len() - 1 - suffix_len;
            let new_idx = new_items.len() - 1 - suffix_len;
            if previous_items[prev_idx] != new_items[new_idx] {
                break;
            }
            suffix_len += 1;
        }

        let mut prefix_items_end = new_items.len().saturating_sub(suffix_len);

        let tail_start_cell = if suffix_len == 0 {
            self.history_cells.len()
        } else {
            let start = previous_items.len() - suffix_len;
            previous_indices[start..]
                .iter()
                .find_map(|idx| *idx)
                .unwrap_or(self.history_cells.len())
        };

        if suffix_len > 0 && tail_start_cell == self.history_cells.len() {
            // Suffix items no longer map to on-screen cells (e.g., after repeated compactions),
            // so treat the whole conversation as the overlay prefix.
            prefix_items_end = new_items.len();
        }

        let prefix_items = new_items[..prefix_items_end].to_vec();

        Some(AutoCompactionOverlay {
            prefix_items,
            tail_start_cell,
        })
    }

    fn rebuild_auto_history(&mut self) -> Vec<code_protocol::models::ResponseItem> {
        let conversation = self.export_auto_drive_items();
        let tail = self
            .auto_history
            .replace_converted(conversation.clone());
        if !tail.is_empty() {
            self.auto_history.append_converted_tail(&tail);
        }
        self.auto_history.raw_snapshot()
    }

    fn current_auto_history(&mut self) -> Vec<code_protocol::models::ResponseItem> {
        if self.auto_history.converted_is_empty() {
            return self.rebuild_auto_history();
        }
        self.auto_history.raw_snapshot()
    }

    /// Export current user/assistant messages into ResponseItem list for forking.
    pub(crate) fn export_response_items(&self) -> Vec<code_protocol::models::ResponseItem> {
        use code_protocol::models::ContentItem;
        use code_protocol::models::ResponseItem;
        let mut items = Vec::new();
        for (idx, cell) in self.history_cells.iter().enumerate() {
            match cell.kind() {
                crate::history_cell::HistoryCellType::User => {
                    let text = self
                        .cell_lines_for_index(idx, cell.as_ref())
                        .iter()
                        .map(|l| {
                            l.spans
                                .iter()
                                .map(|s| s.content.to_string())
                                .collect::<String>()
                        })
                        .collect::<Vec<_>>()
                        .join("\n");
                    let prefixed = format!("Coordinator: {text}");
                    let content = ContentItem::InputText { text: prefixed };
                    items.push(ResponseItem::Message {
                        id: None,
                        role: "user".to_string(),
                        content: vec![content],
                    });
                }
                crate::history_cell::HistoryCellType::Assistant => {
                    let text = self
                        .cell_lines_for_index(idx, cell.as_ref())
                        .iter()
                        .map(|l| {
                            l.spans
                                .iter()
                                .map(|s| s.content.to_string())
                                .collect::<String>()
                        })
                        .collect::<Vec<_>>()
                        .join("\n");
                    let prefixed = format!("CLI: {text}");
                    let content = ContentItem::OutputText { text: prefixed };
                    items.push(ResponseItem::Message {
                        id: None,
                        role: "assistant".to_string(),
                        content: vec![content],
                    });
                }
                crate::history_cell::HistoryCellType::PlanUpdate => {
                    if let Some(plan) = cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::PlanUpdateCell>()
                    {
                        let state = plan.state();
                        let mut lines: Vec<String> = Vec::new();
                        if !state.name.trim().is_empty() {
                            lines.push(format!("Plan update: {}", state.name.trim()));
                        } else {
                            lines.push("Plan update".to_string());
                        }

                        if state.progress.total > 0 {
                            lines.push(format!(
                                "Progress: {}/{}",
                                state.progress.completed, state.progress.total
                            ));
                        }

                        if state.steps.is_empty() {
                            lines.push("(no steps recorded)".to_string());
                        } else {
                            for step in &state.steps {
                                let status_label = match step.status {
                                    StepStatus::Completed => "[completed]",
                                    StepStatus::InProgress => "[in_progress]",
                                    StepStatus::Pending => "[pending]",
                                };
                                lines.push(format!("- {} {}", status_label, step.description));
                            }
                        }

                        let text = lines.join("\n");
                        let content = ContentItem::OutputText { text };
                        items.push(ResponseItem::Message {
                            id: None,
                            role: "assistant".to_string(),
                            content: vec![content],
                        });
                    }
                }
                _ => {}
            }
        }
        items
    }

    pub(crate) fn config_ref(&self) -> &Config {
        &self.config
    }

    /// Check if there are any animations and trigger redraw if needed
    pub fn check_for_initial_animations(&mut self) {
        if self.history_cells.iter().any(|cell| cell.is_animating()) {
            if Self::auto_reduced_motion_preference() {
                return;
            }
            tracing::info!("Initial animation detected, scheduling frame");
            // Schedule initial frame for animations to ensure they start properly.
            // Use ScheduleFrameIn to avoid debounce issues with immediate RequestRedraw.
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(HISTORY_ANIMATION_FRAME_INTERVAL));
        }
    }

    /// Format model name with proper capitalization (e.g., "gpt-4" -> "GPT-4")
    fn format_model_name(&self, model_name: &str) -> String {
        fn format_segment(segment: &str) -> String {
            if segment.eq_ignore_ascii_case("codex") {
                return "Codex".to_string();
            }

            let mut chars = segment.chars();
            match chars.next() {
                Some(first) if first.is_ascii_alphabetic() => {
                    let mut formatted = String::new();
                    formatted.push(first.to_ascii_uppercase());
                    formatted.push_str(chars.as_str());
                    formatted
                }
                Some(first) => {
                    let mut formatted = String::new();
                    formatted.push(first);
                    formatted.push_str(chars.as_str());
                    formatted
                }
                None => String::new(),
            }
        }

        if let Some(rest) = model_name.strip_prefix("gpt-") {
            let formatted_rest = rest
                .split('-')
                .map(format_segment)
                .collect::<Vec<_>>()
                .join("-");
            format!("GPT-{}", formatted_rest)
        } else {
            model_name.to_string()
        }
    }

    /// Calculate the maximum scroll offset based on current content size
    #[allow(dead_code)]
    fn calculate_max_scroll_offset(&self, content_area_height: u16) -> u16 {
        let mut total_height = 0u16;

        // Calculate total content height (same logic as render method)
        for cell in &self.history_cells {
            let h = cell.desired_height(80); // Use reasonable width for height calculation
            total_height = total_height.saturating_add(h);
        }

        if let Some(ref cell) = self.active_exec_cell {
            let h = cell.desired_height(80);
            total_height = total_height.saturating_add(h);
        }

        // Max scroll is content height minus available height
        total_height.saturating_sub(content_area_height)
    }

    fn try_append_prefix_fast(
        &self,
        render_requests: &[RenderRequest<'_>],
        render_settings: RenderSettings,
        prefix_width: u16,
    ) -> bool {
        if !self.history_prefix_append_only.get() {
            return false;
        }
        if !self
            .history_render
            .can_append_prefix(prefix_width, render_requests.len())
        {
            return false;
        }
        let prev_count = self.history_render.last_prefix_count();
        if prev_count == 0 || render_requests.len() != prev_count.saturating_add(1) {
            return false;
        }
        let history_count = self.history_cells.len();
        if history_count < 2 {
            return false;
        }
        if history_count != self
            .history_render
            .last_history_count()
            .saturating_add(1)
        {
            return false;
        }
        if render_requests.len() != history_count {
            return false;
        }
        let history_tail_start = history_count - 2;
        let tail = &render_requests[history_tail_start..history_count];
        if tail.len() != 2 {
            return false;
        }
        let cells = self
            .history_render
            .visible_cells(&self.history_state, tail, render_settings);
        if cells.len() != 2 {
            return false;
        }
        let prev = &cells[0];
        let next = &cells[1];
        if prev.height == 0 || next.height == 0 {
            return false;
        }
        let prev_is_reasoning = prev
            .cell
            .and_then(|cell| cell.as_any().downcast_ref::<crate::history_cell::CollapsibleReasoningCell>())
            .is_some();
        let next_is_reasoning = next
            .cell
            .and_then(|cell| cell.as_any().downcast_ref::<crate::history_cell::CollapsibleReasoningCell>())
            .is_some();
        if prev_is_reasoning || next_is_reasoning {
            return false;
        }
        let spacing = 1u16;
        let spacing_range = self
            .history_render
            .extend_prefix_for_append(prefix_width, spacing, next.height, history_count);
        if let Some(range) = spacing_range {
            self.history_render.append_spacing_range(range);
        }
        true
    }

    pub(crate) fn handle_key_event(&mut self, key_event: KeyEvent) {
        if settings_handlers::handle_settings_key(self, key_event) {
            return;
        }
        if self.settings.overlay.is_some() {
            return;
        }
        if terminal_handlers::handle_terminal_key(self, key_event) {
            return;
        }
        if self.terminal.overlay.is_some() {
            // Block background input while the terminal overlay is visible.
            return;
        }
        // Intercept keys for overlays when active (help first, then diff)
        if help_handlers::handle_help_key(self, key_event) {
            return;
        }
        if self.help.overlay.is_some() {
            return;
        }
        if diff_handlers::handle_diff_key(self, key_event) {
            return;
        }
        if self.diffs.overlay.is_some() {
            return;
        }
        if self.browser_overlay_visible {
            let is_ctrl_b = matches!(
                key_event,
                KeyEvent {
                    code: crossterm::event::KeyCode::Char('b'),
                    modifiers: crossterm::event::KeyModifiers::CONTROL,
                    kind: KeyEventKind::Press | KeyEventKind::Repeat,
                    ..
                }
            );
            if is_ctrl_b {
                self.toggle_browser_overlay();
                return;
            }
            if self.handle_browser_overlay_key(key_event) {
                return;
            }
        }
        if key_event.kind == KeyEventKind::Press {
            self.bottom_pane.clear_ctrl_c_quit_hint();
        }

        if self.auto_state.awaiting_coordinator_submit()
            && !self.auto_state.is_paused_manual()
            && matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat)
        {
            match key_event.code {
                crossterm::event::KeyCode::Enter
                | crossterm::event::KeyCode::Char(' ') if key_event.modifiers.is_empty() => {
                    if !self.auto_state.should_bypass_coordinator_next_submit() {
                        self.auto_submit_prompt();
                    }
                    return;
                }
                crossterm::event::KeyCode::Char('e') | crossterm::event::KeyCode::Char('E')
                    if key_event.modifiers.is_empty() =>
                {
                    self.auto_pause_for_manual_edit(false);
                    return;
                }
                _ => {}
            }
        }

        // Global overlays (avoid conflicting with common editor keys):
        // - Ctrl+B: toggle Browser overlay
        // - Ctrl+A: toggle Agents terminal mode
        if let KeyEvent {
            code: crossterm::event::KeyCode::Char('b'),
            modifiers: crossterm::event::KeyModifiers::CONTROL,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            self.toggle_browser_overlay();
            return;
        }
        if let KeyEvent {
            code: crossterm::event::KeyCode::Char('a'),
            modifiers: crossterm::event::KeyModifiers::CONTROL,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            self.toggle_agents_hud();
            return;
        }
        if self.agents_terminal.active {
            use crossterm::event::KeyCode;
            if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
                return;
            }

            if let Some(pending) = self.agents_terminal.pending_stop.clone() {
                match key_event.code {
                    KeyCode::Esc | KeyCode::Char('n') => {
                        self.agents_terminal.clear_stop_prompt();
                        self.request_redraw();
                    }
                    KeyCode::Enter | KeyCode::Char('y') => {
                        self.cancel_agent_by_id(&pending.agent_id);
                        self.agents_terminal.clear_stop_prompt();
                    }
                    _ => {}
                }
                return;
            }
            match key_event.code {
                KeyCode::Esc => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.agents_terminal.focus_sidebar();
                        self.request_redraw();
                    } else {
                        self.exit_agents_terminal_mode();
                    }
                    return;
                }
                KeyCode::Right | KeyCode::Enter => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Sidebar {
                        self.agents_terminal.focus_detail();
                        self.request_redraw();
                    }
                    return;
                }
                KeyCode::Left => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.agents_terminal.focus_sidebar();
                        self.request_redraw();
                    }
                    return;
                }
                KeyCode::Tab => {
                    match self.agents_terminal.focus() {
                        AgentsTerminalFocus::Sidebar => self.agents_terminal.focus_detail(),
                        AgentsTerminalFocus::Detail => self.agents_terminal.focus_sidebar(),
                    }
                    self.request_redraw();
                    return;
                }
                KeyCode::BackTab => {
                    match self.agents_terminal.focus() {
                        AgentsTerminalFocus::Sidebar => self.agents_terminal.focus_detail(),
                        AgentsTerminalFocus::Detail => self.agents_terminal.focus_sidebar(),
                    }
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('1') => {
                    self.agents_terminal.set_tab(AgentsTerminalTab::All);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('2') => {
                    self.agents_terminal.set_tab(AgentsTerminalTab::Running);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('3') => {
                    self.agents_terminal.set_tab(AgentsTerminalTab::Failed);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('4') => {
                    self.agents_terminal.set_tab(AgentsTerminalTab::Completed);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('5') => {
                    self.agents_terminal.set_tab(AgentsTerminalTab::Review);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('[') => {
                    self.agents_terminal.jump_batch(-1);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char(']') => {
                    self.agents_terminal.jump_batch(1);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('s') => {
                    let current = self.agents_terminal.current_sidebar_entry();
                    self.agents_terminal.cycle_sort_mode();
                    self.agents_terminal.reselect_entry(current);
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('S') => {
                    self.prompt_stop_selected_agent();
                    return;
                }
                KeyCode::Char('h') => {
                    self.agents_terminal.toggle_highlights();
                    self.request_redraw();
                    return;
                }
                KeyCode::Char('a') => {
                    self.agents_terminal.toggle_actions();
                    self.request_redraw();
                    return;
                }
                KeyCode::Up => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::line_up(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_selection(-1);
                    }
                    return;
                }
                KeyCode::Down => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::line_down(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_selection(1);
                    }
                    return;
                }
                KeyCode::PageUp => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::page_up(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_page(-1);
                    }
                    return;
                }
                KeyCode::PageDown => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::page_down(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_page(1);
                    }
                    return;
                }
                KeyCode::Home => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::to_top(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_home();
                    }
                    return;
                }
                KeyCode::End => {
                    if self.agents_terminal.focus() == AgentsTerminalFocus::Detail {
                        self.sync_agents_terminal_scroll();
                        layout_scroll::to_bottom(self);
                        self.record_current_agent_scroll();
                    } else {
                        self.navigate_agents_terminal_end();
                    }
                    return;
                }
                _ => {
                    return;
                }
            }
        }

        // Fast-path PageUp/PageDown to scroll the transcript by a viewport at a time.
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::PageUp,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            layout_scroll::page_up(self);
            return;
        }
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::PageDown,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            layout_scroll::page_down(self);
            return;
        }
        // Home/End: when the composer is empty, jump the history to start/end
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::Home,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            if self.composer_is_empty() {
                layout_scroll::to_top(self);
                return;
            }
        }
        if let crossterm::event::KeyEvent {
            code: crossterm::event::KeyCode::End,
            kind: KeyEventKind::Press | KeyEventKind::Repeat,
            ..
        } = key_event
        {
            if self.composer_is_empty() {
                layout_scroll::to_bottom(self);
                return;
            }
        }

        let composer_was_empty = self.bottom_pane.composer_is_empty();
        let input_result = self.bottom_pane.handle_key_event(key_event);
        let composer_is_empty = self.bottom_pane.composer_is_empty();
        if composer_was_empty && !composer_is_empty {
            for cell in &self.history_cells {
                cell.trigger_fade();
            }
            self.request_redraw();
        }
        self.auto_sync_goal_escape_state_from_composer();

        match input_result {
            InputResult::Submitted(text) => {
                self.pending_turn_origin = Some(TurnOrigin::User);
                let cleaned = Self::strip_context_sections(&text);
                self.last_user_message = (!cleaned.trim().is_empty()).then_some(cleaned);
                if self.auto_state.should_show_goal_entry() {
                    for cell in &self.history_cells {
                        cell.trigger_fade();
                    }
                    let trimmed = text.trim();
                    if trimmed.is_empty() {
                        self.bottom_pane.set_task_running(true);
                        self.bottom_pane
                            .update_status_text("Auto Drive Goal".to_string());
                        self.clear_composer();
                        self.request_redraw();
                        return;
                    }
                    self.clear_composer();
                    self.bottom_pane.update_status_text(String::new());
                    self.bottom_pane.set_task_running(false);
                    self.handle_auto_command(Some(trimmed.to_string()));
                    return;
                }
                if self.try_handle_terminal_shortcut(&text) {
                    return;
                }
                let user_message = self.parse_message_with_images(text);
                self.submit_user_message(user_message);
            }
            InputResult::Command(_cmd) => {
                // Command was dispatched at the App layer; request redraw.
                self.app_event_tx.send(AppEvent::RequestRedraw);
            }
            InputResult::ScrollUp => {
                let before = self.layout.scroll_offset;
                // Only allow Up to navigate command history when the top view
                // cannot be scrolled at all (no scrollback available).
                if self.layout.last_max_scroll.get() == 0 {
                    if self.bottom_pane.try_history_up() {
                        self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                        return;
                    }
                }
                // Scroll up in chat history (increase offset, towards older content)
                // Use last_max_scroll computed during the previous render to avoid overshoot
                let new_offset = self
                    .layout
                    .scroll_offset
                    .saturating_add(3)
                    .min(self.layout.last_max_scroll.get());
                self.layout.scroll_offset = new_offset;
                self.flash_scrollbar();
                self.sync_history_virtualization();
                // Enable compact mode so history can use the spacer line
                if self.layout.scroll_offset > 0 {
                    self.bottom_pane.set_compact_compose(true);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::ComposerModeChange);
                    // Mark that the very next Down should continue scrolling chat (sticky)
                    self.bottom_pane.mark_next_down_scrolls_history();
                }
                self.app_event_tx.send(AppEvent::RequestRedraw);
                self.height_manager
                    .borrow_mut()
                    .record_event(HeightEvent::UserScroll);
                self.maybe_show_history_nav_hint_on_first_scroll();
                self.perf_track_scroll_delta(before, self.layout.scroll_offset);
            }
            InputResult::ScrollDown => {
                let before = self.layout.scroll_offset;
                // Only allow Down to navigate command history when the top view
                // cannot be scrolled at all (no scrollback available).
                if self.layout.last_max_scroll.get() == 0 && self.bottom_pane.history_is_browsing()
                {
                    if self.bottom_pane.try_history_down() {
                        self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                        return;
                    }
                }
                // Scroll down in chat history (decrease offset, towards bottom)
                if self.layout.scroll_offset == 0 {
                    // Already at bottom: ensure spacer above input is enabled.
                    self.bottom_pane.set_compact_compose(false);
                    self.sync_history_virtualization();
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::ComposerModeChange);
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                } else if self.layout.scroll_offset >= 3 {
                    // Move towards bottom but do NOT toggle spacer yet; wait until
                    // the user confirms by pressing Down again at bottom.
                    self.layout.scroll_offset = self.layout.scroll_offset.saturating_sub(3);
                    self.sync_history_virtualization();
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                } else if self.layout.scroll_offset > 0 {
                    // Land exactly at bottom without toggling spacer yet; require
                    // a subsequent Down to re-enable the spacer so the input
                    // doesn't move when scrolling into the line above it.
                    self.layout.scroll_offset = 0;
                    self.sync_history_virtualization();
                    self.app_event_tx.send(AppEvent::RequestRedraw);
                    self.height_manager
                        .borrow_mut()
                        .record_event(HeightEvent::UserScroll);
                    self.maybe_show_history_nav_hint_on_first_scroll();
                    self.perf_track_scroll_delta(before, self.layout.scroll_offset);
                }
                self.flash_scrollbar();
            }
            InputResult::None => {
                // Trigger redraw so input wrapping/height reflects immediately
                self.app_event_tx.send(AppEvent::RequestRedraw);
            }
        }
    }

    fn toggle_browser_overlay(&mut self) {
        let new_state = !self.browser_overlay_visible;
        self.browser_overlay_visible = new_state;
        if new_state {
            if self.agents_terminal.active {
                self.exit_agents_terminal_mode();
            }
            self.browser_overlay_state.reset();
            let session_key = self
                .tools_state
                .browser_last_key
                .clone()
                .or_else(|| self.tools_state.browser_sessions.keys().next().cloned());
            self.browser_overlay_state.set_session_key(session_key.clone());
            if let Some(key) = session_key {
                if let Some(tracker) = self.tools_state.browser_sessions.get(&key) {
                    let history_len = tracker.cell.screenshot_history().len();
                    if history_len > 0 {
                        self
                            .browser_overlay_state
                            .set_screenshot_index(history_len.saturating_sub(1));
                    }
                }
            }
        } else {
            self.browser_overlay_state.reset();
        }
        self.request_redraw();
    }

    fn handle_browser_overlay_key(&mut self, key_event: KeyEvent) -> bool {
        if !self.browser_overlay_visible {
            return false;
        }
        if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
            return true;
        }

        let shift = key_event.modifiers.contains(KeyModifiers::SHIFT);
        let ctrl = key_event.modifiers.contains(KeyModifiers::CONTROL);

        match key_event.code {
            KeyCode::Esc => {
                self.browser_overlay_visible = false;
                self.browser_overlay_state.reset();
                self.request_redraw();
            }
            KeyCode::Up if shift => {
                self.adjust_browser_overlay_action_scroll(-1);
                self.request_redraw();
            }
            KeyCode::Down if shift => {
                self.adjust_browser_overlay_action_scroll(1);
                self.request_redraw();
            }
            KeyCode::Up => {
                if self.move_browser_overlay_screenshot(-1) {
                    self.request_redraw();
                }
            }
            KeyCode::Down => {
                if self.move_browser_overlay_screenshot(1) {
                    self.request_redraw();
                }
            }
            KeyCode::Left => {
                if self.move_browser_overlay_screenshot(-1) {
                    self.request_redraw();
                }
            }
            KeyCode::Right => {
                if self.move_browser_overlay_screenshot(1) {
                    self.request_redraw();
                }
            }
            KeyCode::PageUp => {
                let step = self.browser_overlay_state.last_action_view_height().max(1) as i16;
                self.adjust_browser_overlay_action_scroll(-step);
                self.request_redraw();
            }
            KeyCode::PageDown => {
                let step = self.browser_overlay_state.last_action_view_height().max(1) as i16;
                self.adjust_browser_overlay_action_scroll(step);
                self.request_redraw();
            }
            KeyCode::Home => {
                if self.set_browser_overlay_screenshot_index(0) {
                    self.request_redraw();
                }
            }
            KeyCode::End => {
                if let Some((_, tracker)) = self.browser_overlay_tracker() {
                    let len = tracker.cell.screenshot_history().len();
                    if len > 0 && self.set_browser_overlay_screenshot_index(len - 1) {
                        self.request_redraw();
                    }
                }
            }
            KeyCode::Char('j') if key_event.modifiers.is_empty() => {
                self.adjust_browser_overlay_action_scroll(1);
                self.request_redraw();
            }
            KeyCode::Char('k') if key_event.modifiers.is_empty() => {
                self.adjust_browser_overlay_action_scroll(-1);
                self.request_redraw();
            }
            KeyCode::Char('g') if ctrl => {
                if self.set_browser_overlay_screenshot_index(0) {
                    self.request_redraw();
                }
            }
            KeyCode::Char('G') if key_event.modifiers.is_empty() => {
                if let Some((_, tracker)) = self.browser_overlay_tracker() {
                    let len = tracker.cell.screenshot_history().len();
                    if len > 0 && self.set_browser_overlay_screenshot_index(len - 1) {
                        self.request_redraw();
                    }
                }
            }
            _ => {}
        }

        true
    }

    fn browser_overlay_session_key(&self) -> Option<String> {
        if let Some(key) = self.browser_overlay_state.session_key() {
            if self.tools_state.browser_sessions.contains_key(&key) {
                return Some(key);
            }
        }
        if let Some(last) = self.tools_state.browser_last_key.clone() {
            if self.tools_state.browser_sessions.contains_key(&last) {
                self.browser_overlay_state
                    .set_session_key(Some(last.clone()));
                return Some(last);
            }
        }
        if let Some((key, _)) = self.tools_state.browser_sessions.iter().next() {
            let owned = key.clone();
            self.browser_overlay_state
                .set_session_key(Some(owned.clone()));
            return Some(owned);
        }
        None
    }

    fn browser_overlay_tracker(
        &self,
    ) -> Option<(String, &browser_sessions::BrowserSessionTracker)> {
        let key = self.browser_overlay_session_key()?;
        self.tools_state
            .browser_sessions
            .get(&key)
            .map(|tracker| (key, tracker))
    }

    fn set_browser_overlay_screenshot_index(&self, index: usize) -> bool {
        let Some((_, tracker)) = self.browser_overlay_tracker() else {
            return false;
        };
        let history = tracker.cell.screenshot_history();
        if history.is_empty() {
            return false;
        }
        let clamped = index.min(history.len().saturating_sub(1));
        if self.browser_overlay_state.screenshot_index() != clamped {
            self.browser_overlay_state.set_screenshot_index(clamped);
            return true;
        }
        false
    }

    fn move_browser_overlay_screenshot(&self, delta: isize) -> bool {
        let Some((_, tracker)) = self.browser_overlay_tracker() else {
            return false;
        };
        let history = tracker.cell.screenshot_history();
        if history.is_empty() {
            return false;
        }
        let last_index = history.len() as isize - 1;
        let mut current = self.browser_overlay_state.screenshot_index() as isize;
        if current > last_index {
            current = last_index;
        }
        let mut new_index = current + delta;
        if new_index < 0 {
            new_index = 0;
        }
        if new_index > last_index {
            new_index = last_index;
        }
        if new_index != current {
            self.browser_overlay_state
                .set_screenshot_index(new_index as usize);
            return true;
        }
        false
    }

    fn adjust_browser_overlay_action_scroll(&self, delta: i16) {
        let current = self.browser_overlay_state.action_scroll() as i32;
        let max = self.browser_overlay_state.max_action_scroll() as i32;
        let mut updated = current + delta as i32;
        if updated < 0 {
            updated = 0;
        } else if updated > max {
            updated = max;
        }
        self.browser_overlay_state
            .set_action_scroll(updated as u16);
    }

    fn toggle_agents_hud(&mut self) {
        if self.agents_terminal.active {
            self.exit_agents_terminal_mode();
        } else {
            self.enter_agents_terminal_mode();
        }
    }

    fn set_limits_overlay_content(&mut self, content: LimitsOverlayContent) {
        let handled_by_settings = self.update_limits_settings_content(content.clone());
        if handled_by_settings {
            self.limits.cached_content = None;
        } else {
            self.limits.cached_content = Some(content);
        }
    }

    fn update_limits_settings_content(&mut self, content: LimitsOverlayContent) -> bool {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if let Some(view) = overlay.limits_content_mut() {
                view.set_content(content);
            } else {
                overlay.set_limits_content(LimitsSettingsContent::new(content));
            }
            self.request_redraw();
            true
        } else {
            false
        }
    }

    fn set_limits_overlay_tabs(&mut self, tabs: Vec<LimitsTab>) {
        let content = if tabs.is_empty() {
            LimitsOverlayContent::Placeholder
        } else {
            LimitsOverlayContent::Tabs(tabs)
        };
        self.set_limits_overlay_content(content);
    }

    fn build_limits_tabs(
        &self,
        current_snapshot: Option<RateLimitSnapshotEvent>,
        current_reset: RateLimitResetInfo,
    ) -> Vec<LimitsTab> {
        use std::collections::HashSet;

        let code_home = self.config.code_home.clone();
        let accounts = auth_accounts::list_accounts(&code_home).unwrap_or_default();
        let account_map: HashMap<String, StoredAccount> = accounts
            .into_iter()
            .map(|account| (account.id.clone(), account))
            .collect();

        let active_id = auth_accounts::get_active_account_id(&code_home)
            .ok()
            .flatten();

        let usage_records = account_usage::list_rate_limit_snapshots(&code_home).unwrap_or_default();
        let mut snapshot_map: HashMap<String, StoredRateLimitSnapshot> = usage_records
            .into_iter()
            .filter(|record| account_map.contains_key(&record.account_id))
            .map(|record| (record.account_id.clone(), record))
            .collect();

        let mut usage_summary_map: HashMap<String, StoredUsageSummary> = HashMap::new();
        for id in account_map.keys() {
            if let Ok(Some(summary)) = account_usage::load_account_usage(&code_home, id) {
                usage_summary_map.insert(id.clone(), summary);
            }
        }

        if let Some(active_id) = active_id.as_ref() {
            if !usage_summary_map.contains_key(active_id) {
                if let Ok(Some(summary)) = account_usage::load_account_usage(&code_home, active_id) {
                    usage_summary_map.insert(active_id.clone(), summary);
                }
            }
        }

        let mut tabs: Vec<LimitsTab> = Vec::new();
        let mut seen_ids: HashSet<String> = HashSet::new();

        if let Some(snapshot) = current_snapshot {
            let account_ref = active_id
                .as_ref()
                .and_then(|id| account_map.get(id));
            let snapshot_ref = active_id
                .as_ref()
                .and_then(|id| snapshot_map.get(id));
            let summary_ref = active_id
                .as_ref()
                .and_then(|id| usage_summary_map.get(id));

            let title = account_ref
                .map(account_display_label)
                .or_else(|| active_id.clone())
                .unwrap_or_else(|| "Current session".to_string());
            let header = Self::account_header_lines(account_ref, snapshot_ref, summary_ref);
            let is_api_key_account = matches!(
                account_ref.map(|acc| acc.mode),
                Some(McpAuthMode::ApiKey)
            );
            let extra = Self::usage_history_lines(summary_ref, is_api_key_account);
            let display = Self::rate_limit_display_config_for_account(account_ref);
            let view = build_limits_view(
                &snapshot,
                current_reset,
                DEFAULT_GRID_CONFIG,
                display,
            );
            tabs.push(LimitsTab::view(title, header, view, extra));

            if let Some(active_id) = active_id.as_ref() {
                if account_map.contains_key(active_id) {
                    seen_ids.insert(active_id.clone());
                    snapshot_map.remove(active_id);
                    usage_summary_map.remove(active_id);
                }
            }
        }

        let mut remaining_ids: Vec<String> = account_map
            .keys()
            .filter(|id| !seen_ids.contains(*id))
            .cloned()
            .collect();

        let account_sort_key = |id: &String| {
            if let Some(account) = account_map.get(id) {
                let label = account_display_label(account);
                (
                    account_mode_priority(account.mode),
                    label.to_ascii_lowercase(),
                    label,
                )
            } else {
                (u8::MAX, id.to_ascii_lowercase(), id.clone())
            }
        };

        remaining_ids.sort_by(|a, b| {
            let (a_priority, a_lower, a_label) = account_sort_key(a);
            let (b_priority, b_lower, b_label) = account_sort_key(b);
            a_priority
                .cmp(&b_priority)
                .then_with(|| a_lower.cmp(&b_lower))
                .then_with(|| a_label.cmp(&b_label))
                .then_with(|| a.cmp(b))
        });

        for id in remaining_ids {
            let account = account_map.get(&id);
            let record = snapshot_map.remove(&id);
            let usage_summary = usage_summary_map.remove(&id);
            let title = account
                .map(account_display_label)
                .unwrap_or_else(|| id.clone());
            match record {
                Some(record) => {
                    if let Some(snapshot) = record.snapshot.clone() {
                        let view_snapshot = snapshot.clone();
                        let view_reset = RateLimitResetInfo {
                            primary_next_reset: record.primary_next_reset_at,
                            secondary_next_reset: record.secondary_next_reset_at,
                            ..RateLimitResetInfo::default()
                        };
                        let display = Self::rate_limit_display_config_for_account(account);
                        let view = build_limits_view(
                            &view_snapshot,
                            view_reset,
                            DEFAULT_GRID_CONFIG,
                            display,
                        );
                        let header = Self::account_header_lines(
                            account,
                            Some(&record),
                            usage_summary.as_ref(),
                        );
                        let is_api_key_account = matches!(
                            account.map(|acc| acc.mode),
                            Some(McpAuthMode::ApiKey)
                        );
                        let extra = Self::usage_history_lines(
                            usage_summary.as_ref(),
                            is_api_key_account,
                        );
                        tabs.push(LimitsTab::view(title, header, view, extra));
                    } else {
                        let is_api_key_account = matches!(
                            account.map(|acc| acc.mode),
                            Some(McpAuthMode::ApiKey)
                        );
                        let mut lines = Self::usage_history_lines(
                            usage_summary.as_ref(),
                            is_api_key_account,
                        );
                        lines.push(Self::dim_line(
                            " Rate limit snapshot not yet available.",
                        ));
                        let header = Self::account_header_lines(
                            account,
                            Some(&record),
                            usage_summary.as_ref(),
                        );
                        tabs.push(LimitsTab::message(title, header, lines));
                    }
                }
                None => {
                    let is_api_key_account = matches!(
                        account.map(|acc| acc.mode),
                        Some(McpAuthMode::ApiKey)
                    );
                    let mut lines = Self::usage_history_lines(
                        usage_summary.as_ref(),
                        is_api_key_account,
                    );
                    lines.push(Self::dim_line(
                        " Rate limit snapshot not yet available.",
                    ));
                    let header = Self::account_header_lines(
                        account,
                        None,
                        usage_summary.as_ref(),
                    );
                    tabs.push(LimitsTab::message(title, header, lines));
                }
            }
        }

        if tabs.is_empty() {
            let mut lines = Self::usage_history_lines(None, false);
            lines.push(Self::dim_line(
                " Rate limit snapshot not yet available.",
            ));
            tabs.push(LimitsTab::message("Usage", Vec::new(), lines));
        }

        tabs
    }

    fn usage_cost_usd_from_totals(totals: &TokenTotals) -> f64 {
        let non_cached_input = totals
            .input_tokens
            .saturating_sub(totals.cached_input_tokens);
        let input_cost = (non_cached_input as f64 / TOKENS_PER_MILLION)
            * INPUT_COST_PER_MILLION_USD;
        let cached_cost = (totals.cached_input_tokens as f64 / TOKENS_PER_MILLION)
            * CACHED_INPUT_COST_PER_MILLION_USD;
        let output_cost = (totals.output_tokens as f64 / TOKENS_PER_MILLION)
            * OUTPUT_COST_PER_MILLION_USD;
        input_cost + cached_cost + output_cost
    }

    fn format_usd(amount: f64) -> String {
        let cents = (amount * 100.0).round().max(0.0);
        let cents_u128 = cents as u128;
        let dollars_u128 = cents_u128 / 100;
        let cents_part = (cents_u128 % 100) as u8;
        let dollars = (dollars_u128.min(u128::from(u64::MAX))) as u64;
        if cents_part == 0 {
            format!("${} USD", format_with_separators(dollars))
        } else {
            format!(
                "${}.{:02} USD",
                format_with_separators(dollars),
                cents_part
            )
        }
    }

    fn accumulate_token_totals(target: &mut TokenTotals, delta: &TokenTotals) {
        target.input_tokens = target
            .input_tokens
            .saturating_add(delta.input_tokens);
        target.cached_input_tokens = target
            .cached_input_tokens
            .saturating_add(delta.cached_input_tokens);
        target.output_tokens = target
            .output_tokens
            .saturating_add(delta.output_tokens);
        target.reasoning_output_tokens = target
            .reasoning_output_tokens
            .saturating_add(delta.reasoning_output_tokens);
        target.total_tokens = target
            .total_tokens
            .saturating_add(delta.total_tokens);
    }

    fn account_header_lines(
        account: Option<&StoredAccount>,
        record: Option<&StoredRateLimitSnapshot>,
        usage: Option<&StoredUsageSummary>,
    ) -> Vec<RtLine<'static>> {
        let mut lines: Vec<RtLine<'static>> = Vec::new();

        let account_type = account
            .map(|acc| match acc.mode {
                McpAuthMode::ChatGPT => "ChatGPT account",
                McpAuthMode::ApiKey => "API key",
            })
            .unwrap_or("Unknown account");

        let plan = record
            .and_then(|r| r.plan.as_deref())
            .or_else(|| usage.and_then(|u| u.plan.as_deref()))
            .unwrap_or("Unknown");

        let value_style = Style::default().fg(crate::colors::text_dim());
        let is_api_key = matches!(account.map(|acc| acc.mode), Some(McpAuthMode::ApiKey));
        let totals = usage
            .map(|u| u.totals.clone())
            .unwrap_or_default();
        let non_cached_input = totals
            .input_tokens
            .saturating_sub(totals.cached_input_tokens);
        let cached_input = totals.cached_input_tokens;
        let output_tokens = totals.output_tokens;
        let reasoning_tokens = totals.reasoning_output_tokens;
        let total_tokens = totals.total_tokens;

        let cost_usd = Self::usage_cost_usd_from_totals(&totals);
        let formatted_total = format_with_separators(total_tokens);
        let formatted_cost = Self::format_usd(cost_usd);
        let cost_suffix = if is_api_key {
            format!("({formatted_cost})")
        } else {
            format!("(API would cost {formatted_cost})")
        };

        lines.push(RtLine::from(String::new()));

        lines.push(RtLine::from(vec![
            RtSpan::raw(status_field_prefix("Type")),
            RtSpan::styled(account_type.to_string(), value_style),
        ]));
        lines.push(RtLine::from(vec![
            RtSpan::raw(status_field_prefix("Plan")),
            RtSpan::styled(plan.to_string(), value_style),
        ]));
        let tokens_prefix = status_field_prefix("Tokens");
        let tokens_summary = format!("{formatted_total} total {cost_suffix}");
        lines.push(RtLine::from(vec![
            RtSpan::raw(tokens_prefix.clone()),
            RtSpan::styled(tokens_summary, value_style),
        ]));

        let indent = " ".repeat(tokens_prefix.len());
        let counts = [
            (format_with_separators(cached_input), "cached"),
            (format_with_separators(non_cached_input), "input"),
            (format_with_separators(output_tokens), "output"),
            (format_with_separators(reasoning_tokens), "reasoning"),
        ];
        let max_width = counts
            .iter()
            .map(|(count, _)| count.len())
            .max()
            .unwrap_or(0);
        for (count, label) in counts.iter() {
            let number = format!("{count:>width$}", count = count, width = max_width);
            lines.push(RtLine::from(vec![
                RtSpan::raw(indent.clone()),
                RtSpan::styled(number, value_style),
                RtSpan::styled(format!(" {label}"), value_style),
            ]));
        }
        lines
    }

    fn hourly_usage_lines(
        summary: Option<&StoredUsageSummary>,
        is_api_key_account: bool,
    ) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        let now = Local::now();
        let anchor = now
            - ChronoDuration::minutes(now.minute() as i64)
            - ChronoDuration::seconds(now.second() as i64)
            - ChronoDuration::nanoseconds(now.nanosecond() as i64);

        let hourly_totals = Self::aggregate_hourly_totals(summary);
        let series: Vec<(DateTime<Local>, TokenTotals)> = (0..12)
            .map(|offset| anchor - ChronoDuration::hours(offset as i64))
            .map(|dt| {
                let utc_key = Self::truncate_utc_hour(dt.with_timezone(&Utc));
                let totals = hourly_totals
                    .get(&utc_key)
                    .cloned()
                    .unwrap_or_default();
                (dt, totals)
            })
            .collect();

        let max_total = series
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(RtLine::from(vec![RtSpan::styled(
            "12 Hour History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));

        let prefix = status_content_prefix();
        let tokens_width = series
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        let cached_width = series
            .iter()
            .map(|(_, totals)| format_with_separators(totals.cached_input_tokens).len())
            .max()
            .unwrap_or(0);
        let cost_width = series
            .iter()
            .map(|(_, totals)| Self::format_usd(Self::usage_cost_usd_from_totals(totals)).len())
            .max()
            .unwrap_or(0);
        let column_divider = RtSpan::styled(
            " │ ",
            Style::default().fg(crate::colors::text_dim()),
        );
        for (dt, totals) in series.iter() {
            let label = Self::format_hour_label(*dt);
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let cached_tokens = format_with_separators(totals.cached_input_tokens);
            let cached_padding = cached_width.saturating_sub(cached_tokens.len());
            let cached_display = format!(
                "{space}{cached_tokens}",
                space = " ".repeat(cached_padding),
                cached_tokens = cached_tokens
            );
            let cost_text = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
            let cost_display = if is_api_key_account {
                format!(
                    "{space}{cost_text}",
                    space = " ".repeat(cost_width.saturating_sub(cost_text.len())),
                    cost_text = cost_text
                )
            } else {
                let saved = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
                format!(
                    "{space}{saved}",
                    space = " ".repeat(cost_width.saturating_sub(saved.len())),
                    saved = saved
                )
            };
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                column_divider.clone(),
                RtSpan::styled(
                    format!("{cached_display} cached"),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                column_divider.clone(),
                RtSpan::styled(
                    format!(
                        "{cost_display} {}",
                        if is_api_key_account { "cost" } else { "saved" }
                    ),
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]));
        }
        lines
    }

    fn daily_usage_lines(
        summary: Option<&StoredUsageSummary>,
        is_api_key_account: bool,
    ) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        let today = Local::now().date_naive();
        let day_totals = Self::aggregate_daily_totals(summary);
        let daily: Vec<(chrono::NaiveDate, TokenTotals)> = (0..7)
            .map(|offset| today - ChronoDuration::days(offset as i64))
            .map(|day| {
                let totals = day_totals.get(&day).cloned().unwrap_or_default();
                (day, totals)
            })
            .collect();

        let max_total = daily
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);
        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(Self::dim_line(String::new()));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "7 Day History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));
        let prefix = status_content_prefix();
        let tokens_width = daily
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        let cached_width = daily
            .iter()
            .map(|(_, totals)| format_with_separators(totals.cached_input_tokens).len())
            .max()
            .unwrap_or(0);
        let cost_width = daily
            .iter()
            .map(|(_, totals)| Self::format_usd(Self::usage_cost_usd_from_totals(totals)).len())
            .max()
            .unwrap_or(0);
        let column_divider = RtSpan::styled(
            " │ ",
            Style::default().fg(crate::colors::text_dim()),
        );
        for (day, totals) in daily.iter() {
            let label = Self::format_daily_label(*day);
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let cached_tokens = format_with_separators(totals.cached_input_tokens);
            let cached_padding = cached_width.saturating_sub(cached_tokens.len());
            let cached_display = format!(
                "{space}{cached_tokens}",
                space = " ".repeat(cached_padding),
                cached_tokens = cached_tokens
            );
            let daily_cost = Self::usage_cost_usd_from_totals(totals);
            let cost_text = Self::format_usd(daily_cost);
            let cost_display = if is_api_key_account {
                format!(
                    "{space}{cost_text}",
                    space = " ".repeat(cost_width.saturating_sub(cost_text.len())),
                    cost_text = cost_text
                )
            } else {
                let saved = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
                format!(
                    "{space}{saved}",
                    space = " ".repeat(cost_width.saturating_sub(saved.len())),
                    saved = saved
                )
            };
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                column_divider.clone(),
                RtSpan::styled(
                    format!("{cached_display} cached"),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                column_divider.clone(),
                RtSpan::styled(
                    format!(
                        "{cost_display} {}",
                        if is_api_key_account { "cost" } else { "saved" }
                    ),
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]));
        }
        lines
    }

    fn day_suffix(day: u32) -> &'static str {
        if (11..=13).contains(&(day % 100)) {
            return "th";
        }
        match day % 10 {
            1 => "st",
            2 => "nd",
            3 => "rd",
            _ => "th",
        }
    }

    fn format_daily_label(date: chrono::NaiveDate) -> String {
        let suffix = Self::day_suffix(date.day());
        format!("{} {:>2}{}", date.format("%b"), date.day(), suffix)
    }

    fn format_hour_label(dt: DateTime<Local>) -> String {
        let (is_pm, hour) = dt.hour12();
        let meridiem = if is_pm { "pm" } else { "am" };
        format!("{} {:>2}{}", dt.format("%a"), hour, meridiem)
    }

    fn usage_history_lines(
        summary: Option<&StoredUsageSummary>,
        is_api_key_account: bool,
    ) -> Vec<RtLine<'static>> {
        let mut lines = Self::hourly_usage_lines(summary, is_api_key_account);
        lines.extend(Self::daily_usage_lines(summary, is_api_key_account));
        lines.extend(Self::six_month_usage_lines(summary, is_api_key_account));
        lines
    }

    fn six_month_usage_lines(
        summary: Option<&StoredUsageSummary>,
        is_api_key_account: bool,
    ) -> Vec<RtLine<'static>> {
        const WIDTH: usize = 14;
        const MONTHS: usize = 6;

        let today = Local::now().date_naive();
        let mut year = today.year();
        let mut month = today.month();

        let month_totals = Self::aggregate_monthly_totals(summary);
        let mut months: Vec<(chrono::NaiveDate, TokenTotals)> = Vec::with_capacity(MONTHS);
        for _ in 0..MONTHS {
            let start = chrono::NaiveDate::from_ymd_opt(year, month, 1)
                .expect("valid month start");
            let key = (start.year(), start.month());
            let totals = month_totals
                .get(&key)
                .cloned()
                .unwrap_or_default();
            months.push((start, totals));
            if month == 1 {
                month = 12;
                year -= 1;
            } else {
                month -= 1;
            }
        }

        let max_total = months
            .iter()
            .map(|(_, totals)| totals.total_tokens)
            .max()
            .unwrap_or(0);

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(Self::dim_line(String::new()));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "6 Month History",
            Style::default().add_modifier(Modifier::BOLD),
        )]));

        let prefix = status_content_prefix();
        let tokens_width = months
            .iter()
            .map(|(_, totals)| format_with_separators(totals.total_tokens).len())
            .max()
            .unwrap_or(0);
        let cached_width = months
            .iter()
            .map(|(_, totals)| format_with_separators(totals.cached_input_tokens).len())
            .max()
            .unwrap_or(0);
        let cost_width = months
            .iter()
            .map(|(_, totals)| Self::format_usd(Self::usage_cost_usd_from_totals(totals)).len())
            .max()
            .unwrap_or(0);
        let column_divider = RtSpan::styled(
            " │ ",
            Style::default().fg(crate::colors::text_dim()),
        );
        for (start, totals) in months.iter() {
            let label = start.format("%b %Y").to_string();
            let bar = Self::bar_segment(totals.total_tokens, max_total, WIDTH);
            let tokens = format_with_separators(totals.total_tokens);
            let padding = tokens_width.saturating_sub(tokens.len());
            let formatted_tokens = format!("{space}{tokens}", space = " ".repeat(padding), tokens = tokens);
            let cached_tokens = format_with_separators(totals.cached_input_tokens);
            let cached_padding = cached_width.saturating_sub(cached_tokens.len());
            let cached_display = format!(
                "{space}{cached_tokens}",
                space = " ".repeat(cached_padding),
                cached_tokens = cached_tokens
            );
            let cost_text = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
            let cost_display = if is_api_key_account {
                format!(
                    "{space}{cost_text}",
                    space = " ".repeat(cost_width.saturating_sub(cost_text.len())),
                    cost_text = cost_text
                )
            } else {
                let saved = Self::format_usd(Self::usage_cost_usd_from_totals(totals));
                format!(
                    "{space}{saved}",
                    space = " ".repeat(cost_width.saturating_sub(saved.len())),
                    saved = saved
                )
            };
            lines.push(RtLine::from(vec![
                RtSpan::raw(prefix.clone()),
                RtSpan::styled(
                    format!("{label} "),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                RtSpan::styled("│ ", Style::default().fg(crate::colors::text_dim())),
                RtSpan::styled(bar, Style::default().fg(crate::colors::primary())),
                RtSpan::raw(format!(" {formatted_tokens} tokens")),
                column_divider.clone(),
                RtSpan::styled(
                    format!("{cached_display} cached"),
                    Style::default().fg(crate::colors::text_dim()),
                ),
                column_divider.clone(),
                RtSpan::styled(
                    format!(
                        "{cost_display} {}",
                        if is_api_key_account { "cost" } else { "saved" }
                    ),
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]));
        }
        lines
    }

    fn bar_segment(value: u64, max: u64, width: usize) -> String {
        const FILL: &str = "▇";
        if max == 0 {
            return format!("{}{}", FILL.repeat(1), " ".repeat(width.saturating_sub(1)));
        }
        if value == 0 {
            return format!("{}{}", FILL.repeat(1), " ".repeat(width.saturating_sub(1)));
        }
        let ratio = value as f64 / max as f64;
        let filled = (ratio * width as f64).ceil().clamp(1.0, width as f64) as usize;
        format!(
            "{}{}",
            FILL.repeat(filled),
            " ".repeat(width.saturating_sub(filled))
        )
    }

    fn dim_line(text: impl Into<String>) -> RtLine<'static> {
        RtLine::from(vec![RtSpan::styled(
            text.into(),
            Style::default().fg(crate::colors::text_dim()),
        )])
    }

    fn truncate_utc_hour(ts: DateTime<Utc>) -> DateTime<Utc> {
        let naive = ts.naive_utc();
        let trimmed = naive
            .with_minute(0)
            .and_then(|dt| dt.with_second(0))
            .and_then(|dt| dt.with_nanosecond(0))
            .expect("valid hour truncation");
        Utc.from_utc_datetime(&trimmed)
    }

    fn aggregate_hourly_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<DateTime<Utc>, TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            for entry in &summary.hourly_entries {
                let key = Self::truncate_utc_hour(entry.timestamp);
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &entry.tokens);
            }
            for bucket in &summary.hourly_buckets {
                let slot = totals
                    .entry(bucket.period_start)
                    .or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
        }
        totals
    }

    fn aggregate_daily_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<chrono::NaiveDate, TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            for bucket in &summary.daily_buckets {
                let key = bucket.period_start.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
            for bucket in &summary.hourly_buckets {
                let key = bucket.period_start.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &bucket.tokens);
            }
            for entry in &summary.hourly_entries {
                let key = entry.timestamp.date_naive();
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, &entry.tokens);
            }
        }
        totals
    }

    fn aggregate_monthly_totals(
        summary: Option<&StoredUsageSummary>,
    ) -> HashMap<(i32, u32), TokenTotals> {
        let mut totals = HashMap::new();
        if let Some(summary) = summary {
            let mut accumulate = |dt: DateTime<Utc>, tokens: &TokenTotals| {
                let date = dt.date_naive();
                let key = (date.year(), date.month());
                let slot = totals.entry(key).or_insert_with(TokenTotals::default);
                Self::accumulate_token_totals(slot, tokens);
            };

            for bucket in &summary.monthly_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for bucket in &summary.daily_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for bucket in &summary.hourly_buckets {
                accumulate(bucket.period_start, &bucket.tokens);
            }
            for entry in &summary.hourly_entries {
                accumulate(entry.timestamp, &entry.tokens);
            }
        }
        totals
    }

    // dispatch_command() removed — command routing is handled at the App layer via AppEvent::DispatchCommand

    pub(crate) fn handle_paste(&mut self, text: String) {
        if settings_handlers::handle_settings_paste(self, text.clone()) {
            return;
        }
        // Check if the pasted text is a file path to an image
        let trimmed = text.trim();

        tracing::info!("Paste received: {:?}", trimmed);

        const IMAGE_EXTENSIONS: &[&str] = &[
            ".png", ".jpg", ".jpeg", ".gif", ".bmp", ".webp", ".svg", ".ico", ".tiff", ".tif",
        ];

        // Check if it looks like a file path
        let is_likely_path = trimmed.starts_with("file://")
            || trimmed.starts_with("/")
            || trimmed.starts_with("~/")
            || trimmed.starts_with("./");

        if is_likely_path {
            // Remove escape backslashes that terminals add for special characters
            let unescaped = trimmed
                .replace("\\ ", " ")
                .replace("\\(", "(")
                .replace("\\)", ")");

            // Handle file:// URLs (common when dragging from Finder)
            let path_str = if unescaped.starts_with("file://") {
                // URL decode to handle spaces and special characters
                // Simple decoding for common cases (spaces as %20, etc.)
                unescaped
                    .strip_prefix("file://")
                    .map(|s| {
                        s.replace("%20", " ")
                            .replace("%28", "(")
                            .replace("%29", ")")
                            .replace("%5B", "[")
                            .replace("%5D", "]")
                            .replace("%2C", ",")
                            .replace("%27", "'")
                            .replace("%26", "&")
                            .replace("%23", "#")
                            .replace("%40", "@")
                            .replace("%2B", "+")
                            .replace("%3D", "=")
                            .replace("%24", "$")
                            .replace("%21", "!")
                            .replace("%2D", "-")
                            .replace("%2E", ".")
                    })
                    .unwrap_or_else(|| unescaped.clone())
            } else {
                unescaped
            };

            tracing::info!("Decoded path: {:?}", path_str);

            // Check if it has an image extension
            let is_image = IMAGE_EXTENSIONS
                .iter()
                .any(|ext| path_str.to_lowercase().ends_with(ext));

            if is_image {
                let path = PathBuf::from(&path_str);
                tracing::info!("Checking if path exists: {:?}", path);
                if path.exists() {
                    tracing::info!("Image file dropped/pasted: {:?}", path);
                    // Get just the filename for display
                    let filename = path.file_name().and_then(|n| n.to_str()).unwrap_or("image");

                    // Add a placeholder to the compose field instead of submitting
                    let placeholder = format!("[image: {}]", filename);

                    let persisted = self.persist_user_image_if_needed(&path).unwrap_or(path);

                    // Store the image path for later submission
                    self.pending_images.insert(placeholder.clone(), persisted);

                    // Add the placeholder text to the compose field
                    self.bottom_pane.handle_paste(placeholder);
                    self.auto_sync_goal_escape_state_from_composer();
                    // Force immediate redraw to reflect input growth/wrap
                    self.request_redraw();
                    return;
                } else {
                    tracing::warn!("Image path does not exist: {:?}", path);
                }
            } else {
                // For non-image files, paste the decoded path as plain text.
                let path = PathBuf::from(&path_str);
                if path.exists() && path.is_file() {
                    self.bottom_pane.handle_paste(path_str);
                    self.auto_sync_goal_escape_state_from_composer();
                    self.request_redraw();
                    return;
                }
            }
        }

        // Otherwise handle as regular text paste
        self.bottom_pane.handle_paste(text);
        self.auto_sync_goal_escape_state_from_composer();
        // Force immediate redraw so compose height matches new content
        self.request_redraw();
    }

    /// Briefly show the vertical scrollbar and schedule a redraw to hide it.
    fn flash_scrollbar(&self) {
        layout_scroll::flash_scrollbar(self);
    }

    fn ensure_image_cell_picker(&self, cell: &dyn HistoryCell) {
        if let Some(image) = cell
            .as_any()
            .downcast_ref::<crate::history_cell::ImageOutputCell>()
        {
            let picker = self.terminal_info.picker.clone();
            let font_size = self.terminal_info.font_size;
            image.ensure_picker_initialized(picker, font_size);
        }
    }

    fn history_insert_with_key_global(
        &mut self,
        cell: Box<dyn HistoryCell>,
        key: OrderKey,
    ) -> usize {
        self.history_insert_with_key_global_tagged(cell, key, "untagged", None)
    }

    // Internal: same as above but with a short tag for debug overlays.
    fn history_insert_with_key_global_tagged(
        &mut self,
        cell: Box<dyn HistoryCell>,
        key: OrderKey,
        tag: &'static str,
        record: Option<HistoryDomainRecord>,
    ) -> usize {
        #[cfg(debug_assertions)]
        {
            let cell_kind = cell.kind();
            if cell_kind == HistoryCellType::BackgroundEvent {
                debug_assert!(
                    tag == "background",
                    "Background events must use the background helper (tag={})",
                    tag
                );
            }
        }
        self.ensure_image_cell_picker(cell.as_ref());
        // Any ordered insert of a non-reasoning cell means reasoning is no longer the
        // bottom-most active block; drop the in-progress ellipsis on collapsed titles.
        let is_reasoning_cell = cell
            .as_any()
            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            .is_some();
        if !is_reasoning_cell {
            self.clear_reasoning_in_progress();
        }
        let is_background_cell = matches!(cell.kind(), HistoryCellType::BackgroundEvent);
        let mut key = key;
        let mut key_bumped = false;
        if !is_background_cell {
            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    key_bumped = true;
                }
            }
        }

        // Determine insertion position across the entire history.
        // Most ordered inserts are monotonic tail-appends (we bump non-background
        // keys to keep them strictly increasing), so avoid an O(n) scan in the
        // common case.
        //
        // Exception: some early, non-background system cells (e.g. the context
        // summary) are inserted with a low order key before any ordering state
        // has been established. In that phase, we must still respect the order.
        let mut pos = self.history_cells.len();
        if is_background_cell || self.last_assigned_order.is_none() {
            for i in 0..self.history_cells.len() {
                if let Some(existing) = self.cell_order_seq.get(i) {
                    if *existing > key {
                        pos = i;
                        break;
                    }
                }
            }
        }

        // Keep auxiliary order vector in lockstep with history before inserting
        if self.cell_order_seq.len() < self.history_cells.len() {
            let missing = self.history_cells.len() - self.cell_order_seq.len();
            for _ in 0..missing {
                self.cell_order_seq.push(OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                });
            }
        }

        tracing::info!(
            "[order] insert: {} pos={} len_before={} order_len_before={} tag={}",
            Self::debug_fmt_order_key(key),
            pos,
            self.history_cells.len(),
            self.cell_order_seq.len(),
            tag
        );
        // If order overlay is enabled, compute a short, inline debug summary for
        // reasoning titles so we can spot mid‑word character drops quickly.
        // We intentionally do this before inserting so we can attach the
        // composed string alongside the standard order debug info.
        let reasoning_title_dbg: Option<String> = if self.show_order_overlay {
            // CollapsibleReasoningCell shows a collapsed "title" line; extract
            // the first visible line and summarize its raw text/lengths.
            if let Some(rc) = cell
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                let lines = rc.display_lines_trimmed();
                let first = lines.first();
                if let Some(line) = first {
                    // Collect visible text and basic metrics
                    let text: String = line.spans.iter().map(|s| s.content.as_ref()).collect();
                    let bytes = text.len();
                    let chars = text.chars().count();
                    let width = unicode_width::UnicodeWidthStr::width(text.as_str());
                    let spans = line.spans.len();
                    // Per‑span byte lengths to catch odd splits inside words
                    let span_lens: Vec<usize> =
                        line.spans.iter().map(|s| s.content.len()).collect();
                    // Truncate preview to avoid overflow in narrow panes
                    let mut preview = text.clone();
                    // Truncate preview by display width, not bytes, to avoid splitting
                    // a multi-byte character at an invalid boundary.
                    {
                        use unicode_width::UnicodeWidthStr as _;
                        let maxw = 120usize;
                        if preview.width() > maxw {
                            preview = format!(
                                "{}…",
                                crate::live_wrap::take_prefix_by_width(
                                    &preview,
                                    maxw.saturating_sub(1)
                                )
                                .0
                            );
                        }
                    }
                    Some(format!(
                        "title='{}' bytes={} chars={} width={} spans={} span_bytes={:?}",
                        preview, bytes, chars, width, spans, span_lens
                    ))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        let mut cell = cell;

        let mutation = if let Some(domain_record) = record {
            let record_index = if pos == self.history_cells.len() {
                self.history_state.records.len()
            } else {
                self.record_index_for_position(pos)
            };
            let event = match domain_record {
                HistoryDomainRecord::Exec(ref exec_record) => {
                    HistoryDomainEvent::StartExec {
                        index: record_index,
                        call_id: exec_record.call_id.clone(),
                        command: exec_record.command.clone(),
                        parsed: exec_record.parsed.clone(),
                        action: exec_record.action,
                        started_at: exec_record.started_at,
                        working_dir: exec_record.working_dir.clone(),
                        env: exec_record.env.clone(),
                        tags: exec_record.tags.clone(),
                    }
                }
                other => HistoryDomainEvent::Insert {
                    index: record_index,
                    record: other,
                },
            };
            Some(self.history_state.apply_domain_event(event))
        } else if let Some(record) = history_cell::record_from_cell(cell.as_ref()) {
            let record_index = if pos == self.history_cells.len() {
                self.history_state.records.len()
            } else {
                self.record_index_for_position(pos)
            };
            let event = match HistoryDomainRecord::from(record) {
                HistoryDomainRecord::Exec(exec_record) => HistoryDomainEvent::StartExec {
                    index: record_index,
                    call_id: exec_record.call_id.clone(),
                    command: exec_record.command.clone(),
                    parsed: exec_record.parsed.clone(),
                    action: exec_record.action,
                    started_at: exec_record.started_at,
                    working_dir: exec_record.working_dir.clone(),
                    env: exec_record.env.clone(),
                    tags: exec_record.tags.clone(),
                },
                other => HistoryDomainEvent::Insert {
                    index: record_index,
                    record: other,
                },
            };
            Some(self.history_state.apply_domain_event(event))
        } else {
            None
        };

        let mut maybe_id = None;
        if let Some(mutation) = mutation {
            if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                maybe_id = Some(id);
            }
        }

        let append = pos == self.history_cells.len();
        if !append {
            self.history_prefix_append_only.set(false);
        }
        if append {
            self.history_cells.push(cell);
            self.history_cell_ids.push(maybe_id);
        } else {
            self.history_cells.insert(pos, cell);
            self.history_cell_ids.insert(pos, maybe_id);
        }
        // In terminal mode, App mirrors history lines into the native buffer.
        // Ensure order vector is also long enough for position after cell insert
        if self.cell_order_seq.len() < pos {
            self.cell_order_seq.resize(
                pos,
                OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                },
            );
        }
        if append {
            self.cell_order_seq.push(key);
        } else {
            self.cell_order_seq.insert(pos, key);
        }
        if key_bumped {
            if let Some(stream) = self.history_cells[pos]
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
            {
                self.stream_order_seq
                    .insert((StreamKind::Answer, stream.state().stream_id.clone()), key);
            }
        }
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });
        // Insert debug info aligned with cell insert
        let ordered = "ordered";
        let req_dbg = format!("{}", key.req);
        let dbg = if let Some(tdbg) = reasoning_title_dbg {
            format!(
                "insert: {} req={} key={} {} pos={} tag={} | {}",
                ordered,
                req_dbg,
                0,
                Self::debug_fmt_order_key(key),
                pos,
                tag,
                tdbg
            )
        } else {
            format!(
                "insert: {} req={} {} pos={} tag={}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag
            )
        };
        if self.cell_order_dbg.len() < pos {
            self.cell_order_dbg.resize(pos, None);
        }
        if append {
            self.cell_order_dbg.push(Some(dbg));
        } else {
            self.cell_order_dbg.insert(pos, Some(dbg));
        }
        if let Some(id) = maybe_id {
            if id != HistoryId::ZERO {
                self.history_render.invalidate_history_id(id);
            } else {
                self.history_render.invalidate_prefix_only();
            }
        } else {
            self.history_render.invalidate_prefix_only();
        }
        self.mark_render_requests_dirty();
        self.autoscroll_if_near_bottom();
        self.bottom_pane.set_has_chat_history(true);
        self.process_animation_cleanup();
        // Maintain input focus when new history arrives unless a modal overlay owns it
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
        self.app_event_tx.send(AppEvent::RequestRedraw);
        self.refresh_explore_trailing_flags();
        self.refresh_reasoning_collapsed_visibility();
        self.mark_history_dirty();
        pos
    }

    fn history_insert_existing_record(
        &mut self,
        mut cell: Box<dyn HistoryCell>,
        mut key: OrderKey,
        tag: &'static str,
        id: HistoryId,
    ) -> usize {
        #[cfg(debug_assertions)]
        {
            let cell_kind = cell.kind();
            if cell_kind == HistoryCellType::BackgroundEvent {
                debug_assert!(
                    tag == "background",
                    "Background events must use the background helper (tag={})",
                    tag
                );
            }
        }

        let is_reasoning_cell = cell
            .as_any()
            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            .is_some();
        if !is_reasoning_cell {
                self.clear_reasoning_in_progress();
        }

        let is_background_cell = matches!(cell.kind(), HistoryCellType::BackgroundEvent);
        let mut key_bumped = false;
        if !is_background_cell {
            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    key_bumped = true;
                }
            }
        }

        let mut pos = self.history_cells.len();
        if is_background_cell || self.last_assigned_order.is_none() {
            for i in 0..self.history_cells.len() {
                if let Some(existing) = self.cell_order_seq.get(i) {
                    if *existing > key {
                        pos = i;
                        break;
                    }
                }
            }
        }

        if self.cell_order_seq.len() < self.history_cells.len() {
            let missing = self.history_cells.len() - self.cell_order_seq.len();
            for _ in 0..missing {
                self.cell_order_seq.push(OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                });
            }
        }

        tracing::info!(
            "[order] insert(existing): {} pos={} len_before={} order_len_before={} tag={}",
            Self::debug_fmt_order_key(key),
            pos,
            self.history_cells.len(),
            self.cell_order_seq.len(),
            tag
        );

        let reasoning_title_dbg: Option<String> = if self.show_order_overlay {
            if let Some(rc) = cell
                .as_any()
                .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
            {
                let lines = rc.display_lines_trimmed();
                if let Some(line) = lines.first() {
                    let text: String = line.spans.iter().map(|s| s.content.as_ref()).collect();
                    let bytes = text.len();
                    let chars = text.chars().count();
                    let width = unicode_width::UnicodeWidthStr::width(text.as_str());
                    let spans = line.spans.len();
                    let span_lens: Vec<usize> =
                        line.spans.iter().map(|s| s.content.len()).collect();
                    let mut preview = text.clone();
                    {
                        use unicode_width::UnicodeWidthStr as _;
                        let maxw = 120usize;
                        if preview.width() > maxw {
                            preview = format!(
                                "{}…",
                                crate::live_wrap::take_prefix_by_width(
                                    &preview,
                                    maxw.saturating_sub(1)
                                )
                                .0
                            );
                        }
                    }
                    Some(format!(
                        "title='{}' bytes={} chars={} width={} spans={} span_bytes={:?}",
                        preview, bytes, chars, width, spans, span_lens
                    ))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        Self::assign_history_id_inner(&mut cell, id);

        let append = pos == self.history_cells.len();
        if !append {
            self.history_prefix_append_only.set(false);
        }
        if append {
            self.history_cells.push(cell);
            self.history_cell_ids.push(Some(id));
        } else {
            self.history_cells.insert(pos, cell);
            self.history_cell_ids.insert(pos, Some(id));
        }
        if self.cell_order_seq.len() < pos {
            self.cell_order_seq.resize(
                pos,
                OrderKey {
                    req: 0,
                    out: -1,
                    seq: 0,
                },
            );
        }
        if append {
            self.cell_order_seq.push(key);
        } else {
            self.cell_order_seq.insert(pos, key);
        }
        if key_bumped {
            if let Some(stream) = self.history_cells[pos]
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
            {
                self.stream_order_seq
                    .insert((StreamKind::Answer, stream.state().stream_id.clone()), key);
            }
        }
        self.last_assigned_order = Some(match self.last_assigned_order {
            Some(prev) => prev.max(key),
            None => key,
        });

        let ordered = "existing";
        let req_dbg = format!("{}", key.req);
        let dbg = if let Some(tdbg) = reasoning_title_dbg {
            format!(
                "insert: {} req={} {} pos={} tag={} | {}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag,
                tdbg
            )
        } else {
            format!(
                "insert: {} req={} {} pos={} tag={}",
                ordered,
                req_dbg,
                Self::debug_fmt_order_key(key),
                pos,
                tag
            )
        };
        if self.cell_order_dbg.len() < pos {
            self.cell_order_dbg.resize(pos, None);
        }
        if append {
            self.cell_order_dbg.push(Some(dbg));
        } else {
            self.cell_order_dbg.insert(pos, Some(dbg));
        }
        self.history_render.invalidate_history_id(id);
        self.mark_render_requests_dirty();
        self.autoscroll_if_near_bottom();
        self.bottom_pane.set_has_chat_history(true);
        self.process_animation_cleanup();
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
        self.app_event_tx.send(AppEvent::RequestRedraw);
        self.refresh_explore_trailing_flags();
        self.refresh_reasoning_collapsed_visibility();
        self.mark_history_dirty();
        pos
    }

    fn append_wait_pairs(target: &mut Vec<(String, bool)>, additions: &[(String, bool)]) {
        for (text, is_error) in additions {
            let trimmed = text.trim();
            if trimmed.is_empty() {
                continue;
            }
            if target
                .last()
                .map(|(existing, existing_err)| existing == trimmed && *existing_err == *is_error)
                .unwrap_or(false)
            {
                continue;
            }
            target.push((trimmed.to_string(), *is_error));
        }
    }

    fn wait_pairs_from_exec_notes(notes: &[ExecWaitNote]) -> Vec<(String, bool)> {
        notes
            .iter()
            .map(|note| {
                (
                    note.message.clone(),
                    matches!(note.tone, TextTone::Error),
                )
            })
            .collect()
    }

    fn update_exec_wait_state_with_pairs(
        &mut self,
        history_id: HistoryId,
        total_wait: Option<Duration>,
        wait_active: bool,
        notes: &[(String, bool)],
    ) -> bool {
        let Some(record_idx) = self.history_state.index_of(history_id) else {
            return false;
        };
        let note_records: Vec<ExecWaitNote> = notes
            .iter()
            .filter_map(|(text, is_error)| {
                let trimmed = text.trim();
                if trimmed.is_empty() {
                    None
                } else {
                    Some(ExecWaitNote {
                        message: trimmed.to_string(),
                        tone: if *is_error {
                            TextTone::Error
                        } else {
                            TextTone::Info
                        },
                        timestamp: SystemTime::now(),
                    })
                }
            })
            .collect();
        let mutation = self.history_state.apply_domain_event(HistoryDomainEvent::UpdateExecWait {
            index: record_idx,
            total_wait,
            wait_active,
            notes: note_records,
        });
        match mutation {
            HistoryMutation::Replaced {
                id,
                record: HistoryRecord::Exec(exec_record),
                ..
            }
            | HistoryMutation::Inserted {
                id,
                record: HistoryRecord::Exec(exec_record),
                ..
            } => {
                self.update_cell_from_record(id, HistoryRecord::Exec(exec_record));
                self.mark_history_dirty();
                true
            }
            _ => false,
        }
    }

    fn hydrate_cell_from_record(
        &self,
        cell: &mut Box<dyn HistoryCell>,
        record: &HistoryRecord,
    ) -> bool {
        Self::hydrate_cell_from_record_inner(cell, record, &self.config)
    }

    fn hydrate_cell_from_record_inner(
        cell: &mut Box<dyn HistoryCell>,
        record: &HistoryRecord,
        config: &Config,
    ) -> bool {
        match record {
            HistoryRecord::PlainMessage(state) => {
                if let Some(plain) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::PlainHistoryCell>()
                {
                    *plain.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::WaitStatus(state) => {
                if let Some(wait) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::WaitStatusCell>()
                {
                    *wait.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Loading(state) => {
                if let Some(loading) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::LoadingCell>()
                {
                    *loading.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::BackgroundEvent(state) => {
                if let Some(background) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::BackgroundEventCell>()
                {
                    *background.state_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Exec(state) => {
                if let Some(exec) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::ExecCell>()
                {
                    exec.sync_from_record(state);
                    return true;
                }
            }
            HistoryRecord::AssistantStream(state) => {
                if let Some(stream) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::StreamingContentCell>()
                {
                    stream.set_state(state.clone());
                    stream.update_context(config.file_opener, &config.cwd);
                    return true;
                }
            }
            HistoryRecord::RateLimits(state) => {
                if let Some(rate_limits) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::RateLimitsCell>()
                {
                    *rate_limits.record_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Patch(state) => {
                if let Some(patch) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::PatchSummaryCell>()
                {
                    patch.update_record(state.clone());
                    return true;
                }
            }
            HistoryRecord::Image(state) => {
                if let Some(image) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::ImageOutputCell>()
                {
                    *image.record_mut() = state.clone();
                    return true;
                }
            }
            HistoryRecord::Context(state) => {
                if let Some(context) = cell
                    .as_any_mut()
                    .downcast_mut::<crate::history_cell::ContextCell>()
                {
                    context.update(state.clone());
                    return true;
                }
            }
            _ => {}
        }
        false
    }

    fn build_cell_from_record(&self, record: &HistoryRecord) -> Option<Box<dyn HistoryCell>> {
        use crate::history_cell;

        match record {
            HistoryRecord::PlainMessage(state) => Some(Box::new(
                history_cell::PlainHistoryCell::from_state(state.clone()),
            )),
            HistoryRecord::WaitStatus(state) => {
                Some(Box::new(history_cell::WaitStatusCell::from_state(state.clone())))
            }
            HistoryRecord::Loading(state) => {
                Some(Box::new(history_cell::LoadingCell::from_state(state.clone())))
            }
            HistoryRecord::RunningTool(state) => Some(Box::new(
                history_cell::RunningToolCallCell::from_state(state.clone()),
            )),
            HistoryRecord::ToolCall(state) => Some(Box::new(
                history_cell::ToolCallCell::from_state(state.clone()),
            )),
            HistoryRecord::PlanUpdate(state) => Some(Box::new(
                history_cell::PlanUpdateCell::from_state(state.clone()),
            )),
            HistoryRecord::UpgradeNotice(state) => Some(Box::new(
                history_cell::UpgradeNoticeCell::from_state(state.clone()),
            )),
            HistoryRecord::Reasoning(state) => Some(Box::new(
                history_cell::CollapsibleReasoningCell::from_state(state.clone()),
            )),
            HistoryRecord::Exec(state) => {
                Some(Box::new(history_cell::ExecCell::from_record(state.clone())))
            }
            HistoryRecord::MergedExec(state) => Some(Box::new(
                history_cell::MergedExecCell::from_state(state.clone()),
            )),
            HistoryRecord::AssistantStream(state) => Some(Box::new(
                history_cell::StreamingContentCell::from_state(
                    state.clone(),
                    self.config.file_opener,
                    self.config.cwd.clone(),
                ),
            )),
            HistoryRecord::AssistantMessage(state) => Some(Box::new(
                history_cell::AssistantMarkdownCell::from_state(state.clone(), &self.config),
            )),
            HistoryRecord::Diff(state) => {
                Some(Box::new(history_cell::DiffCell::from_record(state.clone())))
            }
            HistoryRecord::Patch(state) => {
                Some(Box::new(history_cell::PatchSummaryCell::from_record(state.clone())))
            }
            HistoryRecord::Explore(state) => {
                Some(Box::new(history_cell::ExploreAggregationCell::from_record(state.clone())))
            }
            HistoryRecord::RateLimits(state) => Some(Box::new(
                history_cell::RateLimitsCell::from_record(state.clone()),
            )),
            HistoryRecord::BackgroundEvent(state) => {
                Some(Box::new(history_cell::BackgroundEventCell::new(state.clone())))
            }
            HistoryRecord::Image(state) => {
                let cell = history_cell::ImageOutputCell::from_record(state.clone());
                self.ensure_image_cell_picker(&cell);
                Some(Box::new(cell))
            }
            HistoryRecord::Context(state) => Some(Box::new(
                history_cell::ContextCell::new(state.clone()),
            )),
            HistoryRecord::Notice(state) => Some(Box::new(
                history_cell::PlainHistoryCell::from_notice_record(state.clone()),
            )),
        }
    }

    fn apply_mutation_to_cell(
        &self,
        cell: &mut Box<dyn HistoryCell>,
        mutation: HistoryMutation,
    ) -> Option<HistoryId> {
        match mutation {
            HistoryMutation::Inserted { id, record, .. }
            | HistoryMutation::Replaced { id, record, .. } => {
                if let Some(mut new_cell) = self.build_cell_from_record(&record) {
                    self.assign_history_id(&mut new_cell, id);
                    *cell = new_cell;
                } else if !self.hydrate_cell_from_record(cell, &record) {
                    self.assign_history_id(cell, id);
                }
                Some(id)
            }
            _ => None,
        }
    }

    fn apply_mutation_to_cell_index(
        &mut self,
        idx: usize,
        mutation: HistoryMutation,
    ) -> Option<HistoryId> {
        if idx >= self.history_cells.len() {
            return None;
        }
        match mutation {
            HistoryMutation::Inserted { id, record, .. }
            | HistoryMutation::Replaced { id, record, .. } => {
                self.update_cell_from_record(id, record);
                Some(id)
            }
            _ => None,
        }
    }

    fn cell_index_for_history_id(&self, id: HistoryId) -> Option<usize> {
        if let Some(idx) = self
            .history_cell_ids
            .iter()
            .position(|maybe| maybe.map(|stored| stored == id).unwrap_or(false))
        {
            return Some(idx);
        }

        self.history_cells.iter().enumerate().find_map(|(idx, cell)| {
        history_cell::record_from_cell(cell.as_ref())
                .map(|record| record.id() == id)
                .filter(|matched| *matched)
                .map(|_| idx)
        })
    }

    fn update_cell_from_record(&mut self, id: HistoryId, record: HistoryRecord) {
        if id == HistoryId::ZERO {
            tracing::debug!("skip update_cell_from_record: zero id");
            return;
        }

        self.history_render.invalidate_history_id(id);

        if let Some(idx) = self.cell_index_for_history_id(id) {
            if let Some(mut rebuilt) = self.build_cell_from_record(&record) {
                Self::assign_history_id_inner(&mut rebuilt, id);
                self.history_cells[idx] = rebuilt;
            } else if let Some(cell_slot) = self.history_cells.get_mut(idx) {
                if !Self::hydrate_cell_from_record_inner(cell_slot, &record, &self.config) {
                    Self::assign_history_id_inner(cell_slot, id);
                }
            }

            if idx < self.history_cell_ids.len() {
                self.history_cell_ids[idx] = Some(id);
            }
            self.invalidate_height_cache();
            self.request_redraw();
        } else {
            tracing::warn!(
                "history-state mismatch: unable to locate cell for id {:?}",
                id
            );
        }
    }

    fn assign_history_id(&self, cell: &mut Box<dyn HistoryCell>, id: HistoryId) {
        Self::assign_history_id_inner(cell, id);
    }

    fn assign_history_id_inner(cell: &mut Box<dyn HistoryCell>, id: HistoryId) {
        if let Some(tool_call) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ToolCallCell>()
        {
            tool_call.state_mut().id = id;
        } else if let Some(running_tool) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::RunningToolCallCell>()
        {
            running_tool.state_mut().id = id;
        } else if let Some(plan) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PlanUpdateCell>()
        {
            plan.state_mut().id = id;
        } else if let Some(upgrade) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::UpgradeNoticeCell>()
        {
            upgrade.state_mut().id = id;
        } else if let Some(reasoning) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::CollapsibleReasoningCell>()
        {
            reasoning.set_history_id(id);
        } else if let Some(exec) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ExecCell>()
        {
            exec.record.id = id;
        } else if let Some(merged) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::MergedExecCell>()
        {
            merged.set_history_id(id);
        } else if let Some(stream) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::StreamingContentCell>()
        {
            stream.state_mut().id = id;
        } else if let Some(assistant) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::AssistantMarkdownCell>()
        {
            assistant.state_mut().id = id;
        } else if let Some(diff) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::DiffCell>()
        {
            diff.record_mut().id = id;
        } else if let Some(image) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ImageOutputCell>()
        {
            image.record_mut().id = id;
        } else if let Some(patch) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PatchSummaryCell>()
        {
            patch.record_mut().id = id;
        } else if let Some(explore) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::ExploreAggregationCell>()
        {
            explore.record_mut().id = id;
        } else if let Some(rate_limits) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::RateLimitsCell>()
        {
            rate_limits.record_mut().id = id;
        } else if let Some(plain) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::PlainHistoryCell>()
        {
            plain.state_mut().id = id;
        } else if let Some(wait) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::WaitStatusCell>()
        {
            wait.state_mut().id = id;
        } else if let Some(loading) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::LoadingCell>()
        {
            loading.state_mut().id = id;
        } else if let Some(background) = cell
            .as_any_mut()
            .downcast_mut::<crate::history_cell::BackgroundEventCell>()
        {
            background.state_mut().id = id;
        }
    }

    /// Push a cell using a synthetic global order key at the bottom of the current request.
    pub(crate) fn history_push(&mut self, cell: impl HistoryCell + 'static) {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                cell.kind() != HistoryCellType::BackgroundEvent,
                "Background events must use push_background_* helpers"
            );
        }
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "epilogue", None);
    }

    fn history_insert_plain_state_with_key(
        &mut self,
        state: PlainMessageState,
        key: OrderKey,
        tag: &'static str,
    ) -> usize {
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        self.history_insert_with_key_global_tagged(
            Box::new(cell),
            key,
            tag,
            Some(HistoryDomainRecord::Plain(state)),
        )
    }

    pub(crate) fn history_push_plain_state(&mut self, state: PlainMessageState) {
        let key = self.next_internal_key();
        let _ = self.history_insert_plain_state_with_key(state, key, "epilogue");
    }

    fn history_push_plain_paragraphs<I, S>(
        &mut self,
        kind: PlainMessageKind,
        lines: I,
    ) where
        I: IntoIterator<Item = S>,
        S: Into<String>,
    {
        let role = history_cell::plain_role_for_kind(kind);
        let state = history_cell::plain_message_state_from_paragraphs(kind, role, lines);
        self.history_push_plain_state(state);
    }

    fn history_push_diff(&mut self, title: Option<String>, diff_output: String) {
        let record = history_cell::diff_record_from_string(
            title.unwrap_or_default(),
            &diff_output,
        );
        let key = self.next_internal_key();
        let _ = self.history_insert_with_key_global_tagged(
            Box::new(history_cell::DiffCell::from_record(record.clone())),
            key,
            "diff",
            Some(HistoryDomainRecord::Diff(record)),
        );
    }
    /// Insert a background event near the top of the current request so it appears
    /// before imminent provider output (e.g. Exec begin).
    pub(crate) fn insert_background_event_early(&mut self, message: String) {
        let ticket = self.make_background_before_next_output_ticket();
        self.insert_background_event_with_placement(
            message,
            BackgroundPlacement::BeforeNextOutput,
            Some(ticket.next_order()),
        );
    }
    /// Insert a background event using the specified placement semantics.
    pub(crate) fn insert_background_event_with_placement(
        &mut self,
        message: String,
        placement: BackgroundPlacement,
        order: Option<code_core::protocol::OrderMeta>,
    ) {
        let order = order;
        if order.is_none() {
            if matches!(placement, BackgroundPlacement::Tail) {
                tracing::error!(
                    target: "code_order",
                    "missing order metadata for tail background event; dropping message"
                );
                return;
            } else {
                tracing::warn!(
                    target: "code_order",
                    "background event without order metadata placement={:?}",
                    placement
                );
            }
        }
        let system_placement = match placement {
            BackgroundPlacement::Tail => SystemPlacement::EndOfCurrent,
            BackgroundPlacement::BeforeNextOutput => {
                if self.pending_user_prompts_for_next_turn > 0 {
                    SystemPlacement::EarlyInCurrent
                } else {
                    SystemPlacement::PrePromptInCurrent
                }
            }
        };
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            system_placement,
            None,
            order.as_ref(),
            "background",
            Some(record),
        );
    }

    pub(crate) fn push_background_tail(&mut self, message: impl Into<String>) {
        let ticket = self.make_background_tail_ticket();
        self.insert_background_event_with_placement(
            message.into(),
            BackgroundPlacement::Tail,
            Some(ticket.next_order()),
        );
    }

    pub(crate) fn push_background_before_next_output(&mut self, message: impl Into<String>) {
        let ticket = self.make_background_before_next_output_ticket();
        self.insert_background_event_with_placement(
            message.into(),
            BackgroundPlacement::BeforeNextOutput,
            Some(ticket.next_order()),
        );
    }

    pub(super) fn history_debug(&self, message: impl Into<String>) {
        if !history_cell_logging_enabled() {
            return;
        }
        let message = message.into();
        tracing::trace!(target: "code_history", "{message}");
        if let Some(buffer) = &self.history_debug_events {
            buffer.borrow_mut().push(message);
        }
    }

    fn rehydrate_system_order_cache(&mut self, preserved: &[(String, HistoryId)]) {
        let prev = self.system_cell_by_id.len();
        self.system_cell_by_id.clear();

        for (key, hid) in preserved {
            if let Some(idx) = self
                .history_cell_ids
                .iter()
                .position(|maybe| maybe.map(|stored| stored == *hid).unwrap_or(false))
            {
                self.system_cell_by_id.insert(key.clone(), idx);
            }
        }

        self.history_debug(format!(
            "system_order_cache.rehydrate prev={} restored={} entries={}",
            prev,
            preserved.len(),
            self.system_cell_by_id.len()
        ));
    }

    /// Push a cell using a synthetic key at the TOP of the NEXT request.
    fn history_push_top_next_req(&mut self, cell: impl HistoryCell + 'static) {
        let key = self.next_req_key_top();
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "prelude", None);
    }
    fn history_replace_with_record(
        &mut self,
        idx: usize,
        mut cell: Box<dyn HistoryCell>,
        record: HistoryDomainRecord,
    ) {
        if idx >= self.history_cells.len() {
            return;
        }

        let record_idx = self
            .record_index_for_cell(idx)
            .unwrap_or_else(|| self.record_index_for_position(idx));

        let mutation = self.history_state.apply_domain_event(HistoryDomainEvent::Replace {
            index: record_idx,
            record,
        });

        if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
            if idx < self.history_cell_ids.len() {
                self.history_cell_ids[idx] = Some(id);
            }
        }

        self.ensure_image_cell_picker(cell.as_ref());
        self.history_cells[idx] = cell;
        self.invalidate_height_cache();
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        self.mark_history_dirty();
    }

    fn history_replace_at(&mut self, idx: usize, mut cell: Box<dyn HistoryCell>) {
        if idx >= self.history_cells.len() {
            return;
        }

        let old_id = self.history_cell_ids.get(idx).and_then(|id| *id);
        let record = history_cell::record_from_cell(cell.as_ref());
        let mut maybe_id = None;

        match (record.map(HistoryDomainRecord::from), self.record_index_for_cell(idx)) {
            (Some(record), Some(record_idx)) => {
                let mutation = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Replace {
                        index: record_idx,
                        record,
                    });
                if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                    maybe_id = Some(id);
                }
            }
            (Some(record), None) => {
                let record_idx = self.record_index_for_position(idx);
                let mutation = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Insert {
                        index: record_idx,
                        record,
                    });
                if let Some(id) = self.apply_mutation_to_cell(&mut cell, mutation) {
                    maybe_id = Some(id);
                }
            }
            (None, Some(record_idx)) => {
                let _ = self
                    .history_state
                    .apply_domain_event(HistoryDomainEvent::Remove { index: record_idx });
            }
            (None, None) => {}
        }

        self.ensure_image_cell_picker(cell.as_ref());
        self.history_cells[idx] = cell;
        if idx < self.history_cell_ids.len() {
            self.history_cell_ids[idx] = maybe_id;
        }
        if let Some(id) = old_id {
            self.history_render.invalidate_history_id(id);
        } else {
            self.history_render.invalidate_prefix_only();
        }
        if let Some(id) = maybe_id {
            if Some(id) != old_id {
                self.history_render.invalidate_history_id(id);
            }
        }
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        // Keep debug info for this cell index as-is.
        self.mark_history_dirty();
    }

    fn history_remove_at(&mut self, idx: usize) {
        if idx >= self.history_cells.len() {
            return;
        }

        let removed_id = self.history_cell_ids.get(idx).and_then(|id| *id);
        if let Some(record_idx) = self.record_index_for_cell(idx) {
            let _ = self
                .history_state
                .apply_domain_event(HistoryDomainEvent::Remove { index: record_idx });
        }

        self.history_cells.remove(idx);
        if idx < self.history_cell_ids.len() {
            self.history_cell_ids.remove(idx);
        }
        if idx < self.cell_order_seq.len() {
            self.cell_order_seq.remove(idx);
        }
        if idx < self.cell_order_dbg.len() {
            self.cell_order_dbg.remove(idx);
        }
        if let Some(id) = removed_id {
            self.history_render.invalidate_history_id(id);
        } else {
            self.history_render.invalidate_prefix_only();
        }
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        self.request_redraw();
        self.refresh_explore_trailing_flags();
        self.mark_history_dirty();
    }

    fn history_replace_and_maybe_merge(&mut self, idx: usize, cell: Box<dyn HistoryCell>) {
        // Replace at index, then attempt standard exec merge with previous cell.
        self.history_replace_at(idx, cell);
        // Merge only if the new cell is an Exec with output (completed) or a MergedExec.
        crate::chatwidget::exec_tools::try_merge_completed_exec_at(self, idx);
    }

    // Merge adjacent tool cells with the same header (e.g., successive Web Search blocks)
    #[allow(dead_code)]
    fn history_maybe_merge_tool_with_previous(&mut self, idx: usize) {
        if idx == 0 || idx >= self.history_cells.len() {
            return;
        }
        let new_lines = self.history_cells[idx].display_lines();
        let new_header = new_lines
            .first()
            .and_then(|l| l.spans.get(0))
            .map(|s| s.content.clone().to_string())
            .unwrap_or_default();
        if new_header.is_empty() {
            return;
        }
        let prev_lines = self.history_cells[idx - 1].display_lines();
        let prev_header = prev_lines
            .first()
            .and_then(|l| l.spans.get(0))
            .map(|s| s.content.clone().to_string())
            .unwrap_or_default();
        if new_header != prev_header {
            return;
        }
        let mut combined = prev_lines.clone();
        while combined
            .last()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            combined.pop();
        }
        let mut body: Vec<ratatui::text::Line<'static>> = new_lines.into_iter().skip(1).collect();
        while body
            .first()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            body.remove(0);
        }
        while body
            .last()
            .map(|l| crate::render::line_utils::is_blank_line_trim(l))
            .unwrap_or(false)
        {
            body.pop();
        }
        if let Some(first_line) = body.first_mut() {
            if let Some(first_span) = first_line.spans.get_mut(0) {
                if first_span.content == "  └ " || first_span.content == "└ " {
                    first_span.content = "  ".into();
                }
            }
        }
        combined.extend(body);
        let state = history_cell::plain_message_state_from_lines(
            combined,
            crate::history_cell::HistoryCellType::Plain,
        );
        self.history_replace_with_record(
            idx - 1,
            Box::new(crate::history_cell::PlainHistoryCell::from_state(state.clone())),
            HistoryDomainRecord::Plain(state),
        );
        self.history_remove_at(idx);
    }

    fn record_index_for_position(&self, ui_index: usize) -> usize {
        if let Some(Some(id)) = self.history_cell_ids.get(ui_index) {
            if let Some(idx) = self.history_state.index_of(*id) {
                return idx;
            }
        }
        self.history_cell_ids
            .iter()
            .take(ui_index)
            .filter(|entry| entry.is_some())
            .count()
    }

    fn record_index_for_cell(&self, idx: usize) -> Option<usize> {
        self.history_cell_ids
            .get(idx)
            .and_then(|entry| entry.map(|_| self.record_index_for_position(idx)))
    }

    /// Clean up faded-out animation cells
    fn process_animation_cleanup(&mut self) {
        // With trait-based cells, we can't easily detect and clean up specific cell types
        // Animation cleanup is now handled differently
    }

    /// Replace the initial Popular Commands notice that includes
    /// the transient "Connecting MCP servers…" line with a version
    /// that omits it.
    fn remove_connecting_mcp_notice(&mut self) {
        if self.test_mode {
            return;
        }
        let needle = "Connecting MCP servers…";
        if let Some((idx, cell)) = self.history_cells.iter().enumerate().find(|(idx, cell)| {
            self.cell_lines_for_index(*idx, cell.as_ref()).iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.as_ref() == needle)
            })
        }) {
            match cell.kind() {
                crate::history_cell::HistoryCellType::Notice => {
                    // Older layout: status was inside the notice cell — replace it
                    let state = history_cell::new_popular_commands_notice(
                        false,
                        self.latest_upgrade_version.as_deref(),
                    );
                    let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
                    self.history_replace_with_record(
                        idx,
                        Box::new(cell),
                        HistoryDomainRecord::Plain(state),
                    );
                }
                _ => {
                    // New layout: status is a separate BackgroundEvent cell — remove it
                    self.history_remove_at(idx);
                }
            }
        }
    }

    fn refresh_explore_trailing_flags(&mut self) -> bool {
        let mut updated = false;
        for idx in 0..self.history_cells.len() {
            let is_explore = self.history_cells[idx]
                .as_any()
                .downcast_ref::<history_cell::ExploreAggregationCell>()
                .is_some();
            if !is_explore {
                continue;
            }

            let hold_title = self.rendered_explore_should_hold(idx);

            if let Some(explore_cell) = self.history_cells[idx]
                .as_any_mut()
                .downcast_mut::<history_cell::ExploreAggregationCell>()
            {
                if explore_cell.set_force_exploring_header(hold_title) {
                    updated = true;
                    if let Some(Some(id)) = self.history_cell_ids.get(idx) {
                        self.history_render.invalidate_history_id(*id);
                    }
                }
            }
        }

        if updated {
            self.invalidate_height_cache();
            self.request_redraw();
        }

        updated
    }

    fn rendered_explore_should_hold(&self, idx: usize) -> bool {
        if idx >= self.history_cells.len() {
            return true;
        }

        let mut next = idx + 1;
        while next < self.history_cells.len() {
            let cell = &self.history_cells[next];

            if cell.should_remove() {
                next += 1;
                continue;
            }

            match cell.kind() {
                history_cell::HistoryCellType::Reasoning
                | history_cell::HistoryCellType::Loading
                | history_cell::HistoryCellType::PlanUpdate => {
                    next += 1;
                    continue;
                }
                _ => {}
            }

            if cell
                .as_any()
                .downcast_ref::<history_cell::WaitStatusCell>()
                .is_some()
            {
                next += 1;
                continue;
            }

            if self.cell_lines_trimmed_is_empty(next, cell.as_ref()) {
                next += 1;
                continue;
            }

            return false;
        }

        true
    }

    fn try_coordinator_route(
        &mut self,
        original_text: &str,
    ) -> Option<CoordinatorRouterResponse> {
        let trimmed = original_text.trim();
        if trimmed.is_empty() {
            return None;
        }
        if !self.auto_state.is_active() {
            return None;
        }
        if self.auto_state.is_paused_manual()
            && self.auto_state.should_bypass_coordinator_next_submit()
        {
            return None;
        }
        if !self.config.auto_drive.coordinator_routing {
            return None;
        }
        if trimmed.starts_with('/') {
            return None;
        }

        let mut updates = Vec::new();
        if let Some(summary) = self.auto_state.last_decision_summary.clone() {
            if !summary.trim().is_empty() {
                updates.push(summary);
            }
        }
        if let Some(current) = self.auto_state.current_summary.clone() {
            if !current.trim().is_empty() && updates.iter().all(|existing| existing != &current) {
                updates.push(current);
            }
        }

        let context = CoordinatorContext::new(self.auto_state.pending_agent_actions.len(), updates);
        let response = route_user_message(trimmed, &context);
        if response.user_response.is_some() || response.cli_command.is_some() {
            Some(response)
        } else {
            None
        }
    }

    fn submit_user_message(&mut self, user_message: UserMessage) {
        if self.layout.scroll_offset > 0 {
            layout_scroll::to_bottom(self);
        }
        // Surface a local diagnostic note and anchor it to the NEXT turn,
        // placing it directly after the user prompt so ordering is stable.
        // (debug message removed)
        // Fade the welcome cell only when a user actually posts a message.
        for cell in &self.history_cells {
            cell.trigger_fade();
        }
        let mut message = user_message;
        // If our configured cwd no longer exists (e.g., a worktree folder was
        // deleted outside the app), try to automatically recover to the repo
        // root for worktrees and re-submit the same message there.
        if !self.config.cwd.exists() {
            let missing = self.config.cwd.clone();
            let mut fallback: Option<(PathBuf, &'static str)> =
                worktree_root_hint_for(&missing).map(|p| (p, "recorded repo root"));
            if fallback.is_none() {
                if let Some(parent) = missing.parent().and_then(worktree_root_hint_for) {
                    fallback = Some((parent, "recorded repo root"));
                }
            }
            if fallback.is_none() {
                if let Some(prev) = last_existing_cwd(&missing) {
                    fallback = Some((prev, "last known directory"));
                }
            }
            let missing_s = missing.display().to_string();
            if fallback.is_none() && missing_s.contains("/.code/branches/") {
                let mut current = missing.as_path();
                let mut first_existing: Option<PathBuf> = None;
                while let Some(parent) = current.parent() {
                    current = parent;
                    if !current.exists() {
                        continue;
                    }
                    if first_existing.is_none() {
                        first_existing = Some(current.to_path_buf());
                    }
                    if let Some(repo_root) =
                        code_core::git_info::resolve_root_git_project_for_trust(current)
                    {
                        fallback = Some((repo_root, "repository root"));
                        break;
                    }
                }
                if fallback.is_none() {
                    if let Some(existing) = first_existing {
                        fallback = Some((existing, "parent directory"));
                    }
                }
            }
            if fallback.is_none() {
                if let Some(home) = std::env::var_os("HOME").map(PathBuf::from) {
                    fallback = Some((home, "home directory"));
                }
            }
            if let Some((fallback_root, label)) = fallback {
                let msg = format!(
                    "⚠️ Worktree directory is missing: {}\nSwitching to {}: {}",
                    missing.display(),
                    label,
                    fallback_root.display()
                );
                self.send_background_tail_ordered(msg);
                self.app_event_tx.send(AppEvent::SwitchCwd(
                    fallback_root,
                    Some(message.display_text.clone()),
                ));
                return;
            }
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "Working directory is missing: {}",
                self.config.cwd.display()
            )));
            return;
        }
        let original_text = message.display_text.clone();
        if self.try_submit_weave_task_message(&message) {
            return;
        }

        let mut submitted_cli = false;
        let manual_edit_pending = self.auto_state.is_paused_manual()
            && self.auto_state.resume_after_submit();
        let manual_override_active = self.auto_state.is_paused_manual();
        let bypass_active = self.auto_state.should_bypass_coordinator_next_submit();
        let coordinator_routing_allowed = if bypass_active {
            manual_edit_pending || manual_override_active
        } else {
            true
        };

        let should_route_through_coordinator = !message.suppress_persistence
            && !original_text.trim().starts_with('/')
            && self.auto_state.is_active()
            && self.config.auto_drive.coordinator_routing
            && coordinator_routing_allowed;

        if should_route_through_coordinator
        {
            let mut conversation = self.current_auto_history();
            if let Some(user_item) = Self::auto_drive_make_user_message(original_text.clone()) {
                conversation.push(user_item.clone());
                if self.auto_send_user_prompt_to_coordinator(original_text.clone(), conversation) {
                    self.finalize_sent_user_message(message);
                    self.consume_pending_prompt_for_ui_only_turn();
                    self.auto_history.append_raw(std::slice::from_ref(&user_item));
                    return;
                }
            }
        }

        if !message.suppress_persistence
            && self.auto_state.is_active()
            && self.config.auto_drive.coordinator_routing
            && coordinator_routing_allowed
        {
            if let Some(mut routed) = self.try_coordinator_route(&original_text) {
                self.finalize_sent_user_message(message);
                self.consume_pending_prompt_for_ui_only_turn();

                if let Some(notice_text) = routed.user_response.take() {
                    if let Some(item) =
                        Self::auto_drive_make_assistant_message(notice_text.clone())
                    {
                        self.auto_history.append_raw(std::slice::from_ref(&item));
                    }
                    let mut lines = Vec::with_capacity(2);
                    lines.push("AUTO DRIVE RESPONSE".to_string());
                    lines.push(notice_text);
                    self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);
                }

                let _ = self.rebuild_auto_history();

                if let Some(cli_command) = routed.cli_command {
                    let mut synthetic: UserMessage = cli_command.into();
                    synthetic.suppress_persistence = true;
                    self.submit_user_message(synthetic);
                    submitted_cli = true;
                }

                if !submitted_cli {
                    self.auto_send_conversation_force();
                }

                return;
            }
        }

        let only_text_items = message
            .ordered_items
            .iter()
            .all(|item| matches!(item, InputItem::Text { .. }));
        if only_text_items {
            if let Some((command_line, rest_text)) =
                Self::split_leading_slash_command(&original_text)
            {
                if Self::multiline_slash_command_requires_split(&command_line) {
                    let preview = crate::slash_command::process_slash_command_message(
                        command_line.as_str(),
                    );
                    match preview {
                        ProcessedCommand::RegularCommand(SlashCommand::Auto, canonical_text) => {
                            let goal = rest_text.trim();
                            let command_text = if goal.is_empty() {
                                canonical_text
                            } else {
                                format!("{canonical_text} {goal}")
                            };
                            self.app_event_tx
                                .send(AppEvent::DispatchCommand(SlashCommand::Auto, command_text));
                            return;
                        }
                        ProcessedCommand::NotCommand(_) => {}
                        _ => {
                            self.submit_user_message(command_line.into());
                            let trimmed_rest = rest_text.trim();
                            if !trimmed_rest.is_empty() {
                                self.submit_user_message(rest_text.into());
                            }
                            return;
                        }
                    }
                }
            }
        }
        // Build a combined string view of the text-only parts to process slash commands
        let mut text_only = String::new();
        for it in &message.ordered_items {
            if let InputItem::Text { text } = it {
                if !text_only.is_empty() {
                    text_only.push('\n');
                }
                text_only.push_str(text);
            }
        }

        // Expand user-defined custom prompts, supporting both "/prompts:name" and "/name" forms.
        match prompt_args::expand_custom_prompt(&text_only, self.bottom_pane.custom_prompts()) {
            Ok(Some(expanded)) => {
                text_only = expanded.clone();
                message
                    .ordered_items
                    .clear();
                message
                    .ordered_items
                    .push(InputItem::Text { text: expanded });
            }
            Ok(None) => {}
            Err(err) => {
                self.history_push_plain_state(history_cell::new_error_event(err.user_message()));
                return;
            }
        }

        // Save the prompt if it's a multi-agent command
        let original_trimmed = original_text.trim();
        if original_trimmed.starts_with("/plan ")
            || original_trimmed.starts_with("/solve ")
            || original_trimmed.starts_with("/code ")
        {
            self.last_agent_prompt = Some(original_text.clone());
        }

        // Process slash commands and expand them if needed
        // First, allow custom subagent commands: if the message starts with a slash and the
        // command name matches a saved subagent in config, synthesize a unified prompt using
        // format_subagent_command and replace the message with that prompt.
        if let Some(first) = original_text.trim().strip_prefix('/') {
            let mut parts = first.splitn(2, ' ');
            let cmd_name = parts.next().unwrap_or("").trim();
            let args = parts.next().unwrap_or("").trim().to_string();
            if !cmd_name.is_empty() {
                let has_custom = self
                    .config
                    .subagent_commands
                    .iter()
                    .any(|c| c.name.eq_ignore_ascii_case(cmd_name));
                // Treat built-ins via the standard path below to preserve existing ack flow,
                // but allow any other saved subagent command to be executed here.
                let is_builtin = matches!(
                    cmd_name.to_ascii_lowercase().as_str(),
                    "plan" | "solve" | "code"
                );
                if has_custom && !is_builtin {
                    let res = code_core::slash_commands::format_subagent_command(
                        cmd_name,
                        &args,
                        Some(&self.config.agents),
                        Some(&self.config.subagent_commands),
                    );
                    if !res.read_only
                        && self.ensure_git_repo_for_action(
                            GitInitResume::SubmitText {
                                text: original_text.clone(),
                            },
                            "Write-enabled agents require a git repository.",
                        )
                    {
                        return;
                    }
                    // Acknowledge configuration
                    let mode = if res.read_only { "read-only" } else { "write" };
                    let agents = if res.models.is_empty() {
                        "<none>".to_string()
                    } else {
                        res.models.join(", ")
                    };
                    let lines = vec![
                        format!("/{} configured", res.name),
                        format!("mode: {}", mode),
                        format!("agents: {}", agents),
                        format!("command: {}", original_text.trim()),
                    ];
                    self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);

                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: res.prompt });
                    // Continue with normal submission after this match block
                }
            }
        }

        let processed = crate::slash_command::process_slash_command_message(&text_only);
        match processed {
            crate::slash_command::ProcessedCommand::ExpandedPrompt(_expanded) => {
                // If a built-in multi-agent slash command was used, resolve
                // configured subagent settings and feed the synthesized prompt
                // without echoing an additional acknowledgement cell.
                let trimmed = original_trimmed;
                let (cmd_name, args_opt) = if let Some(rest) = trimmed.strip_prefix("/plan ") {
                    ("plan", Some(rest.trim().to_string()))
                } else if let Some(rest) = trimmed.strip_prefix("/solve ") {
                    ("solve", Some(rest.trim().to_string()))
                } else if let Some(rest) = trimmed.strip_prefix("/code ") {
                    ("code", Some(rest.trim().to_string()))
                } else {
                    ("", None)
                };

                if let Some(task) = args_opt {
                    let res = code_core::slash_commands::format_subagent_command(
                        cmd_name,
                        &task,
                        Some(&self.config.agents),
                        Some(&self.config.subagent_commands),
                    );
                    if !res.read_only
                        && self.ensure_git_repo_for_action(
                            GitInitResume::SubmitText {
                                text: original_text.clone(),
                            },
                            "Write-enabled agents require a git repository.",
                        )
                    {
                        return;
                    }

                    // Replace the message with the resolved prompt and suppress the
                    // agent launch hint that would otherwise echo back immediately.
                    self.suppress_next_agent_hint = true;
                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: res.prompt });
                } else {
                    // Fallback to default expansion behavior
                    let expanded = _expanded;
                    message
                        .ordered_items
                        .clear();
                    message
                        .ordered_items
                        .push(InputItem::Text { text: expanded });
                }
            }
            crate::slash_command::ProcessedCommand::RegularCommand(cmd, command_text) => {
                if cmd == SlashCommand::Undo {
                    self.handle_undo_command();
                    return;
                }
                // This is a regular slash command, dispatch it normally
                self.app_event_tx
                    .send(AppEvent::DispatchCommand(cmd, command_text));
                return;
            }
            crate::slash_command::ProcessedCommand::Error(error_msg) => {
                // Show error in history
                self.history_push_plain_state(history_cell::new_error_event(error_msg));
                return;
            }
            crate::slash_command::ProcessedCommand::NotCommand(_) => {
                // Not a slash command, process normally
            }
        }

        let mut items: Vec<InputItem> = Vec::new();

        // Check if browser mode is enabled and capture screenshot
        // IMPORTANT: Always use global browser manager for consistency
        // The global browser manager ensures both TUI and agent tools use the same instance

        // Start async screenshot capture in background (non-blocking)
        {
            let latest_browser_screenshot_clone = Arc::clone(&self.latest_browser_screenshot);

            tokio::spawn(async move {
                tracing::info!("Evaluating background screenshot capture...");

                // Rate-limit: skip if a capture ran very recently (< 4000ms)
                let now_ms = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64;
                let last = BG_SHOT_LAST_START_MS.load(Ordering::Relaxed);
                if now_ms.saturating_sub(last) < 4000 {
                    tracing::info!("Skipping background screenshot: rate-limited");
                    return;
                }

                // Single-flight: skip if another capture is in progress
                if BG_SHOT_IN_FLIGHT.swap(true, Ordering::AcqRel) {
                    tracing::info!("Skipping background screenshot: already in-flight");
                    return;
                }
                // Ensure we always clear the flag
                struct ShotGuard;
                impl Drop for ShotGuard {
                    fn drop(&mut self) {
                        BG_SHOT_IN_FLIGHT.store(false, Ordering::Release);
                    }
                }
                let _guard = ShotGuard;

                // Short settle to allow page to reach a stable state; keep it small
                tokio::time::sleep(tokio::time::Duration::from_millis(800)).await;

                let Some(browser_manager) = code_browser::global::get_browser_manager().await else {
                    tracing::info!("Skipping background screenshot: browser manager unavailable");
                    return;
                };

                if !browser_manager.is_enabled().await {
                    tracing::info!("Skipping background screenshot: browser disabled");
                    return;
                }

                if browser_manager.idle_elapsed_past_timeout().await.is_some() {
                    tracing::info!("Skipping background screenshot: browser idle");
                    return;
                }

                BG_SHOT_LAST_START_MS.store(now_ms, Ordering::Relaxed);

                // Retry screenshot capture with exponential backoff
                // Keep background capture lightweight: single attempt with a modest timeout
                let mut attempts = 0;
                let max_attempts = 1;

                loop {
                    attempts += 1;
                    tracing::info!(
                        "Screenshot capture attempt {} of {}",
                        attempts,
                        max_attempts
                    );

                    // Add timeout to screenshot capture
                    let capture_result = tokio::time::timeout(
                        tokio::time::Duration::from_secs(5),
                        browser_manager.capture_screenshot_with_url(),
                    )
                    .await;

                    match capture_result {
                        Ok(Ok((screenshot_paths, url))) => {
                            tracing::info!(
                                "Background screenshot capture succeeded with {} images on attempt {}",
                                screenshot_paths.len(),
                                attempts
                            );

                            // Save the first screenshot path and URL for display in the TUI
                            if let Some(first_path) = screenshot_paths.first() {
                                if let Ok(mut latest) = latest_browser_screenshot_clone.lock() {
                                    let url_string =
                                        url.clone().unwrap_or_else(|| "Browser".to_string());
                                    *latest = Some((first_path.clone(), url_string));
                                }
                            }

                            // Create screenshot items
                            let mut screenshot_items = Vec::new();
                            for path in screenshot_paths {
                                if path.exists() {
                                    tracing::info!("Adding browser screenshot: {}", path.display());
                                    let timestamp = std::time::SystemTime::now()
                                        .duration_since(std::time::UNIX_EPOCH)
                                        .unwrap_or_default()
                                        .as_secs();
                                    let metadata = format!(
                                        "screenshot:{}:{}",
                                        timestamp,
                                        url.as_deref().unwrap_or("unknown")
                                    );
                                    screenshot_items.push(InputItem::EphemeralImage {
                                        path,
                                        metadata: Some(metadata),
                                    });
                                }
                            }

                            // Do not enqueue screenshots as messages.
                            // They are now injected per-turn by the core session.
                            break; // Success - exit retry loop
                        }
                        Ok(Err(e)) => {
                            tracing::warn!(
                                "Background screenshot capture failed (attempt {}): {}",
                                attempts,
                                e
                            );
                            break;
                        }
                        Err(_timeout_err) => {
                            tracing::warn!(
                                "Background screenshot capture timed out (attempt {})",
                                attempts
                            );
                            break;
                        }
                    }
                }
            });
        }

        // Use the ordered items (text + images interleaved with markers)
        items.extend(message.ordered_items.clone());
        message.ordered_items = items;

        if message.ordered_items.is_empty() {
            return;
        }

        let wait_only_active = self.wait_only_activity();
        let turn_active = (self.is_task_running()
            || !self.active_task_ids.is_empty()
            || self.stream.is_write_cycle_active()
            || !self.queued_user_messages.is_empty())
            && !wait_only_active;

        if turn_active {
            tracing::info!(
                "[queue] Enqueuing user input while turn is active (queue_size={}, task_running={}, stream_active={}, active_tasks={})",
                self.queued_user_messages.len() + 1,
                self.is_task_running(),
                self.stream.is_write_cycle_active(),
                self.active_task_ids.len()
            );
            let queued_clone = message.clone();
            self.queued_user_messages.push_back(queued_clone);
            self.refresh_queued_user_messages(true);

            let prompt_summary = if message.display_text.trim().is_empty() {
                None
            } else {
                Some(message.display_text.clone())
            };

            let should_capture_snapshot = self.active_ghost_snapshot.is_none()
                && self.ghost_snapshot_queue.is_empty();
            if should_capture_snapshot {
                let _ = self.capture_ghost_snapshot(prompt_summary);
            }
            self.dispatch_queued_user_message_now(message);
            return;
        }

        if wait_only_active {
            // Keep long waits running but do not block user input.
            self.bottom_pane.set_task_running(false);
            self.bottom_pane
                .update_status_text("Waiting in background".to_string());
        }

        tracing::info!(
            "[queue] Turn idle, enqueuing and preparing to drain (auto_active={}, queue_size={})",
            self.auto_state.is_active(),
            self.queued_user_messages.len() + 1
        );

        let queued_clone = message.clone();
        self.queued_user_messages.push_back(queued_clone);
        self.refresh_queued_user_messages(false);

        let batch: Vec<UserMessage> = self.queued_user_messages.iter().cloned().collect();
        let summary = batch
            .last()
            .and_then(|msg| {
                let trimmed = msg.display_text.trim();
                if trimmed.is_empty() {
                    None
                } else {
                    Some(msg.display_text.clone())
                }
            });

        let _ = self.capture_ghost_snapshot(summary);

        if self.auto_state.is_active() {
            tracing::info!(
                "[queue] Draining via coordinator path for Auto Drive (batch_size={})",
                batch.len()
            );
            self.dispatch_queued_batch_via_coordinator(batch);
        } else {
            tracing::info!(
                "[queue] Draining via direct batch dispatch (batch_size={})",
                batch.len()
            );
            self.dispatch_queued_batch(batch);
        }

        // (debug watchdog removed)
    }

    fn split_leading_slash_command(text: &str) -> Option<(String, String)> {
        if !text.starts_with('/') {
            return None;
        }
        let mut parts = text.splitn(2, '\n');
        let first_line = parts.next().unwrap_or_default();
        let rest = parts.next().unwrap_or("");
        if rest.is_empty() {
            return None;
        }
        let command = first_line.trim_end_matches('\r');
        if command.is_empty() {
            return None;
        }
        if rest.trim().is_empty() {
            return None;
        }
        Some((command.to_string(), rest.to_string()))
    }

    fn slash_command_from_line(line: &str) -> Option<SlashCommand> {
        let trimmed = line.trim();
        let command_portion = trimmed.strip_prefix('/')?;
        let name = command_portion.split_whitespace().next()?;
        let canonical = name.to_ascii_lowercase();
        SlashCommand::from_str(&canonical).ok()
    }

    fn multiline_slash_command_requires_split(command_line: &str) -> bool {
        Self::slash_command_from_line(command_line)
            .map(|cmd| !cmd.is_prompt_expanding())
            .unwrap_or(true)
    }

    fn capture_ghost_snapshot(&mut self, summary: Option<String>) -> GhostSnapshotJobHandle {
        if self.ghost_snapshots_disabled {
            return GhostSnapshotJobHandle::Skipped;
        }

        let request = GhostSnapshotRequest::new(
            summary,
            self.current_conversation_snapshot(),
            self.history_snapshot_for_persistence(),
        );
        self.enqueue_ghost_snapshot(request)
    }

    fn capture_ghost_snapshot_blocking(&mut self, summary: Option<String>) -> Option<GhostSnapshot> {
        if self.ghost_snapshots_disabled {
            return None;
        }

        let request = GhostSnapshotRequest::new(
            summary,
            self.current_conversation_snapshot(),
            self.history_snapshot_for_persistence(),
        );
        let repo_path = self.config.cwd.clone();
        let started_at = request.started_at;
        let hook_repo = repo_path.clone();
        let result = create_ghost_commit(
            &CreateGhostCommitOptions::new(repo_path.as_path())
                .post_commit_hook(&move || bump_snapshot_epoch_for(&hook_repo)),
        );
        let elapsed = started_at.elapsed();
        let snapshot = self.finalize_ghost_snapshot(request, result, elapsed);
        snapshot
    }

    fn dispatch_queued_batch(&mut self, batch: Vec<UserMessage>) {
        if batch.is_empty() {
            return;
        }

        let mut messages: Vec<UserMessage> = Vec::with_capacity(batch.len());

        for message in batch {
            let Some(message) = self.take_queued_user_message(&message) else {
                tracing::info!("Skipping queued user input removed before dispatch");
                continue;
            };
            messages.push(message);
        }

        if messages.is_empty() {
            return;
        }

        let mut combined_items: Vec<InputItem> = Vec::new();

        for (idx, message) in messages.iter().enumerate() {
            if idx > 0 && !combined_items.is_empty() && !message.ordered_items.is_empty() {
                combined_items.push(InputItem::Text {
                    text: "\n\n".to_string(),
                });
            }
            combined_items.extend(message.ordered_items.clone());
        }

        let total_items = combined_items.len();
        let ephemeral_count = combined_items
            .iter()
            .filter(|item| matches!(item, InputItem::EphemeralImage { .. }))
            .count();
        if ephemeral_count > 0 {
            tracing::info!(
                "Sending {} items to model (including {} ephemeral images)",
                total_items,
                ephemeral_count
            );
        }

        if !combined_items.is_empty() {
            self.flush_pending_agent_notes();
            if let Err(e) = self
                .code_op_tx
                .send(Op::UserInput {
                    items: combined_items,
                    final_output_json_schema: None,
                })
            {
                tracing::error!("failed to send Op::UserInput: {e}");
            }
        }

        for message in messages {
            self.finalize_sent_user_message(message);
        }
    }

    fn dispatch_queued_user_message_now(&mut self, message: UserMessage) {
        let message = self.take_queued_user_message(&message).unwrap_or(message);
        let items = message.ordered_items.clone();
        tracing::info!(
            "[queue] Dispatching single queued message via coordinator (queue_remaining={})",
            self.queued_user_messages.len()
        );
        match self.code_op_tx.send(Op::QueueUserInput { items }) {
            Ok(()) => {
                self.finalize_sent_user_message(message);
            }
            Err(err) => {
                tracing::error!("failed to send QueueUserInput op: {err}");
                self.queued_user_messages.push_front(message);
                self.refresh_queued_user_messages(true);
            }
        }
    }

    fn dispatch_queued_batch_via_coordinator(&mut self, batch: Vec<UserMessage>) {
        if batch.is_empty() {
            return;
        }

        tracing::info!(
            "[queue] Draining batch via coordinator path (batch_size={}, auto_active={})",
            batch.len(),
            self.auto_state.is_active()
        );

        for message in batch {
            let Some(message) = self.take_queued_user_message(&message) else {
                tracing::info!("[queue] Skipping queued user input removed before dispatch");
                continue;
            };

            let items = message.ordered_items.clone();
            match self.code_op_tx.send(Op::QueueUserInput { items }) {
                Ok(()) => {
                    self.finalize_sent_user_message(message);
                }
                Err(err) => {
                    tracing::error!("[queue] Failed to send QueueUserInput op: {err}");
                    self.queued_user_messages.push_front(message);
                    self.refresh_queued_user_messages(true);
                    break;
                }
            }
        }
    }

    fn take_queued_user_message(&mut self, target: &UserMessage) -> Option<UserMessage> {
        let position = self
            .queued_user_messages
            .iter()
            .position(|message| message == target)?;
        let removed = self.queued_user_messages.remove(position)?;
        self.refresh_queued_user_messages(false);
        Some(removed)
    }

    fn enqueue_ghost_snapshot(&mut self, request: GhostSnapshotRequest) -> GhostSnapshotJobHandle {
        let job_id = self.next_ghost_snapshot_id;
        self.next_ghost_snapshot_id = self.next_ghost_snapshot_id.wrapping_add(1);
        self.ghost_snapshot_queue.push_back((job_id, request));
        self.spawn_next_ghost_snapshot();
        GhostSnapshotJobHandle::Scheduled(job_id)
    }

    fn spawn_next_ghost_snapshot(&mut self) {
        if self.ghost_snapshots_disabled {
            self.ghost_snapshot_queue.clear();
            return;
        }
        if self.active_ghost_snapshot.is_some() {
            return;
        }
        let Some((job_id, request)) = self.ghost_snapshot_queue.pop_front() else {
            return;
        };

        let repo_path = self.config.cwd.clone();
        let app_event_tx = self.app_event_tx.clone();
        let notice_ticket = self.make_background_tail_ticket();
        let started_at = request.started_at;
        self.active_ghost_snapshot = Some((job_id, request));

        tokio::spawn(async move {
            let handle = tokio::task::spawn_blocking(move || {
                let hook_repo = repo_path.clone();
                let options = CreateGhostCommitOptions::new(repo_path.as_path());
                create_ghost_commit(&options.post_commit_hook(&move || bump_snapshot_epoch_for(&hook_repo)))
            });
            tokio::pin!(handle);

            let mut notice_sent = false;
            let notice_sleep = tokio::time::sleep(GHOST_SNAPSHOT_NOTICE_THRESHOLD);
            tokio::pin!(notice_sleep);
            let timeout_sleep = tokio::time::sleep(GHOST_SNAPSHOT_TIMEOUT);
            tokio::pin!(timeout_sleep);

            let join_result = loop {
                tokio::select! {
                    res = &mut handle => break res,
                    _ = &mut timeout_sleep => {
                        handle.as_mut().abort();
                        let elapsed = started_at.elapsed();
                        let err = GitToolingError::Io(io::Error::new(
                            io::ErrorKind::TimedOut,
                            format!(
                                "ghost snapshot exceeded {}",
                                format_duration(GHOST_SNAPSHOT_TIMEOUT)
                            ),
                        ));
                        let event = AppEvent::GhostSnapshotFinished {
                            job_id,
                            result: Err(err),
                            elapsed,
                        };
                        app_event_tx.send(event);
                        return;
                    }
                    _ = &mut notice_sleep, if !notice_sent => {
                        notice_sent = true;
                        let elapsed = started_at.elapsed();
                        let message = format!(
                            "Git snapshot still running… {} elapsed.",
                            format_duration(elapsed)
                        );
                        app_event_tx.send_background_event_with_ticket(&notice_ticket, message);
                    }
                }
            };

            let elapsed = started_at.elapsed();
            let event = match join_result {
                Ok(Ok(commit)) => AppEvent::GhostSnapshotFinished {
                    job_id,
                    result: Ok(commit),
                    elapsed,
                },
                Ok(Err(err)) => AppEvent::GhostSnapshotFinished {
                    job_id,
                    result: Err(err),
                    elapsed,
                },
                Err(join_err) => {
                    let err = GitToolingError::Io(io::Error::new(
                        io::ErrorKind::Other,
                        format!("ghost snapshot task failed: {join_err}"),
                    ));
                    AppEvent::GhostSnapshotFinished {
                        job_id,
                        result: Err(err),
                        elapsed,
                    }
                }
            };

            app_event_tx.send(event);
        });
    }

    fn finalize_ghost_snapshot(
        &mut self,
        request: GhostSnapshotRequest,
        result: Result<GhostCommit, GitToolingError>,
        elapsed: Duration,
    ) -> Option<GhostSnapshot> {
        match result {
            Ok(commit) => {
                self.ghost_snapshots_disabled = false;
                self.ghost_snapshots_disabled_reason = None;
                let snapshot = GhostSnapshot::new(
                    commit,
                    request.summary,
                    request.conversation,
                    request.history,
                );
                self.ghost_snapshots.push(snapshot.clone());
                session_log::log_history_snapshot(
                    snapshot.commit().id(),
                    snapshot.summary.as_deref(),
                    &snapshot.history,
                );
                if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
                    self.ghost_snapshots.remove(0);
                }
                if elapsed >= GHOST_SNAPSHOT_NOTICE_THRESHOLD {
                    self.push_background_tail(format!(
                        "Git snapshot captured in {}.",
                        format_duration(elapsed)
                    ));
                }
                Some(snapshot)
            }
            Err(err) => {
                if let GitToolingError::Io(io_err) = &err {
                    if io_err.kind() == io::ErrorKind::TimedOut {
                        self.push_background_tail(format!(
                            "Git snapshot timed out after {}. Try again once the repository is less busy.",
                            format_duration(elapsed)
                        ));
                        tracing::warn!(
                            elapsed = %format_duration(elapsed),
                            "ghost snapshot timed out"
                        );
                        return None;
                    }
                }
                self.ghost_snapshots_disabled = true;
                let (message, hint) = match &err {
                    GitToolingError::NotAGitRepository { .. } => (
                        "Snapshots disabled: this workspace is not inside a Git repository.".to_string(),
                        None,
                    ),
                    _ => (
                        format!("Snapshots disabled after Git error: {err}"),
                        Some(
                            "Restart Code after resolving the issue to re-enable snapshots.".to_string(),
                        ),
                    ),
                };
                self.ghost_snapshots_disabled_reason = Some(GhostSnapshotsDisabledReason {
                    message: message.clone(),
                    hint: hint.clone(),
                });
                self.push_background_tail(message);
                if let Some(hint) = hint {
                    self.push_background_tail(hint);
                }
                tracing::warn!("failed to create ghost snapshot: {err}");
                self.ghost_snapshot_queue.clear();
                None
            }
        }
    }

    pub(crate) fn handle_ghost_snapshot_finished(
        &mut self,
        job_id: u64,
        result: Result<GhostCommit, GitToolingError>,
        elapsed: Duration,
    ) {
        let Some((active_id, request)) = self.active_ghost_snapshot.take() else {
            tracing::warn!("ghost snapshot finished without active job (id={job_id})");
            return;
        };

        if active_id != job_id {
            tracing::warn!(
                "ghost snapshot job id mismatch: expected {active_id}, got {job_id}"
            );
            self.active_ghost_snapshot = Some((active_id, request));
            return;
        }

        let _ = self.finalize_ghost_snapshot(request, result, elapsed);
        self.request_redraw();
        self.spawn_next_ghost_snapshot();
    }

    fn current_conversation_snapshot(&self) -> ConversationSnapshot {
        use crate::history_cell::HistoryCellType;
        let mut user_turns = 0usize;
        let mut assistant_turns = 0usize;
        for cell in &self.history_cells {
            match cell.kind() {
                HistoryCellType::User => user_turns = user_turns.saturating_add(1),
                HistoryCellType::Assistant => {
                    assistant_turns = assistant_turns.saturating_add(1)
                }
                _ => {}
            }
        }
        let mut snapshot = ConversationSnapshot::new(user_turns, assistant_turns);
        snapshot.history_len = self.history_cells.len();
        snapshot.order_len = self.cell_order_seq.len();
        snapshot.order_dbg_len = self.cell_order_dbg.len();
        snapshot
    }

    fn conversation_delta_since(
        &self,
        snapshot: &ConversationSnapshot,
    ) -> (usize, usize) {
        let current = self.current_conversation_snapshot();
        let user_delta = current
            .user_turns
            .saturating_sub(snapshot.user_turns);
        let assistant_delta = current
            .assistant_turns
            .saturating_sub(snapshot.assistant_turns);
        (user_delta, assistant_delta)
    }

    fn history_snapshot_for_persistence(&self) -> HistorySnapshot {
        let order: Vec<OrderKeySnapshot> = self
            .cell_order_seq
            .iter()
            .map(|key| (*key).into())
            .collect();
        let order_debug = self.cell_order_dbg.clone();
        self.history_state
            .snapshot()
            .with_order(order, order_debug)
    }

    fn mark_history_dirty(&mut self) {
        self.history_snapshot_dirty = true;
        self.render_request_cache_dirty.set(true);
        self.flush_history_snapshot_if_needed(false);
        self.sync_history_virtualization();
    }

    fn flush_history_snapshot_if_needed(&mut self, force: bool) {
        if !self.history_snapshot_dirty {
            return;
        }
        if !force {
            if let Some(last) = self.history_snapshot_last_flush {
                if last.elapsed() < Duration::from_millis(400) {
                    return;
                }
            }
        }
        let snapshot = self.history_snapshot_for_persistence();
        match serde_json::to_value(&snapshot) {
            Ok(snapshot_value) => {
                let send_result = self
                    .code_op_tx
                    .send(Op::PersistHistorySnapshot { snapshot: snapshot_value });
                if send_result.is_err() {
                    tracing::warn!("failed to send history snapshot to core");
                } else {
                    self.history_snapshot_dirty = false;
                }
                self.history_snapshot_last_flush = Some(Instant::now());
            }
            Err(err) => {
                tracing::warn!("failed to serialize history snapshot: {err}");
            }
        }
    }

    pub(crate) fn snapshot_ghost_state(&self) -> GhostState {
        GhostState {
            snapshots: self.ghost_snapshots.clone(),
            disabled: self.ghost_snapshots_disabled,
            disabled_reason: self.ghost_snapshots_disabled_reason.clone(),
            queue: self.ghost_snapshot_queue.clone(),
            active: self.active_ghost_snapshot.clone(),
            next_id: self.next_ghost_snapshot_id,
            queued_user_messages: self.queued_user_messages.clone(),
        }
    }

    pub(crate) fn adopt_ghost_state(&mut self, state: GhostState) {
        self.ghost_snapshots = state.snapshots;
        if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
            self.ghost_snapshots
                .truncate(MAX_TRACKED_GHOST_COMMITS);
        }
        self.ghost_snapshots_disabled = state.disabled;
        self.ghost_snapshots_disabled_reason = state.disabled_reason;
        self.ghost_snapshot_queue = state.queue;
        self.active_ghost_snapshot = state.active;
        self.next_ghost_snapshot_id = state.next_id;
        self.queued_user_messages = state.queued_user_messages;
        let blocked = self.is_task_running()
            || !self.active_task_ids.is_empty()
            || self.stream.is_write_cycle_active();
        self.refresh_queued_user_messages(blocked);
        self.spawn_next_ghost_snapshot();
    }

    pub(crate) fn handle_undo_command(&mut self) {
        if self.ghost_snapshots_disabled {
            let reason = self
                .ghost_snapshots_disabled_reason
                .as_ref()
                .map(|reason| reason.message.clone())
                .unwrap_or_else(|| "Snapshots are currently disabled.".to_string());
            self.push_background_tail(format!("/undo unavailable: {reason}"));
            self.show_undo_snapshots_disabled();
            return;
        }

        if self.ghost_snapshots.is_empty() {
            self.push_background_tail(
                "/undo unavailable: no snapshots captured yet. Run a file-modifying command to create one.".to_string(),
            );
            self.show_undo_empty_state();
            return;
        }

        self.show_undo_snapshot_picker();
    }

    fn show_undo_snapshots_disabled(&mut self) {
        let mut lines: Vec<String> = Vec::new();
        if let Some(reason) = &self.ghost_snapshots_disabled_reason {
            lines.push(reason.message.clone());
            if let Some(hint) = &reason.hint {
                lines.push(hint.clone());
            }
        } else {
            lines.push(
                "Snapshots are currently disabled. Resolve the Git issue and restart Code to re-enable them.".to_string(),
            );
        }

        self.show_undo_status_popup(
            "Snapshots unavailable",
            Some(
                "Restores workspace files only. Conversation history remains unchanged.".to_string(),
            ),
            Some("Automatic snapshotting failed, so /undo cannot restore the workspace.".to_string()),
            lines,
        );
    }

    fn show_undo_empty_state(&mut self) {
        self.show_undo_status_popup(
            "No snapshots yet",
            Some(
                "Restores workspace files only. Conversation history remains unchanged.".to_string(),
            ),
            Some("Snapshots appear once Code captures a Git checkpoint.".to_string()),
            vec![
                "No snapshot is available to restore.".to_string(),
                "Run a command that modifies files to create the first snapshot.".to_string(),
            ],
        );
    }

    fn show_undo_status_popup(
        &mut self,
        title: &str,
        scope_hint: Option<String>,
        subtitle: Option<String>,
        mut lines: Vec<String>,
    ) {
        if lines.is_empty() {
            lines.push("No snapshot information available.".to_string());
        }

        let headline = lines.remove(0);
        let description = if lines.is_empty() {
            None
        } else {
            Some(lines.join("\n"))
        };

        let mut composed_subtitle = Vec::new();
        if let Some(hint) = scope_hint {
            composed_subtitle.push(hint);
        }
        if let Some(extra) = subtitle {
            composed_subtitle.push(extra);
        }
        let subtitle_for_view = if composed_subtitle.is_empty() {
            None
        } else {
            Some(composed_subtitle.join("\n"))
        };

        let items = vec![SelectionItem {
            name: headline,
            description,
            is_current: true,
            actions: Vec::new(),
        }];

        let view = ListSelectionView::new(
            format!(" {title} "),
            subtitle_for_view,
            Some("Esc close".to_string()),
            items,
            self.app_event_tx.clone(),
            1,
        );

        self.bottom_pane.show_list_selection(
            title.to_string(),
            None,
            Some("Esc close".to_string()),
            view,
        );
    }

    fn show_undo_snapshot_picker(&mut self) {
        let entries = self.build_undo_timeline_entries();
        if entries.len() <= 1 {
            self.push_background_tail(
                "/undo unavailable: no snapshots captured yet. Run a file-modifying command to create one.".to_string(),
            );
            self.show_undo_empty_state();
            return;
        }

        let current_index = entries.len().saturating_sub(1);
        let view = UndoTimelineView::new(entries, current_index, self.app_event_tx.clone());
        self.bottom_pane.show_undo_timeline_view(view);
    }

    fn build_undo_timeline_entries(&self) -> Vec<UndoTimelineEntry> {
        let mut entries: Vec<UndoTimelineEntry> = Vec::with_capacity(self.ghost_snapshots.len().saturating_add(1));
        for snapshot in self.ghost_snapshots.iter() {
            entries.push(self.timeline_entry_for_snapshot(snapshot));
        }
        entries.push(self.timeline_entry_for_current());
        entries
    }

    fn timeline_entry_for_snapshot(&self, snapshot: &GhostSnapshot) -> UndoTimelineEntry {
        let short_id = snapshot.short_id();
        let label = format!("Snapshot {short_id}");
        let summary = snapshot.summary.clone();
        let timestamp_line = Some(snapshot.captured_at.format("%Y-%m-%d %H:%M:%S").to_string());
        let relative_time = snapshot
            .age_from(Local::now())
            .map(|age| format!("captured {} ago", format_duration(age)));
        let (user_delta, assistant_delta) = self.conversation_delta_since(&snapshot.conversation);
        let stats_line = if user_delta == 0 && assistant_delta == 0 {
            Some("conversation already matches current state".to_string())
        } else if assistant_delta == 0 {
            Some(format!(
                "rewind {} user turn{}",
                user_delta,
                if user_delta == 1 { "" } else { "s" }
            ))
        } else {
            Some(format!(
                "rewind {} user turn{} and {} assistant repl{}",
                user_delta,
                if user_delta == 1 { "" } else { "s" },
                assistant_delta,
                if assistant_delta == 1 { "y" } else { "ies" }
            ))
        };

        let conversation_lines = Self::conversation_preview_lines_from_snapshot(&snapshot.history);
        let file_lines = self.timeline_file_lines_for_commit(snapshot.commit().id());

        UndoTimelineEntry {
            label,
            summary,
            timestamp_line,
            relative_time,
            stats_line,
            commit_line: Some(format!("commit {short_id}")),
            conversation_lines,
            file_lines,
            conversation_available: user_delta > 0,
            files_available: true,
            kind: UndoTimelineEntryKind::Snapshot {
                commit: snapshot.commit().id().to_string(),
            },
        }
    }

    fn timeline_entry_for_current(&self) -> UndoTimelineEntry {
        let history_snapshot = self.history_snapshot_for_persistence();
        let conversation_lines = Self::conversation_preview_lines_from_snapshot(&history_snapshot);
        let file_lines = self.timeline_file_lines_for_current();
        UndoTimelineEntry {
            label: "Current workspace".to_string(),
            summary: None,
            timestamp_line: Some(Local::now().format("%Y-%m-%d %H:%M:%S").to_string()),
            relative_time: Some("current point".to_string()),
            stats_line: Some("Already at this point in time".to_string()),
            commit_line: None,
            conversation_lines,
            file_lines,
            conversation_available: false,
            files_available: false,
            kind: UndoTimelineEntryKind::Current,
        }
    }

    fn conversation_preview_lines_from_snapshot(snapshot: &HistorySnapshot) -> Vec<Line<'static>> {
        let mut state = HistoryState::new();
        state.restore(snapshot);
        let mut messages: Vec<(UndoPreviewRole, String)> = Vec::new();
        for record in &state.records {
            match record {
                HistoryRecord::PlainMessage(msg) => match msg.kind {
                    PlainMessageKind::User => {
                        let text = Self::message_lines_to_plain_preview(&msg.lines);
                        if !text.is_empty() {
                            messages.push((UndoPreviewRole::User, text));
                        }
                    }
                    PlainMessageKind::Assistant => {
                        let text = Self::message_lines_to_plain_preview(&msg.lines);
                        if !text.is_empty() {
                            messages.push((UndoPreviewRole::Assistant, text));
                        }
                    }
                    _ => {}
                },
                HistoryRecord::AssistantMessage(msg) => {
                    let text = Self::markdown_to_plain_preview(&msg.markdown);
                    if !text.is_empty() {
                        messages.push((UndoPreviewRole::Assistant, text));
                    }
                }
                _ => {}
            }
        }

        if messages.is_empty() {
            return vec![Line::from(Span::styled(
                "No conversation captured in this snapshot.",
                Style::default().fg(crate::colors::text_dim()),
            ))];
        }

        let len = messages.len();
        let start = len.saturating_sub(Self::MAX_UNDO_CONVERSATION_MESSAGES);
        messages[start..]
            .iter()
            .map(|(role, text)| Self::conversation_line(*role, text.as_str()))
            .collect()
    }

    fn conversation_line(role: UndoPreviewRole, text: &str) -> Line<'static> {
        let (label, color) = match role {
            UndoPreviewRole::User => ("You", crate::colors::text_bright()),
            UndoPreviewRole::Assistant => ("Code", crate::colors::primary()),
        };
        let label_span = Span::styled(
            format!("{label}: "),
            Style::default().fg(color).add_modifier(Modifier::BOLD),
        );
        let content_span = Span::styled(text.to_string(), Style::default().fg(crate::colors::text()));
        Line::from(vec![label_span, content_span])
    }

    fn message_lines_to_plain_preview(lines: &[MessageLine]) -> String {
        let mut segments: Vec<String> = Vec::new();
        for line in lines {
            match line.kind {
                MessageLineKind::Blank => continue,
                MessageLineKind::Metadata => continue,
                _ => {
                    let mut text = String::new();
                    for span in &line.spans {
                        text.push_str(&span.text);
                    }
                    let trimmed = text.trim();
                    if !trimmed.is_empty() {
                        segments.push(trimmed.to_string());
                    }
                }
            }
            if segments.len() >= Self::MAX_UNDO_CONVERSATION_MESSAGES {
                break;
            }
        }
        let joined = segments.join(" ");
        Self::truncate_preview_text(joined, Self::MAX_UNDO_PREVIEW_CHARS)
    }

    fn markdown_to_plain_preview(markdown: &str) -> String {
        let mut segments: Vec<String> = Vec::new();
        for line in markdown.lines() {
            let trimmed = line.trim();
            if trimmed.is_empty() {
                continue;
            }
            if trimmed.starts_with('#') {
                segments.push(trimmed.trim_start_matches('#').trim().to_string());
            } else {
                segments.push(trimmed.to_string());
            }
            if segments.len() >= Self::MAX_UNDO_CONVERSATION_MESSAGES {
                break;
            }
        }
        if segments.is_empty() {
            return String::new();
        }
        let joined = segments.join(" ");
        Self::truncate_preview_text(joined, Self::MAX_UNDO_PREVIEW_CHARS)
    }

    fn truncate_preview_text(text: String, limit: usize) -> String {
        if text.chars().count() <= limit {
            return text;
        }
        let truncated: String = text.chars().take(limit.saturating_sub(1)).collect();
        format!("{truncated}…")
    }

    fn timeline_file_lines_for_commit(&self, commit_id: &str) -> Vec<Line<'static>> {
        match self.git_numstat(["show", "--numstat", "--format=", commit_id]) {
            Ok(entries) => Self::file_change_lines(entries),
            Err(err) => vec![Line::from(Span::styled(
                err,
                Style::default().fg(crate::colors::error()),
            ))],
        }
    }

    fn timeline_file_lines_for_current(&self) -> Vec<Line<'static>> {
        match self.git_numstat(["diff", "--numstat", "HEAD"]) {
            Ok(entries) => {
                if entries.is_empty() {
                    vec![Line::from(Span::styled(
                        "Working tree clean",
                        Style::default().fg(crate::colors::text_dim()),
                    ))]
                } else {
                    Self::file_change_lines(entries)
                }
            }
            Err(err) => vec![Line::from(Span::styled(
                err,
                Style::default().fg(crate::colors::error()),
            ))],
        }
    }

    fn git_numstat<I, S>(
        &self,
        args: I,
    ) -> Result<Vec<(Option<u32>, Option<u32>, String)>, String>
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
    {
        self.run_git_command(args, |stdout| {
            let mut out = Vec::new();
            for line in stdout.lines() {
                let trimmed = line.trim();
                if trimmed.is_empty() {
                    continue;
                }
                let mut parts = trimmed.splitn(3, '\t');
                let added = parts.next();
                let removed = parts.next();
                let path = parts.next();
                if let (Some(added), Some(removed), Some(path)) = (added, removed, path) {
                    out.push((
                        Self::parse_numstat_count(added),
                        Self::parse_numstat_count(removed),
                        path.to_string(),
                    ));
                }
            }
            Ok(out)
        })
    }

    fn run_git_command<I, S, F, T>(&self, args: I, parser: F) -> Result<T, String>
    where
        I: IntoIterator<Item = S>,
        S: AsRef<str>,
        F: FnOnce(String) -> Result<T, String>,
    {
        let args_vec: Vec<String> = args.into_iter().map(|s| s.as_ref().to_string()).collect();
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(&args_vec)
            .output()
            .map_err(|err| format!("git {} failed: {err}", args_vec.join(" ")))?;
        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            let msg = stderr.trim();
            if msg.is_empty() {
                Err(format!(
                    "git {} exited with status {}",
                    args_vec.join(" "),
                    output.status
                ))
            } else {
                Err(msg.to_string())
            }
        } else {
            if args_vec
                .iter()
                .any(|arg| matches!(arg.as_str(), "pull" | "checkout" | "merge" | "apply"))
            {
                bump_snapshot_epoch_for(&self.config.cwd);
            }
            parser(String::from_utf8_lossy(&output.stdout).to_string())
        }
    }

    fn parse_numstat_count(raw: &str) -> Option<u32> {
        if raw == "-" {
            None
        } else {
            raw.parse::<u32>().ok()
        }
    }

    fn file_change_lines(entries: Vec<(Option<u32>, Option<u32>, String)>) -> Vec<Line<'static>> {
        if entries.is_empty() {
            return vec![Line::from(Span::styled(
                "No file changes recorded for this snapshot.",
                Style::default().fg(crate::colors::text_dim()),
            ))];
        }

        let max_entries = (Self::MAX_UNDO_FILE_LINES / 2).max(1);
        let mut lines: Vec<Line<'static>> = Vec::new();
        for (idx, (added, removed, path)) in entries.iter().enumerate() {
            if idx >= max_entries {
                break;
            }
            lines.push(Line::from(Span::styled(
                path.clone(),
                Style::default().fg(crate::colors::text()),
            )));

            let added_text = added.map_or("-".to_string(), |v| v.to_string());
            let removed_text = removed.map_or("-".to_string(), |v| v.to_string());
            lines.push(Line::from(vec![
                Span::raw("    "),
                Span::styled(
                    format!("+{added_text}"),
                    Style::default().fg(crate::colors::success()),
                ),
                Span::raw("  "),
                Span::styled(
                    format!("-{removed_text}"),
                    Style::default().fg(crate::colors::error()),
                ),
            ]));
        }

        if entries.len() > max_entries {
            let remaining = entries.len() - max_entries;
            lines.push(Line::from(Span::styled(
                format!("… and {remaining} more file{}", if remaining == 1 { "" } else { "s" }),
                Style::default().fg(crate::colors::text_dim()),
            )));
        }

        lines
    }

    fn reset_resume_order_anchor(&mut self) {
        if self.history_cells.is_empty() {
            self.resume_expected_next_request = None;
        } else {
            let max_req = self
                .cell_order_seq
                .iter()
                .map(|key| key.req)
                .max()
                .unwrap_or(0);
            self.resume_expected_next_request = Some(max_req.saturating_add(1));
        }
        self.order_request_bias = 0;
        self.resume_provider_baseline = None;
    }

    pub(crate) fn restore_history_snapshot(&mut self, snapshot: &HistorySnapshot) {
        let perf_timer = self.perf_state.enabled.then(Instant::now);
        let preserved_system_entries: Vec<(String, HistoryId)> = self
            .system_cell_by_id
            .iter()
            .filter_map(|(key, &idx)| {
                self.history_cell_ids
                    .get(idx)
                    .and_then(|maybe| maybe.map(|hid| (key.clone(), hid)))
            })
            .collect();
        self.history_debug(format!(
            "restore_history_snapshot.start records={} cells_before={} order_before={}",
            snapshot.records.len(),
            self.history_cells.len(),
            self.cell_order_seq.len()
        ));
        self.history_state.restore(snapshot);

        self.history_render.invalidate_all();
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);

        self.history_cells.clear();
        self.history_cell_ids.clear();
        self.history_live_window = None;
        self.history_frozen_width = 0;
        self.history_frozen_count = 0;
        self.history_virtualization_sync_pending.set(false);
        self.cell_order_seq.clear();
        self.cell_order_dbg.clear();

        for record in &self.history_state.records {
            if let Some(mut cell) = self.build_cell_from_record(record) {
                let id = record.id();
                Self::assign_history_id_inner(&mut cell, id);
                self.history_cells.push(cell);
                self.history_cell_ids.push(Some(id));
            } else {
                tracing::warn!("unable to rebuild history cell for record id {:?}", record.id());
                let fallback = history_cell::new_background_event(format!(
                    "Restored snapshot missing renderer for record {:?}",
                    record.id()
                ));
                self.history_cells.push(Box::new(fallback));
                self.history_cell_ids.push(None);
            }
        }

        if !snapshot.order.is_empty() {
            self.cell_order_seq = snapshot
                .order
                .iter()
                .copied()
                .map(OrderKey::from)
                .collect();
        } else {
            self.cell_order_seq = self
                .history_cells
                .iter()
                .enumerate()
                .map(|(idx, _)| OrderKey {
                    req: (idx as u64).saturating_add(1),
                    out: i32::MAX,
                    seq: (idx as u64).saturating_add(1),
                })
                .collect();
        }

        if self.cell_order_seq.len() < self.history_cells.len() {
            let mut next_req = self
                .cell_order_seq
                .iter()
                .map(|key| key.req)
                .max()
                .unwrap_or(0);
            let mut next_seq = self
                .cell_order_seq
                .iter()
                .map(|key| key.seq)
                .max()
                .unwrap_or(0)
                .saturating_add(1);
            while self.cell_order_seq.len() < self.history_cells.len() {
                next_req = next_req.saturating_add(1);
                self.cell_order_seq.push(OrderKey {
                    req: next_req,
                    out: i32::MAX,
                    seq: next_seq,
                });
                next_seq = next_seq.saturating_add(1);
            }
        }

        if !snapshot.order_debug.is_empty() {
            self.cell_order_dbg = snapshot.order_debug.clone();
        }
        if self.cell_order_dbg.len() < self.history_cells.len() {
            self.cell_order_dbg
                .resize(self.history_cells.len(), None);
        }

        let max_req = self.cell_order_seq.iter().map(|key| key.req).max().unwrap_or(0);
        let max_seq = self.cell_order_seq.iter().map(|key| key.seq).max().unwrap_or(0);

        self.last_seen_request_index = max_req;
        self.current_request_index = max_req;
        self.internal_seq = max_seq;
        self.last_assigned_order = self.cell_order_seq.iter().copied().max();
        self.reset_resume_order_anchor();

        self.rebuild_ui_background_seq_counters();

        running_tools::rehydrate(self);
        self.rehydrate_system_order_cache(&preserved_system_entries);

        self.bottom_pane
            .set_has_chat_history(!self.history_cells.is_empty());
        self.refresh_reasoning_collapsed_visibility();
        self.refresh_explore_trailing_flags();
        self.invalidate_height_cache();
        self.request_redraw();

        if let (true, Some(started)) = (self.perf_state.enabled, perf_timer) {
            let elapsed = started.elapsed().as_nanos();
            self.perf_state
                .stats
                .borrow_mut()
                .record_undo_restore(elapsed);
        }
        self.history_snapshot_dirty = true;
        self.history_snapshot_last_flush = None;

        self.history_debug(format!(
            "restore_history_snapshot.done cells={} order={} system_cells={}",
            self.history_cells.len(),
            self.cell_order_seq.len(),
            self.system_cell_by_id.len()
        ));
    }

    pub(crate) fn perform_undo_restore(
        &mut self,
        commit: Option<&str>,
        restore_files: bool,
        restore_conversation: bool,
    ) {
        let Some(commit_id) = commit else {
            self.push_background_tail("No snapshot selected.".to_string());
            return;
        };

        let Some((index, snapshot)) = self
            .ghost_snapshots
            .iter()
            .enumerate()
            .find(|(_, snap)| snap.commit().id() == commit_id)
            .map(|(idx, snap)| (idx, snap.clone()))
        else {
            self.push_background_tail(
                "Selected snapshot is no longer available.".to_string(),
            );
            return;
        };

        if !restore_files && !restore_conversation {
            self.push_background_tail("No restore options selected.".to_string());
            return;
        }

        let mut files_restored = false;
        let mut conversation_rewind_requested = false;
        let mut errors: Vec<String> = Vec::new();
        let mut pre_restore_snapshot: Option<GhostSnapshot> = None;

        if restore_files {
            let previous_len = self.ghost_snapshots.len();
            let pre_summary = Some("Pre-undo checkpoint".to_string());
            let captured_snapshot = self.capture_ghost_snapshot_blocking(pre_summary);
            let added_snapshot = self.ghost_snapshots.len() > previous_len;
            if let Some(snapshot) = captured_snapshot {
                pre_restore_snapshot = Some(snapshot);
            }

            match restore_ghost_commit(&self.config.cwd, snapshot.commit()) {
                Ok(()) => {
                    files_restored = true;
                    self.ghost_snapshots.truncate(index);
                    if let Some(pre) = pre_restore_snapshot {
                        self.ghost_snapshots.push(pre);
                        if self.ghost_snapshots.len() > MAX_TRACKED_GHOST_COMMITS {
                            self.ghost_snapshots.remove(0);
                        }
                    }
                }
                Err(err) => {
                    if added_snapshot && !self.ghost_snapshots.is_empty() {
                        self.ghost_snapshots.pop();
                    }
                    errors.push(format!("Failed to restore workspace files: {err}"));
                }
            }
        }

        if restore_conversation {
            let (user_delta, assistant_delta) =
                self.conversation_delta_since(&snapshot.conversation);
            if user_delta == 0 {
                self.push_background_tail(
                    "Conversation already matches selected snapshot; nothing to rewind.".to_string(),
                );
            } else {
                self.app_event_tx.send(AppEvent::JumpBack {
                    nth: user_delta,
                    prefill: String::new(),
                    history_snapshot: Some(snapshot.history.clone()),
                });
                if assistant_delta > 0 {
                    self.push_background_tail(format!(
                        "Rewinding conversation by {} user turn{} and {} assistant repl{}",
                        user_delta,
                        if user_delta == 1 { "" } else { "s" },
                        assistant_delta,
                        if assistant_delta == 1 { "y" } else { "ies" }
                    ));
                } else {
                    self.push_background_tail(format!(
                        "Rewinding conversation by {} user turn{}",
                        user_delta,
                        if user_delta == 1 { "" } else { "s" }
                    ));
                }
                conversation_rewind_requested = true;
            }
        }

        for err in errors {
            self.history_push_plain_state(history_cell::new_error_event(err));
        }

        if files_restored {
            let mut message = format!("Restored workspace files to snapshot {}", snapshot.short_id());
            if let Some(snippet) = snapshot.summary_snippet(60) {
                message.push_str(&format!(" • {}", snippet));
            }
            if let Some(age) = snapshot.age_from(Local::now()) {
                message.push_str(&format!(" • captured {} ago", format_duration(age)));
            }
            if !restore_conversation {
                message.push_str(" • chat history unchanged");
            }
            self.push_background_tail(message);
        }

        if conversation_rewind_requested {
            // Ensure Auto Drive state does not point at the old session after a conversation rewind.
            // If we leave it active, subsequent user messages may be routed to a stale coordinator
            // handle and appear to "not go through".
            if self.auto_state.is_active() || self.auto_handle.is_some() {
                self.auto_stop(Some("Auto Drive reset after /undo restore.".to_string()));
                self.auto_handle = None;
                self.auto_history.clear();
            }

            // Conversation rewind will reload the chat widget via AppEvent::JumpBack.
            self.reset_after_conversation_restore();
        } else {
            // Even when only files are restored, clear any pending user prompts or transient state
            // so subsequent messages flow normally.
            self.reset_after_conversation_restore();
        }

        self.request_redraw();
    }

    fn reset_after_conversation_restore(&mut self) {
        self.pending_dispatched_user_messages.clear();
        self.pending_user_prompts_for_next_turn = 0;
        self.queued_user_messages.clear();
        self.refresh_queued_user_messages(false);
        self.bottom_pane.clear_composer();
        self.bottom_pane.clear_ctrl_c_quit_hint();
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_task_running(false);
        self.active_task_ids.clear();
        if !self.agents_terminal.active {
            self.bottom_pane.ensure_input_focus();
        }
    }

    fn flush_pending_agent_notes(&mut self) {
        for note in self.pending_agent_notes.drain(..) {
            if let Err(e) = self.code_op_tx.send(Op::AddToHistory { text: note }) {
                tracing::error!("failed to send AddToHistory op: {e}");
            }
        }
    }

    fn finalize_sent_user_message(&mut self, message: UserMessage) {
        let UserMessage {
            display_text,
            ordered_items,
            suppress_persistence,
        } = message;

        let combined_message_text = {
            let mut buffer = String::new();
            for item in &ordered_items {
                if let InputItem::Text { text } = item {
                    if !buffer.is_empty() {
                        buffer.push('\n');
                    }
                    buffer.push_str(text);
                }
            }
            let trimmed = buffer.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        };

        if !display_text.is_empty() {
            let key = self.next_req_key_prompt();
            let state = history_cell::new_user_prompt(display_text.clone());
            let _ = self.history_insert_plain_state_with_key(state, key, "prompt");
            self.pending_user_prompts_for_next_turn =
                self.pending_user_prompts_for_next_turn.saturating_add(1);
        }

        self.flush_pending_agent_notes();

        if let Some(model_echo) = combined_message_text {
            self.pending_dispatched_user_messages.push_back(model_echo);
        }

        let suppress_history = suppress_persistence;

        if !display_text.is_empty() && !suppress_history {
            if let Err(e) = self
                .code_op_tx
                .send(Op::AddToHistory { text: display_text })
            {
                tracing::error!("failed to send AddHistory op: {e}");
            }
        }

        if self.auto_state.is_active() && self.auto_state.resume_after_submit() {
            self.auto_state.on_prompt_submitted();
            self.auto_state.seconds_remaining = 0;
            self.auto_rebuild_live_ring();
            self.bottom_pane.update_status_text(String::new());
            self.bottom_pane.set_task_running(false);
        }

        self.request_redraw();
    }

    fn refresh_queued_user_messages(&mut self, schedule_watchdog: bool) {
        let mut scheduled_watchdog = false;
        if self.queued_user_messages.is_empty() {
            self.queue_block_started_at = None;
        } else if schedule_watchdog {
            if self.queue_block_started_at.is_none() {
                self.queue_block_started_at = Some(Instant::now());
                scheduled_watchdog = true;
            }
        }

        if scheduled_watchdog {
            let tx = self.app_event_tx.clone();
            // Fire a CommitTick after ~10s to ensure the watchdog runs even when
            // no streaming/animation is active.
            if thread_spawner::spawn_lightweight("queue-watchdog", move || {
                std::thread::sleep(Duration::from_secs(10));
                tx.send(crate::app_event::AppEvent::CommitTick);
            })
            .is_none()
            {
                // If we cannot spawn another lightweight thread (e.g., thread cap reached),
                // fall back to a non-threaded timer using tokio when available, or a best-effort
                // regular thread; as a last resort mark the timer expired and send immediately so
                // the queue cannot remain blocked.
                if let Ok(handle) = tokio::runtime::Handle::try_current() {
                    let tx = self.app_event_tx.clone();
                    handle.spawn(async move {
                        tokio::time::sleep(Duration::from_secs(10)).await;
                        let _ = tx.send(crate::app_event::AppEvent::CommitTick);
                    });
                } else {
                    let tx = self.app_event_tx.clone();
                    if std::thread::Builder::new()
                        .name("queue-watchdog-fallback".to_string())
                        .spawn(move || {
                            std::thread::sleep(Duration::from_secs(10));
                            let _ = tx.send(crate::app_event::AppEvent::CommitTick);
                        })
                        .is_err()
                    {
                        // No way to schedule a delayed tick; force the timer to appear expired
                        // and emit a tick now to avoid indefinite blocking.
                        self.queue_block_started_at = Some(Instant::now() - Duration::from_secs(10));
                        let _ = self.app_event_tx.send(crate::app_event::AppEvent::CommitTick);
                    }
                }
            }
        }

        self.request_redraw();
    }

    #[allow(dead_code)]
    pub(crate) fn set_mouse_status_message(&mut self, message: &str) {
        self.bottom_pane.update_status_text(message.to_string());
    }

    pub(crate) fn handle_mouse_event(&mut self, mouse_event: crossterm::event::MouseEvent) {
        use crossterm::event::KeyModifiers;
        use crossterm::event::MouseEventKind;

        // Check if Shift is held - if so, let the terminal handle selection
        if mouse_event.modifiers.contains(KeyModifiers::SHIFT) {
            // Don't handle any mouse events when Shift is held
            // This allows the terminal's native text selection to work
            return;
        }

        match mouse_event.kind {
            MouseEventKind::ScrollUp => layout_scroll::mouse_scroll(self, true),
            MouseEventKind::ScrollDown => layout_scroll::mouse_scroll(self, false),
            _ => {
                // Ignore other mouse events for now
            }
        }
    }

    pub(crate) fn handle_code_event(&mut self, event: Event) {
        tracing::debug!(
            "handle_code_event({})",
            serde_json::to_string_pretty(&event).unwrap_or_default()
        );

        if self.session_id.is_none()
            && !self.test_mode
            && !matches!(&event.msg, EventMsg::SessionConfigured(_))
        {
            tracing::debug!(
                "Ignoring stale event {:?} (seq={}) while waiting for SessionConfigured",
                &event.msg,
                event.event_seq
            );
            return;
        }
        // Strict ordering: all LLM/tool events must carry OrderMeta; internal events use synthetic keys.
        // Track provider order to anchor internal inserts at the bottom of the active request.
        self.note_order(event.order.as_ref());

        let Event { id, msg, .. } = event.clone();
        match msg {
            EventMsg::EnvironmentContextFull(ev) => {
                self.handle_environment_context_full_event(&ev);
            }
            EventMsg::EnvironmentContextDelta(ev) => {
                self.handle_environment_context_delta_event(&ev);
            }
            EventMsg::BrowserSnapshot(ev) => {
                self.handle_browser_snapshot_event(&ev);
            }
            EventMsg::CompactionCheckpointWarning(event) => {
                self.history_push_plain_paragraphs(PlainMessageKind::Notice, [event.message]);
            }
            EventMsg::SessionConfigured(event) => {
                // Remove stale "Connecting MCP servers…" status from the startup notice
                // now that MCP initialization has completed in core.
                self.remove_connecting_mcp_notice();
                // Record session id for potential future fork/backtrack features
                self.session_id = Some(event.session_id);
                self.bottom_pane
                    .set_history_metadata(event.history_log_id, event.history_entry_count);
                // Record session information at the top of the conversation.
                // If we already showed the startup prelude (Popular commands),
                // avoid inserting a duplicate. Still surface a notice if the
                // model actually changed from the requested one.
                let is_first = !self.welcome_shown;
                let should_insert_session_info =
                    (!self.test_mode && is_first) || self.config.model != event.model;
                if should_insert_session_info {
                    if is_first {
                        self.welcome_shown = true;
                    }
                    let session_state = history_cell::new_session_info(
                        &self.config,
                        event.clone(),
                        is_first,
                        self.latest_upgrade_version.as_deref(),
                    );
                    let key = self.next_req_key_top();
                    let _ = self
                        .history_insert_plain_state_with_key(session_state, key, "prelude");
                }

                if let Some(user_message) = self.initial_user_message.take() {
                    // If the user provided an initial message, add it to the
                    // conversation history.
                    self.submit_user_message(user_message);
                }

                // Ask core for custom prompts so the slash menu can show them.
                self.submit_op(Op::ListCustomPrompts);
                self.submit_op(Op::ListSkills);

                if self.resume_placeholder_visible && event.history_entry_count == 0 {
                    self.replace_resume_placeholder_with_notice(RESUME_NO_HISTORY_NOTICE);
                }

                self.request_redraw();
                self.flush_history_snapshot_if_needed(true);
            }
            EventMsg::WebSearchBegin(ev) => {
                self.ensure_spinner_for_activity("web-search-begin");
                // Enforce order presence (tool events should carry it)
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on WebSearchBegin; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] WebSearchBegin call_id={} seq={}",
                    ev.call_id,
                    event.event_seq
                );
                tools::web_search_begin(self, ev.call_id, ev.query, event.order.as_ref(), ok)
            }
            EventMsg::AgentMessage(AgentMessageEvent { message }) => {
                // If the user requested an interrupt, ignore late final answers.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentMessage after interrupt");
                    self.stop_spinner();
                    return;
                }

                // Allow a fresh lingering-exec sweep even if the per-turn guard
                // was tripped before any commands started.
                self.cleared_lingering_execs_this_turn = false;
                self.ensure_lingering_execs_cleared();

                self.stream_state.seq_answer_final = Some(event.event_seq);
                if !id.trim().is_empty() {
                    self.note_answer_stream_seen(&id);
                    // Any Answer item that completes before TaskComplete is considered
                    // mid‑turn until we later determine it was the final Answer.
                    if !self.active_task_ids.is_empty() {
                        self.mid_turn_answer_ids_in_turn.insert(id.clone());
                    }
                }
                // Strict order for the stream id
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on AgentMessage; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Answer, &id, ok);

                tracing::debug!(
                    "AgentMessage final id={} bytes={} preview={:?}",
                    id,
                    message.len(),
                    message.chars().take(80).collect::<String>()
                );

                // Route final message through streaming controller so AppEvent::InsertFinalAnswer
                // is the single source of truth for assistant content.
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Answer, Some(id.clone()));
                let _ = self.stream.apply_final_answer(&message, &sink);

                // Track last message for potential dedup heuristics.
                let cleaned = Self::strip_context_sections(&message);
                self.last_assistant_message = (!cleaned.trim().is_empty()).then_some(cleaned);
                // Mark this Answer stream id as closed for the rest of the turn so any late
                // AgentMessageDelta for the same id is ignored. In the full App runtime,
                // the InsertFinalAnswer path also marks closed; setting it here makes
                // unit tests (which do not route AppEvents back) behave identically.
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(id.clone()));
                // Do not quiesce the global spinner here. `AgentMessage` is emitted for every
                // completed assistant output item, and modern models may send multiple assistant
                // messages mid-turn (progress updates, tool interleavings, etc.). We only clear
                // the turn spinner on `TaskComplete` or when all other activity drains.
                // Important: do not advance Auto Drive here. The StreamController will emit
                // AppEvent::InsertFinalAnswer, and the App thread will finalize the assistant
                // cell slightly later. Advancing at this point can start the next Auto Drive
                // step before the final answer is actually inserted, which appears as a
                // mid-turn re-trigger. We instead advance immediately after insertion inside
                // insert_final_answer_with_id().
            }
            EventMsg::ReplayHistory(ev) => {
                self.clear_resume_placeholder();
                let code_core::protocol::ReplayHistoryEvent { items, history_snapshot } = ev;
                self.replay_history_depth = self.replay_history_depth.saturating_add(1);
                let max_req = self.last_seen_request_index;
                let mut processed_snapshot = false;
                if let Some(snapshot_value) = history_snapshot {
                    match serde_json::from_value::<HistorySnapshot>(snapshot_value) {
                        Ok(snapshot) => {
                            self.restore_history_snapshot(&snapshot);
                            self.flush_history_snapshot_if_needed(true);
                            processed_snapshot = true;
                        }
                        Err(err) => {
                            tracing::warn!("failed to deserialize replay snapshot: {err}");
                        }
                    }
                }
                if !processed_snapshot {
                    for item in &items {
                        self.render_replay_item(item.clone());
                    }
                    if !items.is_empty() {
                        self.last_seen_request_index =
                            self.last_seen_request_index.max(self.current_request_index);
                    }
                }
                if max_req > 0 {
                    self.last_seen_request_index = self.last_seen_request_index.max(max_req);
                    self.current_request_index = self.last_seen_request_index;
                }
                if processed_snapshot || !items.is_empty() {
                    self.reset_resume_order_anchor();
                }
                self.request_redraw();
                self.replay_history_depth = self.replay_history_depth.saturating_sub(1);
            }
            EventMsg::WebSearchComplete(ev) => {
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on WebSearchComplete; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tools::web_search_complete(self, ev.call_id, ev.query, event.order.as_ref(), ok)
            }
            EventMsg::AgentMessageDelta(AgentMessageDeltaEvent { delta }) => {
                tracing::debug!("AgentMessageDelta: {:?}", delta);
                // If the user requested an interrupt, ignore late deltas.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring Answer delta after interrupt");
                    self.stop_spinner();
                    return;
                }

                self.ensure_lingering_execs_cleared();

                if self.strict_stream_ids_enabled() && id.trim().is_empty() {
                    self.warn_missing_stream_id("assistant answer delta");
                    return;
                }
                // Ignore late deltas for ids that have already finalized in this turn
                if self
                    .stream_state
                    .closed_answer_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring Answer delta for closed id={}", id);
                    return;
                }
                self.note_answer_stream_seen(&id);
                // Seed/refresh order key for this Answer stream id (must have OrderMeta)
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on AgentMessageDelta; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Answer, &id, ok);
                // Stream answer delta through StreamController
                streaming::delta_text(
                    self,
                    StreamKind::Answer,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
                self.ensure_spinner_for_activity("assistant-delta");
                // Show responding state while assistant streams
                self.bottom_pane
                    .update_status_text("responding".to_string());
            }
            EventMsg::AgentReasoning(AgentReasoningEvent { text }) => {
                // Ignore late reasoning if we've dropped streaming due to interrupt.
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentReasoning after interrupt");
                    self.stop_spinner();
                    return;
                }
                tracing::debug!(
                    "AgentReasoning event with text: {:?}...",
                    text.chars().take(100).collect::<String>()
                );
                // Guard duplicates for this id within the task
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::warn!("Ignoring duplicate AgentReasoning for closed id={}", id);
                    return;
                }
                // Seed strict order key for this Reasoning stream
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on AgentReasoning; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!("[order] EventMsg::AgentReasoning id={} key={:?}", id, ok);
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                // Use StreamController for final reasoning
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Reasoning, Some(id.clone()));

                // The StreamController now properly handles duplicate detection and prevents
                // re-injecting content when we're already finishing a stream
                let _finished = self.stream.apply_final_reasoning(&text, &sink);
                // Stream finishing is handled by StreamController
                // Mark this id closed for further reasoning deltas in this turn
                self.stream_state
                    .closed_reasoning_ids
                    .insert(StreamId(id.clone()));
                // Clear in-progress flags on the most recent reasoning cell(s)
                if let Some(last) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                }) {
                    if let Some(reason) = self.history_cells[last]
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    {
                        reason.set_in_progress(false);
                    }
                }
                self.mark_needs_redraw();
            }
            EventMsg::AgentReasoningDelta(AgentReasoningDeltaEvent { delta }) => {
                tracing::debug!("AgentReasoningDelta: {:?}", delta);
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring Reasoning delta after interrupt");
                    self.stop_spinner();
                    return;
                }
                if self.strict_stream_ids_enabled() && id.trim().is_empty() {
                    self.warn_missing_stream_id("assistant reasoning delta");
                    return;
                }
                // Ignore late deltas for ids that have already finalized in this turn
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring Reasoning delta for closed id={}", id);
                    return;
                }
                // Seed strict order key for this Reasoning stream
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on AgentReasoningDelta; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] EventMsg::AgentReasoningDelta id={} key={:?}",
                    id,
                    ok
                );
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                streaming::delta_text(
                    self,
                    StreamKind::Reasoning,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
                self.ensure_spinner_for_activity("reasoning-delta");
                // Show thinking state while reasoning streams
                self.bottom_pane.update_status_text("thinking".to_string());
            }
            EventMsg::AgentReasoningSectionBreak(AgentReasoningSectionBreakEvent {}) => {
                // Insert section break in reasoning stream
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                self.stream.insert_reasoning_section_break(&sink);
            }
            EventMsg::TaskStarted => {
                // Defensive: if the previous turn never emitted TaskComplete (e.g. dropped event
                // due to reconnect), `active_task_ids` can stay non-empty. That makes every
                // subsequent Answer look like "mid-turn" forever and keeps the footer spinner
                // stuck.
                if let Some(last_id) = self.last_seen_answer_stream_id_in_turn.clone() {
                    if self.mid_turn_answer_ids_in_turn.contains(&last_id)
                        || !self.active_task_ids.is_empty()
                    {
                        self.mid_turn_answer_ids_in_turn.remove(&last_id);
                        self.maybe_clear_mid_turn_for_last_answer(&last_id);
                    }
                }
                if !self.active_task_ids.is_empty() {
                    tracing::warn!(
                        "TaskStarted id={} while {} task(s) still active; assuming stale turn state",
                        id,
                        self.active_task_ids.len()
                    );
                    self.active_task_ids.clear();
                }
                // Reset per-turn cleanup guard and clear any lingering running
                // exec/tool cells if the prior turn never sent TaskComplete.
                // This runs once per turn and is intentionally later than
                // ToolEnd to avoid the earlier regression where we finalized
                // after every tool call.
                self.turn_sequence = self.turn_sequence.saturating_add(1);
                self.turn_had_code_edits = false;
                self.current_turn_origin = self.pending_turn_origin.take();
                self.cleared_lingering_execs_this_turn = false;
                self.ensure_lingering_execs_cleared();

                self.clear_reconnecting();
                // This begins the new turn; clear the pending prompt anchor count
                // so subsequent background events use standard placement.
                self.pending_user_prompts_for_next_turn = 0;
                // Reset stream headers for new turn
                self.stream.reset_headers_for_new_turn();
                self.stream_state.current_kind = None;
                self.stream_state.seq_answer_final = None;
                self.last_answer_stream_id_in_turn = None;
                self.last_answer_history_id_in_turn = None;
                self.last_seen_answer_stream_id_in_turn = None;
                self.mid_turn_answer_ids_in_turn.clear();
                // New turn: clear closed id guards
                self.stream_state.closed_answer_ids.clear();
                self.stream_state.closed_reasoning_ids.clear();
                self.ended_call_ids.clear();
                self.bottom_pane.clear_ctrl_c_quit_hint();
                // Accept streaming again for this turn
                self.stream_state.drop_streaming = false;
                // Mark this task id as active and ensure the status stays visible
                self.active_task_ids.insert(id.clone());
                // Reset per-turn UI indicators; ordering is now global-only
                self.reasoning_index.clear();
                self.bottom_pane.set_task_running(true);
                self.bottom_pane
                    .update_status_text("waiting for model".to_string());
                self.ensure_spinner_for_activity("task-started");
                tracing::info!("[order] EventMsg::TaskStarted id={}", id);

                // Capture a baseline snapshot for this turn so background auto review only
                // covers changes made during the turn, not pre-existing local edits.
                self.auto_review_baseline = None;
                if self.config.tui.auto_review_enabled {
                    self.spawn_auto_review_baseline_capture();
                }

                // Don't add loading cell - we have progress in the input area
                // self.add_to_history(history_cell::new_loading_cell("waiting for model".to_string()));

                self.mark_needs_redraw();
            }
            EventMsg::TaskComplete(TaskCompleteEvent { last_agent_message }) => {
                self.clear_reconnecting();
                let had_running_execs = !self.exec.running_commands.is_empty();
                // Finalize any active streams
                let finalizing_streams = self.stream.is_write_cycle_active();
                if finalizing_streams {
                    // Finalize both streams via streaming facade
                    streaming::finalize(self, StreamKind::Reasoning, true);
                    streaming::finalize(self, StreamKind::Answer, true);
                }
                // Remove this id from the active set (it may be a sub‑agent)
                self.active_task_ids.remove(&id);
                if !finalizing_streams && self.active_task_ids.is_empty() {
                    if let Some(last_id) = self.last_seen_answer_stream_id_in_turn.clone() {
                        self.mid_turn_answer_ids_in_turn.remove(&last_id);
                        self.maybe_clear_mid_turn_for_last_answer(&last_id);
                    }
                }
                if self.auto_resolve_enabled() {
                    self.auto_resolve_on_task_complete(last_agent_message.clone());
                }
                // Defensive: mark any lingering agent state as complete so the spinner can quiesce
                self.finalize_agent_activity();
                // Convert any lingering running exec/tool cells to completed so the UI doesn't hang
                self.finalize_all_running_due_to_answer();
                // Mark any running web searches as completed
                web_search_sessions::finalize_all_failed(
                    self,
                    "Search cancelled before completion",
                );
                if had_running_execs {
                    self.insert_background_event_with_placement(
                        "Running commands finalized after turn end.".to_string(),
                        BackgroundPlacement::Tail,
                        event.order.clone(),
                    );
                }
                // Now that streaming is complete, flush any queued interrupts
        self.flush_interrupt_queue();

        // Only drop the working status if nothing is actually running.
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
                let any_streaming = self.stream.is_write_cycle_active();
                let any_agents_active = self.agents_are_actively_running();
                let any_tasks_active = !self.active_task_ids.is_empty();

                if !(any_tools_running || any_streaming || any_agents_active || any_tasks_active) {
                    self.bottom_pane.set_task_running(false);
                    // Ensure any transient footer text like "responding" is cleared when truly idle
                    self.bottom_pane.update_status_text(String::new());
                }
                self.stream_state.current_kind = None;
                // Final re-check for idle state
                self.maybe_hide_spinner();
                self.maybe_trigger_auto_review();
                self.emit_turn_complete_notification(last_agent_message);
                self.suppress_next_agent_hint = false;
                self.mark_needs_redraw();
                self.flush_history_snapshot_if_needed(true);

            }
            EventMsg::AgentReasoningRawContentDelta(AgentReasoningRawContentDeltaEvent {
                delta,
            }) => {
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring RawContent delta after interrupt");
                    self.stop_spinner();
                    return;
                }
                if self.strict_stream_ids_enabled() && id.trim().is_empty() {
                    self.warn_missing_stream_id("assistant raw reasoning delta");
                    return;
                }
                // Treat raw reasoning content the same as summarized reasoning
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::debug!("Ignoring RawContent delta for closed id={}", id);
                    return;
                }
                // Seed strict order key for this reasoning stream id
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on Tools::PlanUpdate; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);

                streaming::delta_text(
                    self,
                    StreamKind::Reasoning,
                    id.clone(),
                    delta,
                    event.order.as_ref().and_then(|o| o.sequence_number),
                );
            }
            EventMsg::AgentReasoningRawContent(AgentReasoningRawContentEvent { text }) => {
                if self.stream_state.drop_streaming {
                    tracing::debug!("Ignoring AgentReasoningRawContent after interrupt");
                    self.stop_spinner();
                    return;
                }
                tracing::debug!(
                    "AgentReasoningRawContent event with text: {:?}...",
                    text.chars().take(100).collect::<String>()
                );
                if self
                    .stream_state
                    .closed_reasoning_ids
                    .contains(&StreamId(id.clone()))
                {
                    tracing::warn!(
                        "Ignoring duplicate AgentReasoningRawContent for closed id={}",
                        id
                    );
                    return;
                }
                // Seed strict order key now so upcoming insert uses the correct key.
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on Tools::ReasoningBegin; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                self.seed_stream_order_key(StreamKind::Reasoning, &id, ok);
                // Use StreamController for final raw reasoning
                let sink = AppEventHistorySink(self.app_event_tx.clone());
                streaming::begin(self, StreamKind::Reasoning, Some(id.clone()));
                let _finished = self.stream.apply_final_reasoning(&text, &sink);
                // Stream finishing is handled by StreamController
                self.stream_state
                    .closed_reasoning_ids
                    .insert(StreamId(id.clone()));
                if let Some(last) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                        .is_some()
                }) {
                    if let Some(reason) = self.history_cells[last]
                        .as_any()
                        .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    {
                        reason.set_in_progress(false);
                    }
                }
                self.mark_needs_redraw();
            }
            EventMsg::TokenCount(event) => {
                if let Some(info) = &event.info {
                    self.total_token_usage = info.total_token_usage.clone();
                    self.last_token_usage = info.last_token_usage.clone();
                }
                if let Some(snapshot) = event.rate_limits {
                    self.update_rate_limit_resets(&snapshot);
                    let warnings = self
                        .rate_limit_warnings
                        .take_warnings(snapshot.secondary_used_percent, snapshot.primary_used_percent);
                    let mut legend_entries: Vec<RateLimitLegendEntry> = Vec::new();
                    for warning in warnings {
                        if self.log_and_should_display_warning(&warning) {
                            let label = match warning.scope {
                                RateLimitWarningScope::Primary => {
                                    format!("Hourly usage ≥ {:.0}%", warning.threshold)
                                }
                                RateLimitWarningScope::Secondary => {
                                    format!("Weekly usage ≥ {:.0}%", warning.threshold)
                                }
                            };
                            legend_entries.push(RateLimitLegendEntry {
                                label,
                                description: warning.message.clone(),
                                tone: TextTone::Warning,
                            });
                        }
                    }
                    if !legend_entries.is_empty() {
                        let record = RateLimitsRecord {
                            id: HistoryId::ZERO,
                            snapshot: snapshot.clone(),
                            legend: legend_entries,
                        };
                        let cell = history_cell::RateLimitsCell::from_record(record.clone());
                        let key = self.next_internal_key();
                        let _ = self.history_insert_with_key_global_tagged(
                            Box::new(cell),
                            key,
                            "rate-limits",
                            Some(HistoryDomainRecord::RateLimits(record)),
                        );
                        self.request_redraw();
                    }

                    self.rate_limit_snapshot = Some(snapshot);
                    self.rate_limit_last_fetch_at = Some(Utc::now());
                    self.rate_limit_fetch_inflight = false;
                    self.refresh_settings_overview_rows();
                    let refresh_limits_settings = self
                        .settings
                        .overlay
                        .as_ref()
                        .map(|overlay| {
                            overlay.active_section() == SettingsSection::Limits
                                && !overlay.is_menu_active()
                        })
                        .unwrap_or(false);
                    if refresh_limits_settings {
                        self.show_limits_settings_ui();
                    }
                }
                self.bottom_pane.set_token_usage(
                    self.total_token_usage.clone(),
                    self.last_token_usage.clone(),
                    self.config.model_context_window,
                );
                self.update_stream_token_usage_metadata();
            }
            EventMsg::Error(ErrorEvent { message }) => {
                self.on_error(message);
            }
            EventMsg::PlanUpdate(update) => {
                let (plan_title, plan_active) = {
                    let title = update
                        .name
                        .as_ref()
                        .map(|s| s.trim())
                        .filter(|s| !s.is_empty())
                        .map(|s| s.to_string());
                    let total = update.plan.len();
                    let completed = update
                        .plan
                        .iter()
                        .filter(|p| matches!(p.status, StepStatus::Completed))
                        .count();
                    let active = total > 0 && completed < total;
                    (title, active)
                };
                // Insert plan updates at the time they occur. If the provider
                // supplied OrderMeta, honor it. Otherwise, derive a key within
                // the current (last-seen) request — do NOT advance to the next
                // request when a prompt is already queued, since these belong
                // to the in-flight turn.
                let key = self.near_time_key_current_req(event.order.as_ref());
                let _ = self.history_insert_with_key_global(
                    Box::new(history_cell::new_plan_update(update)),
                    key,
                );
                // If we inserted during streaming, keep the reasoning ellipsis visible.
                self.restore_reasoning_in_progress_if_streaming();
                let desired_title = if plan_active {
                    Some(plan_title.unwrap_or_else(|| "Plan".to_string()))
                } else {
                    None
                };
                self.apply_plan_terminal_title(desired_title);
            }
            EventMsg::ExecApprovalRequest(ev) => {
                let id2 = id.clone();
                let ev2 = ev.clone();
                let seq = event.event_seq;
                self.defer_or_handle(
                    move |interrupts| interrupts.push_exec_approval(seq, id, ev),
                    |this| {
                        this.finalize_active_stream();
                        this.flush_interrupt_queue();
                        this.handle_exec_approval_now(id2, ev2);
                        this.request_redraw();
                    },
                );
            }
            EventMsg::ApplyPatchApprovalRequest(ev) => {
                let id2 = id.clone();
                let ev2 = ev.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_apply_patch_approval(event.event_seq, id, ev),
                    |this| {
                        this.finalize_active_stream();
                        this.flush_interrupt_queue();
                        // Push approval UI state to bottom pane and surface the patch summary there.
                        // (Avoid inserting a duplicate summary here; handle_apply_patch_approval_now
                        // is responsible for rendering the proposed patch once.)
                        this.handle_apply_patch_approval_now(id2, ev2);
                        this.request_redraw();
                    },
                );
            }
            EventMsg::ExecCommandBegin(ev) => {
                let seq = event.event_seq;
                let om_begin = event
                    .order
                    .clone()
                    .expect("missing OrderMeta for ExecCommandBegin");
                self.handle_exec_begin_ordered(ev, om_begin, seq);
            }
            EventMsg::ExecCommandOutputDelta(ev) => {
                let call_id = ExecCallId(ev.call_id.clone());
                if self.exec.running_commands.contains_key(&call_id) {
                    self.ensure_spinner_for_activity("exec-output");
                }
                if let Some(running) = self.exec.running_commands.get_mut(&call_id) {
                    let chunk = String::from_utf8_lossy(&ev.chunk).to_string();
                    let chunk_len = chunk.len();
                    let (stdout_chunk, stderr_chunk) = match ev.stream {
                        ExecOutputStream::Stdout => {
                            let offset = running.stdout_offset;
                            running.stdout_offset = running.stdout_offset.saturating_add(chunk_len);
                            (
                                Some(crate::history::state::ExecStreamChunk {
                                    offset,
                                    content: chunk,
                                }),
                                None,
                            )
                        }
                        ExecOutputStream::Stderr => {
                            let offset = running.stderr_offset;
                            running.stderr_offset = running.stderr_offset.saturating_add(chunk_len);
                            (
                                None,
                                Some(crate::history::state::ExecStreamChunk {
                                    offset,
                                    content: chunk,
                                }),
                            )
                        }
                    };
                    let history_id = running.history_id.or_else(|| {
                        let mapped = self
                            .history_state
                            .history_id_for_exec_call(call_id.as_ref())
                            .or_else(|| {
                                running.history_index.and_then(|idx| {
                                    self.history_cell_ids
                                        .get(idx)
                                        .and_then(|slot| *slot)
                                })
                            });
                        running.history_id = mapped;
                        mapped
                    });
                    if let Some(history_id) = history_id {
                        if let Some(record_idx) = self.history_state.index_of(history_id) {
                            let mutation = self.history_state.apply_domain_event(
                                HistoryDomainEvent::UpdateExecStream {
                                    index: record_idx,
                                    stdout_chunk,
                                    stderr_chunk,
                                },
                            );
                            if let HistoryMutation::Replaced {
                                id,
                                record: HistoryRecord::Exec(exec_record),
                                ..
                            } = mutation
                            {
                                self.update_cell_from_record(id, HistoryRecord::Exec(exec_record));
                            }
                        }
                    }
                    self.invalidate_height_cache();
                    self.autoscroll_if_near_bottom();
                    self.request_redraw();
                }
            }
            EventMsg::PatchApplyBegin(PatchApplyBeginEvent {
                call_id,
                auto_approved,
                changes,
            }) => {
                let exec_call_id = ExecCallId(call_id.clone());
                self.exec.suppress_exec_end(exec_call_id);
                // Store for session diff popup (clone before moving into history)
                self.diffs.session_patch_sets.push(changes.clone());
                // Capture/adjust baselines, including rename moves
                if let Some(last) = self.diffs.session_patch_sets.last() {
                    for (src_path, chg) in last.iter() {
                        match chg {
                            code_core::protocol::FileChange::Update {
                                move_path: Some(dest_path),
                                ..
                            } => {
                                // Prefer to carry forward existing baseline from src to dest.
                                if let Some(baseline) =
                                    self.diffs.baseline_file_contents.remove(src_path)
                                {
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(dest_path.clone(), baseline);
                                } else if !self.diffs.baseline_file_contents.contains_key(dest_path)
                                {
                                    // Fallback: snapshot current contents of src (pre-apply) under dest key.
                                    let baseline =
                                        std::fs::read_to_string(src_path).unwrap_or_default();
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(dest_path.clone(), baseline);
                                }
                            }
                            _ => {
                                if !self.diffs.baseline_file_contents.contains_key(src_path) {
                                    let baseline =
                                        std::fs::read_to_string(src_path).unwrap_or_default();
                                    self.diffs
                                        .baseline_file_contents
                                        .insert(src_path.clone(), baseline);
                                }
                            }
                        }
                    }
                }
                // Enable Ctrl+D footer hint now that we have diffs to show
                self.bottom_pane.set_diffs_hint(true);
                // Strict order
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on ExecEnd flush; using synthetic key");
                        self.next_internal_key()
                    }
                };
                let cell = history_cell::new_patch_event(
                    PatchEventType::ApplyBegin { auto_approved },
                    changes,
                );
                let _ = self.history_insert_with_key_global(Box::new(cell), ok);
            }
            EventMsg::PatchApplyEnd(ev) => {
                let ev2 = ev.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_patch_end(event.event_seq, ev),
                    |this| this.handle_patch_apply_end_now(ev2),
                );
            }
            EventMsg::ExecCommandEnd(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let order_meta_end = event
                    .order
                    .clone()
                    .expect("missing OrderMeta for ExecCommandEnd");
                let om_for_send = order_meta_end.clone();
                self.defer_or_handle(
                    move |interrupts| interrupts.push_exec_end(seq, ev, Some(om_for_send)),
                    move |this| {
                        tracing::info!(
                            "[order] ExecCommandEnd call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        this.enqueue_or_handle_exec_end(ev2, order_meta_end);
                    },
                );
            }
            EventMsg::McpToolCallBegin(ev) => {
                let seq = event.event_seq;
                let order_ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on McpBegin; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.finalize_active_stream();
                tracing::info!(
                    "[order] McpToolCallBegin call_id={} seq={}",
                    ev.call_id,
                    seq
                );
                self.ensure_spinner_for_activity("mcp-begin");
                tools::mcp_begin(self, ev, order_ok);
                if self.interrupts.has_queued() {
                    self.flush_interrupt_queue();
                }
            }
            EventMsg::McpToolCallEnd(ev) => {
                let ev2 = ev.clone();
                let seq = event.event_seq;
                let order_ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on McpEnd; using synthetic key");
                        self.next_internal_key()
                    }
                };
                self.defer_or_handle(
                    move |interrupts| interrupts.push_mcp_end(seq, ev, event.order.clone()),
                    |this| {
                        tracing::info!(
                            "[order] McpToolCallEnd call_id={} seq={}",
                            ev2.call_id,
                            seq
                        );
                        tools::mcp_end(this, ev2, order_ok)
                    },
                );
            }

            EventMsg::CustomToolCallBegin(CustomToolCallBeginEvent {
                call_id,
                tool_name,
                parameters,
            }) => {
                self.ensure_spinner_for_activity("tool-begin");
                // Any custom tool invocation should fade out the welcome animation
                for cell in &self.history_cells {
                    cell.trigger_fade();
                }
                self.finalize_active_stream();
                // Flush any queued interrupts when streaming ends
                self.flush_interrupt_queue();
                // Show an active entry immediately for all custom tools so the user sees progress
                let params_json = parameters.clone();
                let params_string = params_json.clone().map(|p| p.to_string());
                if agent_runs::is_agent_tool(&tool_name) {
                    if agent_runs::handle_custom_tool_begin(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                    ) {
                        self.bottom_pane
                            .update_status_text("agents coordinating".to_string());
                        return;
                    }
                }
                if tool_name.starts_with("browser_") {
                    if browser_sessions::handle_custom_tool_begin(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                    ) {
                        self.bottom_pane
                            .update_status_text("using browser".to_string());
                        return;
                    }
                }

                if tool_name == "wait" {

                    if let Some(exec_call_id) = wait_exec_call_id_from_params(params_string.as_ref()) {
                        // Only treat this as an exec-scoped wait when the target exec is still running.
                        // Background waits (e.g., waiting on a shell call_id) also carry `call_id`.
                        if self.exec.running_commands.contains_key(&exec_call_id) {
                            self.tools_state
                                .running_wait_tools
                                .insert(ToolCallId(call_id.clone()), exec_call_id.clone());


                            let mut wait_update: Option<(
                                HistoryId,
                                Option<Duration>,
                                Vec<(String, bool)>,
                            )> = None;
                            if let Some(running) = self.exec.running_commands.get_mut(&exec_call_id) {
                                running.wait_active = true;
                                running.wait_notes.clear();
                                let history_id = running.history_id.or_else(|| {
                                    running.history_index.and_then(|idx| {
                                        self.history_cell_ids
                                            .get(idx)
                                            .and_then(|slot| *slot)
                                    })
                                });
                                running.history_id = history_id;
                                if let Some(id) = history_id {
                                    wait_update = Some((id, running.wait_total, running.wait_notes.clone()));
                                }
                            }
                            if let Some((history_id, total, notes)) = wait_update {
                                let _ = self.update_exec_wait_state_with_pairs(history_id, total, true, &notes);
                            }
                            self.bottom_pane
                                .update_status_text("waiting for command".to_string());
                            self.invalidate_height_cache();
                            self.request_redraw();
                            return;
                        }
                    }
                }

                if tool_name == "kill" {

                    if let Some(exec_call_id) = wait_exec_call_id_from_params(params_string.as_ref()) {
                        if self.exec.running_commands.contains_key(&exec_call_id) {
                            self.tools_state
                                .running_kill_tools
                                .insert(ToolCallId(call_id.clone()), exec_call_id);
                            self.bottom_pane
                                .update_status_text("cancelling command".to_string());
                            self.invalidate_height_cache();
                            self.request_redraw();
                            return;
                        }
                    }
                }
                // Animated running cell with live timer and formatted args
                let mut cell = if tool_name.starts_with("browser_") {
                    history_cell::new_running_browser_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                } else if tool_name.starts_with("agent_") {
                    history_cell::new_running_custom_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                } else {
                    history_cell::new_running_custom_tool_call(
                        tool_name.clone(),
                        params_string.clone(),
                    )
                };
                cell.state_mut().call_id = Some(call_id.clone());
                // Enforce ordering for custom tool begin
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on CustomToolCallBegin; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                let idx = self.history_insert_with_key_global(Box::new(cell), ok);
                let history_id = self
                    .history_state
                    .history_id_for_tool_call(&call_id)
                    .or_else(|| self.history_cell_ids.get(idx).and_then(|slot| *slot));
                // Track index so we can replace it on completion
                if idx < self.history_cells.len() {
                    self.tools_state
                        .running_custom_tools
                        .insert(
                            ToolCallId(call_id.clone()),
                            RunningToolEntry::new(ok, idx).with_history_id(history_id),
                        );
                }

                // Update border status based on tool
                if tool_name.starts_with("browser_") {
                    self.bottom_pane
                        .update_status_text("using browser".to_string());
                } else if agent_runs::is_agent_tool(&tool_name) {
                    self.bottom_pane
                        .update_status_text("agents coordinating".to_string());
                } else {
                    self.bottom_pane
                        .update_status_text(format!("using tool: {}", tool_name));
                }
            }
            EventMsg::CustomToolCallEnd(CustomToolCallEndEvent {
                call_id,
                tool_name,
                parameters,
                duration,
                result,
            }) => {
                let params_json = parameters.clone();
                if agent_runs::is_agent_tool(&tool_name) {
                    if agent_runs::handle_custom_tool_end(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                        duration,
                        &result,
                    ) {
                        self.bottom_pane
                            .update_status_text("responding".to_string());
                        return;
                    }
                }
                if tool_name.starts_with("browser_") {
                    if browser_sessions::handle_custom_tool_end(
                        self,
                        event.order.as_ref(),
                        &call_id,
                        &tool_name,
                        params_json.clone(),
                        duration,
                        &result,
                    ) {
                        if tool_name == "browser_close" {
                            self.bottom_pane
                                .update_status_text("responding".to_string());
                        } else {
                            self.bottom_pane
                                .update_status_text("using browser".to_string());
                        }
                        return;
                    }
                }
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!(
                            "missing OrderMeta on CustomToolCallEnd; using synthetic key"
                        );
                        self.next_internal_key()
                    }
                };
                let image_view_seen = if tool_name == "image_view" {
                    self.tools_state
                        .image_viewed_calls
                        .remove(&ToolCallId(call_id.clone()))
                } else {
                    false
                };
                let image_view_path = if tool_name == "image_view" && !image_view_seen {
                    params_json
                        .as_ref()
                        .and_then(|value| image_view_path_from_params(value, &self.config.cwd))
                } else {
                    None
                };
                tracing::info!(
                    "[order] CustomToolCallEnd call_id={} tool={} seq={}",
                    call_id,
                    tool_name,
                    event.event_seq
                );
                // Convert parameters to String if present
                let params_string = params_json.map(|p| p.to_string());
                // Determine success and content from Result
                let (success, content) = match result {
                    Ok(content) => (true, content),
                    Err(error) => (false, error),
                };
                if tool_name == "wait" {
                    if let Some(exec_call_id) = self
                        .tools_state
                        .running_wait_tools
                        .remove(&ToolCallId(call_id.clone()))
                    {
                        let trimmed = content.trim();
                        let wait_missing_job = wait_result_missing_background_job(trimmed);
                        let wait_interrupted = wait_result_interrupted(trimmed);
                        let mut wait_still_pending =
                            !success && trimmed != "Cancelled by user." && !wait_missing_job;
                        let mut exec_running = false;
                        let mut exec_completed = false;
                        let mut note_lines: Vec<(String, bool)> = Vec::new();
                        let suppress_json_notes = serde_json::from_str::<serde_json::Value>(
                            trimmed,
                        )
                        .ok()
                        .and_then(|value| {
                            value.as_object().map(|obj| {
                                obj.contains_key("output") || obj.contains_key("metadata")
                            })
                        })
                        .unwrap_or(false);
                        if !suppress_json_notes {
                            for line in content.lines() {
                                let note_text = line.trim();
                                if note_text.is_empty() {
                                    continue;
                                }
                                let is_error_note = note_text == "Cancelled by user.";
                                note_lines.push((note_text.to_string(), is_error_note));
                            }
                        }
                        let mut history_id: Option<HistoryId> = None;
                        let mut wait_total: Option<Duration> = None;
                        let mut wait_notes_snapshot: Vec<(String, bool)> = Vec::new();
                        if let Some(running) = self.exec.running_commands.get_mut(&exec_call_id) {
                            exec_running = true;
                            let base = running.wait_total.unwrap_or_default();
                            let total = base.saturating_add(duration);
                            running.wait_total = Some(total);
                            running.wait_active = wait_still_pending;
                            Self::append_wait_pairs(&mut running.wait_notes, &note_lines);
                            wait_notes_snapshot = running.wait_notes.clone();
                            wait_total = running.wait_total;
                            history_id = running.history_id.or_else(|| {
                                running.history_index.and_then(|idx| {
                                    self.history_cell_ids
                                        .get(idx)
                                        .and_then(|slot| *slot)
                                })
                            });
                            running.history_id = history_id;
                        } else {
                            Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                        }

                        if history_id.is_none() {
                            if let Some((idx, _)) = self.history_cells.iter().enumerate().rev().find(|(_, cell)| {
                                cell.as_any()
                                    .downcast_ref::<history_cell::ExecCell>()
                                    .is_some()
                            }) {
                                if let Some(id) = self.history_cell_ids.get(idx).and_then(|slot| *slot) {
                                    history_id = Some(id);
                                    if let Some(running) =
                                        self.exec.running_commands.get_mut(&exec_call_id)
                                    {
                                        running.history_index = Some(idx);
                                        running.history_id = Some(id);
                                    }
                                }
                            }
                        }

                        if let Some(id) = history_id {
                            let exec_record = self
                                .history_state
                                .index_of(id)
                                .and_then(|idx| self.history_state.get(idx).cloned());
                            if let Some(HistoryRecord::Exec(record)) = exec_record {
                                exec_completed = !matches!(record.status, ExecStatus::Running);
                                if wait_total.is_none() {
                                    let base = record.wait_total.unwrap_or_default();
                                    wait_total = Some(base.saturating_add(duration));
                                }
                                if wait_notes_snapshot.is_empty() {
                                    wait_notes_snapshot =
                                        Self::wait_pairs_from_exec_notes(&record.wait_notes);
                                    Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                                }
                            } else {
                                if wait_total.is_none() {
                                    wait_total = Some(duration);
                                }
                                if wait_notes_snapshot.is_empty() {
                                    Self::append_wait_pairs(&mut wait_notes_snapshot, &note_lines);
                                }
                            }
                            if exec_completed {
                                wait_still_pending = false;
                            } else if wait_interrupted && !exec_running {
                                wait_still_pending = false;
                            }

                            if !exec_completed {
                                let _ = self.update_exec_wait_state_with_pairs(
                                    id,
                                    wait_total,
                                    wait_still_pending,
                                    &wait_notes_snapshot,
                                );
                            }
                        }

                        if exec_completed {
                            self.bottom_pane
                                .update_status_text("responding".to_string());
                            self.maybe_hide_spinner();
                            self.invalidate_height_cache();
                            self.request_redraw();
                            return;
                        }

                        if success {
                            self.remove_background_completion_message(&call_id);
                            self.bottom_pane
                                .update_status_text("responding".to_string());
                            self.maybe_hide_spinner();
                        } else if trimmed == "Cancelled by user." {
                            self.bottom_pane
                                .update_status_text("wait cancelled".to_string());
                        } else if wait_missing_job || (wait_interrupted && !exec_running) {
                            let finalized = exec_tools::finalize_wait_missing_exec(
                                self,
                                exec_call_id.clone(),
                                trimmed,
                            );
                            if finalized {
                                self.bottom_pane.update_status_text(
                                    "command finished (output unavailable)".to_string(),
                                );
                            } else {
                                self.bottom_pane.update_status_text(
                                    "command status unavailable".to_string(),
                                );
                            }
                        } else {
                            self.bottom_pane
                                .update_status_text("waiting for command".to_string());
                        }
                        self.invalidate_height_cache();
                        self.request_redraw();
                        return;
                    }
                }
                let running_entry = self
                    .tools_state
                    .running_custom_tools
                    .remove(&ToolCallId(call_id.clone()));
                let resolved_idx = running_entry
                    .as_ref()
                    .and_then(|entry| running_tools::resolve_entry_index(self, entry, &call_id))
                    .or_else(|| running_tools::find_by_call_id(self, &call_id));

                if tool_name == "apply_patch" && success {
                    if let Some(idx) = resolved_idx {
                        if idx < self.history_cells.len() {
                            let is_running_tool = self.history_cells[idx]
                                .as_any()
                                .downcast_ref::<history_cell::RunningToolCallCell>()
                                .is_some();
                            if is_running_tool {
                                self.history_remove_at(idx);
                            }
                        }
                    }
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }

                if tool_name == "wait" && success {
                    let target = wait_target_from_params(params_string.as_ref(), &call_id);
                    let wait_cell = history_cell::new_completed_wait_tool_call(target, duration);
                    let wait_state = wait_cell.state().clone();
                    if let Some(idx) = resolved_idx {
                        self.history_replace_with_record(
                            idx,
                            Box::new(wait_cell),
                            HistoryDomainRecord::WaitStatus(wait_state),
                        );
                    } else {
                        let _ = self.history_insert_with_key_global_tagged(
                            Box::new(wait_cell),
                            ok,
                            "untagged",
                            Some(HistoryDomainRecord::WaitStatus(wait_state)),
                        );
                    }
                    self.remove_background_completion_message(&call_id);
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                if tool_name == "wait" && !success && content.trim() == "Cancelled by user." {
                    let mut emphasis = TextEmphasis::default();
                    emphasis.bold = true;
                    let wait_state = PlainMessageState {
                        id: HistoryId::ZERO,
                        role: PlainMessageRole::Error,
                        kind: PlainMessageKind::Error,
                        header: None,
                        lines: vec![MessageLine {
                            kind: MessageLineKind::Paragraph,
                            spans: vec![InlineSpan {
                                text: "Wait cancelled".into(),
                                tone: TextTone::Error,
                                emphasis,
                                entity: None,
                            }],
                        }],
                        metadata: None,
                    };

                    if let Some(idx) = resolved_idx {
                        self.history_replace_with_record(
                            idx,
                            Box::new(history_cell::PlainHistoryCell::from_state(wait_state.clone())),
                            HistoryDomainRecord::Plain(wait_state.clone()),
                        );
                    } else {
                        let _ = self.history_insert_plain_state_with_key(wait_state, ok, "untagged");
                    }

                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                if tool_name == "kill" {
                    let _ = self
                        .tools_state
                        .running_kill_tools
                        .remove(&ToolCallId(call_id.clone()));
                    if success {
                        self.remove_background_completion_message(&call_id);
                        self.bottom_pane
                            .update_status_text("responding".to_string());
                    } else {
                        let trimmed = content.trim();
                        if !trimmed.is_empty() {
                            self.push_background_tail(trimmed.to_string());
                        }
                        self.bottom_pane
                            .update_status_text("kill failed".to_string());
                    }
                    self.maybe_hide_spinner();
                    self.invalidate_height_cache();
                    self.request_redraw();
                    return;
                }
                // Special-case browser/web fetch to render returned markdown nicely.
                if tool_name == "web_fetch" || tool_name == "browser_fetch" {
                    let completed = history_cell::new_completed_web_fetch_tool_call(
                        &self.config,
                        params_string,
                        duration,
                        success,
                        content,
                    );
                    if let Some(idx) = resolved_idx {
                        self.history_replace_at(idx, Box::new(completed));
                    } else {
                        running_tools::collapse_spinner(self, &call_id);
                        let _ = self.history_insert_with_key_global(Box::new(completed), ok);
                    }

                    // After tool completes, likely transitioning to response
                    self.bottom_pane
                        .update_status_text("responding".to_string());
                    self.maybe_hide_spinner();
                    return;
                }
                let mut completed = history_cell::new_completed_custom_tool_call(
                    tool_name,
                    params_string,
                    duration,
                    success,
                    content,
                );
                completed.state_mut().call_id = Some(call_id.clone());
                if let Some(idx) = resolved_idx {
                    self.history_debug(format!(
                        "custom_tool_end.in_place call_id={} idx={} order=({}, {}, {})",
                        call_id,
                        idx,
                        ok.req,
                        ok.out,
                        ok.seq
                    ));
                    self.history_replace_at(idx, Box::new(completed));
                } else {
                    self.history_debug(format!(
                        "custom_tool_end.fallback_insert call_id={} order=({}, {}, {})",
                        call_id,
                        ok.req,
                        ok.out,
                        ok.seq
                    ));
                    running_tools::collapse_spinner(self, &call_id);
                    let _ = self.history_insert_with_key_global(Box::new(completed), ok);
                }

                if let Some(path) = image_view_path.as_ref() {
                    if let Some(record) = image_record_from_path(path) {
                        let cell = Box::new(history_cell::ImageOutputCell::from_record(record));
                        let _ = self.history_insert_with_key_global(cell, ok);
                    }
                }

                // After tool completes, likely transitioning to response
                self.bottom_pane
                    .update_status_text("responding".to_string());
                self.maybe_hide_spinner();
            }
            EventMsg::ViewImageToolCall(ViewImageToolCallEvent { call_id, path }) => {
                let ok = match event.order.as_ref() {
                    Some(om) => self.provider_order_key_from_order_meta(om),
                    None => {
                        tracing::warn!("missing OrderMeta on ViewImageToolCall; using synthetic key");
                        self.next_internal_key()
                    }
                };
                if let Some(record) = image_record_from_path(&path) {
                    let cell = Box::new(history_cell::ImageOutputCell::from_record(record));
                    let _ = self.history_insert_with_key_global(cell, ok);
                    self.tools_state
                        .image_viewed_calls
                        .insert(ToolCallId(call_id));
                }
            }
            EventMsg::GetHistoryEntryResponse(event) => {
                let code_core::protocol::GetHistoryEntryResponseEvent {
                    offset,
                    log_id,
                    entry,
                } = event;

                // Inform bottom pane / composer.
                self.bottom_pane
                    .on_history_entry_response(log_id, offset, entry.map(|e| e.text));
            }
            EventMsg::ListCustomPromptsResponse(ev) => {
                let len = ev.custom_prompts.len();
                debug!("received {len} custom prompts");
                self.bottom_pane.set_custom_prompts(ev.custom_prompts);
            }
            EventMsg::ListSkillsResponse(ev) => {
                let len = ev.skills.len();
                debug!("received {len} skills");
                self.bottom_pane.set_skills(ev.skills);
                self.refresh_settings_overview_rows();
            }
            EventMsg::ShutdownComplete => {
                self.push_background_tail("🟡 ShutdownComplete".to_string());
                self.app_event_tx.send(AppEvent::ExitRequest);
            }
            EventMsg::TurnDiff(TurnDiffEvent { unified_diff }) => {
                info!("TurnDiffEvent: {unified_diff}");
                self.turn_had_code_edits = true;
            }
            EventMsg::BackgroundEvent(BackgroundEventEvent { message }) => {
                info!("BackgroundEvent: {message}");
                if browser_sessions::handle_background_event(
                    self,
                    event.order.as_ref(),
                    &message,
                ) {
                    return;
                }
                let is_agent_hint = message.starts_with("🤖 Agent");
                if is_agent_hint && self.suppress_next_agent_hint {
                    self.suppress_next_agent_hint = false;
                    self.clear_resume_placeholder();
                    return;
                }
                self.clear_resume_placeholder();
                // Route through unified system notice helper. If the core ties the
                // event to a turn (order present), prefer placing it before the next
                // provider output; else append to the tail. Use the event.id for
                // in-place replacement.
                let placement = match event.order.as_ref().and_then(|om| om.output_index) {
                    Some(v) if v == i32::MAX as u32 => SystemPlacement::EndOfCurrent,
                    Some(_) => SystemPlacement::EarlyInCurrent,
                    None => SystemPlacement::EndOfCurrent,
                };
                let id_for_replace = Some(id.clone());
                let message_clone = message.clone();
                let cell = history_cell::new_background_event(message_clone);
                let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
                self.push_system_cell(
                    Box::new(cell),
                    placement,
                    id_for_replace,
                    event.order.as_ref(),
                    "background",
                    Some(record),
                );
                // If we inserted during streaming, keep the reasoning ellipsis visible.
                self.restore_reasoning_in_progress_if_streaming();

                // Also reflect CDP connect success in the status line.
                if message.starts_with("✅ Connected to Chrome via CDP") {
                    self.bottom_pane
                        .update_status_text("using browser (CDP)".to_string());
                }

                if is_agent_hint
                    || message.starts_with("⚠️ Agent reuse")
                    || message.starts_with("⚠️ Agent prompt")
                {
                    self.recent_agent_hint = Some(message);
                }
            }
            EventMsg::AgentStatusUpdate(event) => {
                agent_runs::handle_status_update(self, &event);
                let AgentStatusUpdateEvent { agents, context, task } = event;
                // Update the active agents list from the event and track timing
                self.active_agents.clear();
                let now = Instant::now();
                let mut saw_running = false;
                let mut has_running_non_auto_review = false;
                let mut has_running_auto_review = false;
                for agent in agents.iter() {
                    let parsed_status = agent_status_from_str(agent.status.as_str());
                    // Update runtime map
                    let entry = self
                        .agent_runtime
                        .entry(agent.id.clone())
                        .or_insert_with(AgentRuntime::default);
                    entry.last_update = Some(now);
                    match parsed_status {
                        AgentStatus::Running => {
                            if entry.started_at.is_none() {
                                entry.started_at = Some(now);
                            }
                            saw_running = true;
                        }
                        AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled => {
                            if entry.completed_at.is_none() {
                                entry.completed_at = entry.completed_at.or(Some(now));
                            }
                        }
                        _ => {}
                    }

                    // Mirror agent list for rendering
                    self.active_agents.push(AgentInfo {
                        id: agent.id.clone(),
                        name: agent.name.clone(),
                        status: parsed_status.clone(),
                        source_kind: agent.source_kind.clone(),
                        batch_id: agent.batch_id.clone(),
                        model: agent.model.clone(),
                        result: agent.result.clone(),
                        error: agent.error.clone(),
                        last_progress: agent.last_progress.clone(),
                    });

                    let is_auto_review = Self::is_auto_review_agent(agent);

                    if matches!(parsed_status, AgentStatus::Pending | AgentStatus::Running) {
                        if is_auto_review {
                            has_running_auto_review = true;
                        } else {
                            has_running_non_auto_review = true;
                        }
                    }
                }

                self.update_agents_terminal_state(&agents, context.clone(), task.clone());

                self.observe_auto_review_status(&agents);

                let agent_hint_label = if has_running_auto_review && !has_running_non_auto_review {
                    AgentHintLabel::Review
                } else {
                    AgentHintLabel::Agents
                };
                self.bottom_pane.set_agent_hint_label(agent_hint_label);

                // Store shared context and task
                self.agent_context = context;
                self.agent_task = task;

                // Fallback: if every agent we know about has reached a terminal state and
                // there is no active streaming or tooling, clear the spinner even if the
                // backend hasn't sent TaskComplete yet. This prevents the footer from
                // getting stuck on "Responding..." after multi-agent runs that yield
                // early.
                if self.bottom_pane.is_task_running() {
                    let all_agents_terminal = !self.agent_runtime.is_empty()
                        && self
                            .agent_runtime
                            .values()
                            .all(|rt| rt.completed_at.is_some());
                    if all_agents_terminal {
                        let any_tools_running = !self.exec.running_commands.is_empty()
                            || !self.tools_state.running_custom_tools.is_empty()
                            || !self.tools_state.web_search_sessions.is_empty();
                        let any_streaming = self.stream.is_write_cycle_active();
                        if !(any_tools_running || any_streaming) {
                            self.bottom_pane.set_task_running(false);
                            self.bottom_pane.update_status_text(String::new());
                        }
                    }
                }

                if saw_running
                    && has_running_non_auto_review
                    && !self.bottom_pane.is_task_running()
                {
                    self.bottom_pane.set_task_running(true);
                    self.bottom_pane.update_status_text("Running...".to_string());
                    self.refresh_auto_drive_visuals();
                    self.request_redraw();
                }

                // Update overall task status based on agent states
                let status = Self::overall_task_status_for(&self.active_agents);
                self.overall_task_status = status.to_string();

                let agents_still_active = self
                    .active_agents
                    .iter()
                    .any(|a| matches!(a.status, AgentStatus::Pending | AgentStatus::Running));
                if agents_still_active && has_running_non_auto_review {
                    self.bottom_pane.set_task_running(true);
                } else if agents_still_active && !has_running_non_auto_review {
                    // Auto Review-only runs should not drive the spinner.
                    if !self.has_running_commands_or_tools()
                        && !self.stream.is_write_cycle_active()
                        && self.active_task_ids.is_empty()
                    {
                        self.bottom_pane.set_task_running(false);
                        self.bottom_pane.update_status_text(String::new());
                    }
                }

                // Reflect concise agent status in the input border
                if has_running_non_auto_review {
                    let count = self.active_agents.len();
                    let msg = match status {
                        "preparing" => format!("agents: preparing ({} ready)", count),
                        "running" => format!("agents: running ({})", count),
                        "complete" => format!("agents: complete ({} ok)", count),
                        "failed" => "agents: failed".to_string(),
                        "cancelled" => "agents: cancelled".to_string(),
                        _ => "agents: planning".to_string(),
                    };
                    self.bottom_pane.update_status_text(msg);
                } else if has_running_auto_review {
                    // Let the dedicated Auto Review footer drive messaging; avoid
                    // clobbering it with a generic agents status.
                    self.bottom_pane.update_status_text(String::new());
                }

                // Keep agents visible after completion so users can see final messages/errors.
                // HUD will be reset automatically when a new agent batch starts.

                // Reset ready to start flag when we get actual agent updates
                if !self.active_agents.is_empty() {
                    self.agents_ready_to_start = false;
                }
                // Re-evaluate spinner visibility now that agent states changed.
                self.maybe_hide_spinner();
                self.request_redraw();
            }
            EventMsg::BrowserScreenshotUpdate(payload) => {
                #[cfg(feature = "code-fork")]
                handle_browser_screenshot(&payload, &self.app_event_tx);

                let BrowserScreenshotUpdateEvent { screenshot_path, url } = payload;
                let update = browser_sessions::handle_screenshot_update(
                    self,
                    event.order.as_ref(),
                    &screenshot_path,
                    &url,
                );
                tracing::info!(
                    "Received browser screenshot update: {} at URL: {}",
                    screenshot_path.display(),
                    url
                );

                // Update the latest screenshot and URL for display
                if let Ok(mut latest) = self.latest_browser_screenshot.lock() {
                    let old_url = latest.as_ref().map(|(_, u)| u.clone());
                    *latest = Some((screenshot_path.clone(), url.clone()));
                    if old_url.as_ref() != Some(&url) {
                        tracing::info!("Browser URL changed from {:?} to {}", old_url, url);
                    }
                    tracing::debug!(
                        "Updated browser screenshot display with path: {} and URL: {}",
                        screenshot_path.display(),
                        url
                    );
                } else {
                    tracing::warn!("Failed to acquire lock for browser screenshot update");
                }

                if let Some(key) = update.session_key.as_ref() {
                    self.browser_overlay_state
                        .set_session_key(Some(key.clone()));
                    if let Some(tracker) = self.tools_state.browser_sessions.get(key) {
                        let len = tracker.cell.screenshot_history().len();
                        if len > 0 {
                            let last_index = len.saturating_sub(1);
                            let current_index = self.browser_overlay_state.screenshot_index();
                            if !self.browser_overlay_visible || current_index >= last_index {
                                self.browser_overlay_state
                                    .set_screenshot_index(last_index);
                            }
                        }
                    }
                }

                // Request a redraw to update the display immediately
                self.app_event_tx.send(AppEvent::RequestRedraw);

                if update.grouped {
                    self.bottom_pane
                        .update_status_text("using browser".to_string());
                }
            }
            // Newer protocol variants we currently ignore in the TUI
            EventMsg::UserMessage(_) => {}
            EventMsg::TurnAborted(_) => {}
            EventMsg::ConversationPath(_) => {}
            EventMsg::EnteredReviewMode(review_request) => {
                if self.auto_resolve_enabled() {
                    self.auto_resolve_handle_review_enter();
                }
                let hint = review_request.user_facing_hint.trim();
                let banner = if hint.is_empty() {
                    ">> Code review started <<".to_string()
                } else {
                    format!(">> Code review started: {hint} <<")
                };
                self.active_review_hint = Some(review_request.user_facing_hint.clone());
                self.active_review_prompt = Some(review_request.prompt.clone());
                self.push_background_before_next_output(banner);

                let prompt_text = review_request.prompt.trim();
                if !prompt_text.is_empty() {
                    let mut lines: Vec<Line<'static>> = Vec::new();
                    lines.push(Line::from(vec![RtSpan::styled(
                        "Review focus",
                        Style::default().add_modifier(Modifier::BOLD),
                    )]));
                    lines.push(Line::from(""));
                    for line in prompt_text.lines() {
                        lines.push(Line::from(line.to_string()));
                    }
                    let state = history_cell::plain_message_state_from_lines(
                        lines,
                        history_cell::HistoryCellType::Notice,
                    );
                    self.history_push_plain_state(state);
                }
                if self.auto_state.is_active() {
                    self.auto_state.on_begin_review(false);
                    self.auto_rebuild_live_ring();
                }
                self.request_redraw();
            }
            EventMsg::ExitedReviewMode(review_event) => {
                if self.auto_resolve_enabled() {
                    self.auto_resolve_handle_review_exit(review_event.review_output.clone());
                }
                self.review_guard = None;
                let hint = self.active_review_hint.take();
                let prompt = self.active_review_prompt.take();
                match review_event.review_output {
                    Some(output) => {
                        let summary_cell = self.build_review_summary_cell(
                            hint.as_deref(),
                            prompt.as_deref(),
                            &output,
                        );
                        self.history_push(summary_cell);
                        let finish_banner = match hint.as_deref() {
                            Some(h) if !h.trim().is_empty() => {
                                let trimmed = h.trim();
                                format!("<< Code review finished: {trimmed} >>")
                            }
                            _ => "<< Code review finished >>".to_string(),
                        };
                        self.push_background_tail(finish_banner);
                    }
                    None => {
                        let banner = match hint.as_deref() {
                            Some(h) if !h.trim().is_empty() => {
                                let trimmed = h.trim();
                                format!(
                                    "<< Code review finished without a final response ({trimmed}) >>"
                                )
                            }
                            _ => "<< Code review finished without a final response >>".to_string(),
                        };
                        self.push_background_tail(banner);
                        self.history_push_plain_state(history_cell::new_warning_event(
                            "Review session ended without returning findings. Try `/review` again if you still need feedback.".to_string(),
                        ));
                    }
                }
                if self.auto_state.is_active() && self.auto_state.awaiting_review() {
                    if self.auto_resolve_should_block_auto_resume() {
                        self.request_redraw();
                    } else {
                        self.maybe_resume_auto_after_review();
                    }
                } else {
                    self.request_redraw();
                }
            }
        }
    }

    fn request_redraw(&mut self) {
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    pub(crate) fn handle_perf_command(&mut self, args: String) {
        let arg = args.trim().to_lowercase();
        match arg.as_str() {
            "on" => {
                self.perf_state.enabled = true;
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance tracing: on".to_string());
            }
            "off" => {
                self.perf_state.enabled = false;
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance tracing: off".to_string());
            }
            "reset" => {
                self.perf_state.stats.borrow_mut().reset();
                self.perf_state.pending_scroll_rows.set(0);
                self.add_perf_output("performance stats reset".to_string());
            }
            "show" | "" => {
                let summary = self.perf_state.stats.borrow().summary();
                self.add_perf_output(summary);
            }
            _ => {
                self.add_perf_output("usage: /perf on | off | show | reset".to_string());
            }
        }
        self.request_redraw();
    }

    pub(crate) fn handle_demo_command(&mut self, command_args: String) {
        let trimmed_args = command_args.trim();
        if !trimmed_args.is_empty() {
            if self.handle_demo_auto_drive_card_background_palette(trimmed_args) {
                self.request_redraw();
                return;
            }

            self.history_push_plain_state(history_cell::new_warning_event(format!(
                "demo: unknown args '{trimmed_args}' (try: /demo auto drive card)",
            )));
            self.request_redraw();
            return;
        }

        use ratatui::style::Modifier as RtModifier;
        use ratatui::style::Style as RtStyle;
        use ratatui::text::Span;

        self.push_background_tail("demo: populating history with sample cells…");
        enum DemoPatch {
            Add {
                path: &'static str,
                content: &'static str,
            },
            Update {
                path: &'static str,
                unified_diff: &'static str,
                original: &'static str,
                new_content: &'static str,
            },
        }

        let scenarios = [
            (
                "build automation",
                "How do I wire up CI, linting, and release automation for this repo?",
                vec![
                    ("Context", "scan workspace layout and toolchain."),
                    ("Next", "surface build + validation commands."),
                    ("Goal", "summarize a reproducible workflow."),
                ],
                vec![
                    "streaming preview: inspecting package manifests…",
                    "streaming preview: drafting deployment summary…",
                    "streaming preview: cross-checking lint targets…",
                ],
                "**Here's a demo walkthrough:**\n\n1. Run `./build-fast.sh perf` to compile quickly.\n2. Cache artifacts in `code-rs/target/perf`.\n3. Finish by sharing `./build-fast.sh run` output.\n\n```bash\n./build-fast.sh perf run\n```",
                vec![
                    (vec!["git", "status"], "On branch main\nnothing to commit, working tree clean\n"),
                    (vec!["rg", "--files"], ""),
                ],
                Some(DemoPatch::Add {
                    path: "src/demo.rs",
                    content: "fn main() {\n    println!(\"demo\");\n}\n",
                }),
                UpdatePlanArgs {
                    name: Some("Demo Scroll Plan".to_string()),
                    plan: vec![
                        PlanItemArg {
                            step: "Create reproducible builds".to_string(),
                            status: StepStatus::InProgress,
                        },
                        PlanItemArg {
                            step: "Verify validations".to_string(),
                            status: StepStatus::Pending,
                        },
                        PlanItemArg {
                            step: "Document follow-up tasks".to_string(),
                            status: StepStatus::Completed,
                        },
                    ],
                },
                ("browser_open", "https://example.com", "navigated to example.com"),
                ReasoningEffort::High,
                "demo: lint warnings will appear here",
                "demo: this slot shows error output",
                Some("diff --git a/src/lib.rs b/src/lib.rs\n@@ -1,3 +1,5 @@\n-pub fn hello() {}\n+pub fn hello() {\n+    println!(\"hello, demo!\");\n+}\n"),
            ),
            (
                "release rehearsal",
                "What checklist should I follow before tagging a release?",
                vec![
                    ("Inventory", "collect outstanding changes and docs."),
                    ("Verify", "run smoke tests and package audits."),
                    ("Announce", "draft release notes and rollout plan."),
                ],
                vec![
                    "streaming preview: aggregating changelog entries…",
                    "streaming preview: validating release artifacts…",
                    "streaming preview: preparing announcement copy…",
                ],
                "**Release rehearsal:**\n\n1. Run `./scripts/create_github_release.sh --dry-run`.\n2. Capture artifact hashes in the notes.\n3. Schedule follow-up validation in automation.\n\n```bash\n./scripts/create_github_release.sh 1.2.3 --dry-run\n```",
                vec![
                    (vec!["git", "--no-pager", "diff", "--stat"], " src/lib.rs | 10 ++++++----\n 1 file changed, 6 insertions(+), 4 deletions(-)\n"),
                    (vec!["ls", "-1"], "Cargo.lock\nREADME.md\nsrc\ntarget\n"),
                ],
                Some(DemoPatch::Update {
                    path: "src/release.rs",
                    unified_diff: "--- a/src/release.rs\n+++ b/src/release.rs\n@@ -1 +1,3 @@\n-pub fn release() {}\n+pub fn release() {\n+    println!(\"drafting release\");\n+}\n",
                    original: "pub fn release() {}\n",
                    new_content: "pub fn release() {\n    println!(\"drafting release\");\n}\n",
                }),
                UpdatePlanArgs {
                    name: Some("Release Gate Plan".to_string()),
                    plan: vec![
                        PlanItemArg {
                            step: "Finalize changelog".to_string(),
                            status: StepStatus::Completed,
                        },
                        PlanItemArg {
                            step: "Run smoke tests".to_string(),
                            status: StepStatus::InProgress,
                        },
                        PlanItemArg {
                            step: "Tag release".to_string(),
                            status: StepStatus::Pending,
                        },
                        PlanItemArg {
                            step: "Notify stakeholders".to_string(),
                            status: StepStatus::Pending,
                        },
                    ],
                },
                ("browser_open", "https://example.com/releases", "reviewed release dashboard"),
                ReasoningEffort::Medium,
                "demo: release checklist warning",
                "demo: release checklist error",
                Some("diff --git a/CHANGELOG.md b/CHANGELOG.md\n@@ -1,3 +1,6 @@\n+## 1.2.3\n+- polish release flow\n+- document automation hooks\n"),
            ),
        ];

        for (idx, scenario) in scenarios.iter().enumerate() {
            let (
                label,
                prompt,
                reasoning_steps,
                stream_lines,
                assistant_body,
                execs,
                patch_change,
                plan,
                tool_call,
                effort,
                warning_text,
                error_text,
                diff_snippet,
            ) = scenario;

            self.push_background_tail(format!(
                "demo: scenario {} — {}",
                idx + 1,
                label
            ));

            self.history_push_plain_state(history_cell::new_user_prompt((*prompt).to_string()));

            let mut reasoning_lines: Vec<Line<'static>> = reasoning_steps
                .iter()
                .map(|(title, body)| {
                    Line::from(vec![
                        Span::styled(
                            format!("{}:", title),
                            RtStyle::default().add_modifier(RtModifier::BOLD),
                        ),
                        Span::raw(format!(" {body}")),
                    ])
                })
                .collect();
            reasoning_lines.push(
                Line::from(format!("Scenario summary: {}", label))
                    .style(RtStyle::default().fg(crate::colors::text_dim())),
            );
            let reasoning_cell = history_cell::CollapsibleReasoningCell::new_with_id(
                reasoning_lines,
                Some(format!("demo-reasoning-{}", idx)),
            );
            reasoning_cell.set_collapsed(false);
            reasoning_cell.set_in_progress(false);
            self.history_push(reasoning_cell);

            let preview_lines: Vec<ratatui::text::Line<'static>> = stream_lines
                .iter()
                .map(|line| Line::from((*line).to_string()))
                .collect();
            let state = self.synthesize_stream_state_from_lines(None, &preview_lines, false);
            let streaming_preview = history_cell::new_streaming_content(state, &self.config);
            self.history_push(streaming_preview);

            let assistant_state = AssistantMessageState {
                id: HistoryId::ZERO,
                stream_id: None,
                markdown: (*assistant_body).to_string(),
                citations: Vec::new(),
                metadata: None,
                token_usage: None,
                mid_turn: false,
                created_at: SystemTime::now(),
            };
            let assistant_cell =
                history_cell::AssistantMarkdownCell::from_state(assistant_state, &self.config);
            self.history_push(assistant_cell);

            for (command_tokens, stdout) in execs {
                let cmd_vec: Vec<String> = command_tokens.iter().map(|s| s.to_string()).collect();
                let parsed = code_core::parse_command::parse_command(&cmd_vec);
                self.history_push(history_cell::new_active_exec_command(
                    cmd_vec.clone(),
                    parsed.clone(),
                ));
                if !stdout.is_empty() {
                    let output = history_cell::CommandOutput {
                        exit_code: 0,
                        stdout: stdout.to_string(),
                        stderr: String::new(),
                    };
                    self.history_push(history_cell::new_completed_exec_command(
                        cmd_vec,
                        parsed,
                        output,
                    ));
                }
            }

            if let Some(diff) = diff_snippet {
                self.history_push_diff(None, diff.to_string());
            }

            if let Some(patch) = patch_change {
                let mut patch_changes = HashMap::new();
                let message = match patch {
                    DemoPatch::Add { path, content } => {
                        patch_changes.insert(
                            PathBuf::from(path),
                            code_core::protocol::FileChange::Add {
                                content: (*content).to_string(),
                            },
                        );
                        format!("patch: simulated failure while applying {}", path)
                    }
                    DemoPatch::Update {
                        path,
                        unified_diff,
                        original,
                        new_content,
                    } => {
                        patch_changes.insert(
                            PathBuf::from(path),
                            code_core::protocol::FileChange::Update {
                                unified_diff: (*unified_diff).to_string(),
                                move_path: None,
                                original_content: (*original).to_string(),
                                new_content: (*new_content).to_string(),
                            },
                        );
                        format!("patch: simulated failure while applying {}", path)
                    }
                };
                self.history_push(history_cell::new_patch_event(
                    history_cell::PatchEventType::ApprovalRequest,
                    patch_changes,
                ));
                self.history_push_plain_state(history_cell::new_patch_apply_failure(message));
            }

            self.history_push(history_cell::new_plan_update(plan.clone()));

            let (tool_name, url, result) = tool_call;
            self.history_push(history_cell::new_completed_custom_tool_call(
                (*tool_name).to_string(),
                Some((*url).to_string()),
                Duration::from_millis(420 + (idx as u64 * 150)),
                true,
                (*result).to_string(),
            ));

            self.history_push_plain_state(history_cell::new_warning_event((*warning_text).to_string()));
            self.history_push_plain_state(history_cell::new_error_event((*error_text).to_string()));

            self.history_push_plain_state(history_cell::new_model_output("gpt-5.1-codex", *effort));
            self.history_push_plain_state(history_cell::new_reasoning_output(effort));

            self.history_push_plain_state(history_cell::new_status_output(
                &self.config,
                &self.total_token_usage,
                &self.last_token_usage,
            ));

            self.history_push_plain_state(history_cell::new_prompts_output());
        }

        let final_preview_lines = vec![
            Line::from("streaming preview: final tokens rendered."),
            Line::from("streaming preview: viewport ready for scroll testing."),
        ];
        let final_state =
            self.synthesize_stream_state_from_lines(None, &final_preview_lines, false);
        let final_stream = history_cell::new_streaming_content(final_state, &self.config);
        self.history_push(final_stream);

        self.push_background_tail("demo: rendering sample tool cards for theme review…");

        let mut agent_card = history_cell::AgentRunCell::new("Demo Agent Batch".to_string());
        agent_card.set_batch_label(Some("Demo Agents".to_string()));
        agent_card.set_task(Some("Draft a release checklist".to_string()));
        agent_card.set_context(Some("Context: codex workspace demo run".to_string()));
        agent_card.set_plan(vec![
            "Collect recent commits".to_string(),
            "Summarize blockers".to_string(),
            "Draft announcement".to_string(),
        ]);
        let mut completed_preview = history_cell::AgentStatusPreview::default();
        completed_preview.id = "demo-completed".to_string();
        completed_preview.name = "Docs Scout".to_string();
        completed_preview.status = "Completed".to_string();
        completed_preview.model = Some("gpt-5.1-large".to_string());
        completed_preview.details = vec![history_cell::AgentDetail::Result(
            "Summarized API changes".to_string(),
        )];
        completed_preview.status_kind = history_cell::AgentStatusKind::Completed;
        completed_preview.step_progress = Some(history_cell::StepProgress { completed: 3, total: 3 });
        completed_preview.elapsed = Some(Duration::from_secs(32));
        completed_preview.last_update = Some("Wrapped up summary".to_string());
        let mut running_preview = history_cell::AgentStatusPreview::default();
        running_preview.id = "demo-running".to_string();
        running_preview.name = "Lint Fixer".to_string();
        running_preview.status = "Running".to_string();
        running_preview.model = Some("code-gpt-5.2".to_string());
        running_preview.details = vec![history_cell::AgentDetail::Progress(
            "Refining suggested fixes".to_string(),
        )];
        running_preview.status_kind = history_cell::AgentStatusKind::Running;
        running_preview.step_progress = Some(history_cell::StepProgress { completed: 1, total: 3 });
        running_preview.elapsed = Some(Duration::from_secs(18));
        running_preview.last_update = Some("Step 2 of 3".to_string());
        agent_card.set_agent_overview(vec![completed_preview, running_preview]);
        agent_card.set_latest_result(vec!["Generated release briefing".to_string()]);
        agent_card.record_action("Collecting changelog entries");
        agent_card.record_action("Writing release notes");
        agent_card.set_duration(Some(Duration::from_secs(96)));
        agent_card.set_write_mode(Some(true));
        agent_card.set_status_label("Completed");
        agent_card.mark_completed();
        self.history_push(agent_card);

        let mut agent_read_card = history_cell::AgentRunCell::new("Demo Read Batch".to_string());
        agent_read_card.set_batch_label(Some("Read Agents".to_string()));
        agent_read_card.set_task(Some("Survey docs for regression notes".to_string()));
        agent_read_card.set_context(Some("Scope: analyze docs, no writes".to_string()));
        agent_read_card.set_plan(vec![
            "Gather doc highlights".to_string(),
            "Verify changelog snippets".to_string(),
        ]);
        let mut pending_preview = history_cell::AgentStatusPreview::default();
        pending_preview.id = "demo-read-pending".to_string();
        pending_preview.name = "Doc Harvester".to_string();
        pending_preview.status = "Pending".to_string();
        pending_preview.model = Some("gpt-4.5".to_string());
        pending_preview.details = vec![history_cell::AgentDetail::Info(
            "Waiting for search index".to_string(),
        )];
        pending_preview.status_kind = history_cell::AgentStatusKind::Pending;
        let mut running_read = history_cell::AgentStatusPreview::default();
        running_read.id = "demo-read-running".to_string();
        running_read.name = "Spec Parser".to_string();
        running_read.status = "Running".to_string();
        running_read.model = Some("code-gpt-3.5".to_string());
        running_read.details = vec![history_cell::AgentDetail::Progress(
            "Scanning RFC summaries".to_string(),
        )];
        running_read.status_kind = history_cell::AgentStatusKind::Running;
        running_read.step_progress = Some(history_cell::StepProgress { completed: 2, total: 5 });
        running_read.elapsed = Some(Duration::from_secs(22));
        agent_read_card.set_agent_overview(vec![pending_preview, running_read]);
        agent_read_card.record_action("Fetching documentation excerpts");
        agent_read_card.set_duration(Some(Duration::from_secs(54)));
        agent_read_card.set_write_mode(Some(false));
        agent_read_card.set_status_label("Running");
        self.history_push(agent_read_card);

        let mut browser_card = history_cell::BrowserSessionCell::new();
        browser_card.set_url("https://example.dev/releases");
        browser_card.set_headless(Some(false));
        browser_card.record_action(
            Duration::from_millis(0),
            Duration::from_millis(420),
            "open".to_string(),
            Some("https://example.dev/releases".to_string()),
            None,
            Some("status=200".to_string()),
        );
        browser_card.record_action(
            Duration::from_millis(620),
            Duration::from_millis(380),
            "scroll".to_string(),
            Some("main timeline".to_string()),
            Some("dy=512".to_string()),
            None,
        );
        browser_card.record_action(
            Duration::from_millis(1280),
            Duration::from_millis(520),
            "click".to_string(),
            Some(".release-card".to_string()),
            Some("index=2".to_string()),
            Some("status=OK".to_string()),
        );
        browser_card.add_console_message("Loaded demo assets".to_string());
        browser_card.add_console_message("Fetched changelog via XHR".to_string());
        browser_card.set_status_code(Some("200 OK".to_string()));
        self.history_push(browser_card);

        let mut search_card = history_cell::WebSearchSessionCell::new();
        search_card.set_query(Some("rust async cancellation strategy".to_string()));
        search_card.ensure_started_message();
        search_card.record_info(Duration::from_millis(120), "Searching documentation index");
        search_card.record_success(Duration::from_millis(620), "Found tokio.rs guides");
        search_card.record_success(Duration::from_millis(1040), "Linked blog: cancellation patterns");
        search_card.set_status(history_cell::WebSearchStatus::Completed);
        search_card.set_duration(Some(Duration::from_millis(1400)));
        self.history_push(search_card);

        let mut auto_drive_card =
            history_cell::AutoDriveCardCell::new(Some("Stabilize nightly CI pipeline".to_string()));
        auto_drive_card.push_action(
            "Queued smoke tests across agents",
            history_cell::AutoDriveActionKind::Info,
        );
        auto_drive_card.push_action(
            "Warning: macOS shard flaked",
            history_cell::AutoDriveActionKind::Warning,
        );
        auto_drive_card.push_action(
            "Action required: retry or pause run",
            history_cell::AutoDriveActionKind::Error,
        );
        auto_drive_card.set_status(history_cell::AutoDriveStatus::Paused);
        self.history_push(auto_drive_card);

        let goal = "Stabilize nightly CI pipeline".to_string();
        self.auto_state.last_run_summary = Some(AutoRunSummary {
            duration: Duration::from_secs(95),
            turns_completed: 4,
            message: Some("Auto Drive completed demo run.".to_string()),
            goal: Some(goal),
        });
        let celebration_message = "Diagnostics report: all demo checks passed.".to_string();
        self.auto_state.last_completion_explanation = Some(celebration_message.clone());
        self.schedule_auto_drive_card_celebration(Duration::from_secs(2), Some(celebration_message));

        self.request_redraw();
    }

    fn handle_demo_auto_drive_card_background_palette(&mut self, args: &str) -> bool {
        if !Self::demo_command_is_auto_drive_card_backgrounds(args) {
            return false;
        }

        let (r, g, b) = crate::colors::color_to_rgb(crate::colors::background());
        let luminance = (0.2126 * r as f32 + 0.7152 * g as f32 + 0.0722 * b as f32) / 255.0;
        let theme_label = if luminance < 0.5 { "dark" } else { "light" };

        self.history_push_plain_state(history_cell::plain_message_state_from_lines(
            vec![
                ratatui::text::Line::from("Auto Drive card — ANSI-16 background palette"),
                ratatui::text::Line::from(format!(
                    "Theme context: {theme_label} (based on current /theme background)",
                )),
                ratatui::text::Line::from(
                    "Tip: switch /theme (dark/light) and rerun to compare.".to_string(),
                ),
            ],
            HistoryCellType::Notice,
        ));

        use ratatui::style::Color;
        const PALETTE: &[(Color, &str)] = &[
            (Color::Black, "Black"),
            (Color::Red, "Red"),
            (Color::Green, "Green"),
            (Color::Yellow, "Yellow"),
            (Color::Blue, "Blue"),
            (Color::Magenta, "Magenta"),
            (Color::Cyan, "Cyan"),
            (Color::Gray, "Gray"),
            (Color::DarkGray, "DarkGray"),
            (Color::LightRed, "LightRed"),
            (Color::LightGreen, "LightGreen"),
            (Color::LightYellow, "LightYellow"),
            (Color::LightBlue, "LightBlue"),
            (Color::LightMagenta, "LightMagenta"),
            (Color::LightCyan, "LightCyan"),
            (Color::White, "White"),
        ];

        for (idx, (bg, name)) in PALETTE.iter().enumerate() {
            let ordinal = idx + 1;
            let goal = format!("ANSI-16 bg {ordinal:02}: {name}");
            let mut auto_drive_card = history_cell::AutoDriveCardCell::new(Some(goal));
            auto_drive_card.disable_reveal();
            auto_drive_card.set_background_override(Some(*bg));
            auto_drive_card.push_action(
                "Queued smoke tests across agents",
                AutoDriveActionKind::Info,
            );
            auto_drive_card.push_action(
                "Warning: macOS shard flaked",
                AutoDriveActionKind::Warning,
            );
            auto_drive_card.push_action(
                "Action required: retry or pause run",
                AutoDriveActionKind::Error,
            );
            auto_drive_card.set_status(AutoDriveStatus::Paused);
            self.history_push(auto_drive_card);
        }

        true
    }

    fn demo_command_is_auto_drive_card_backgrounds(args: &str) -> bool {
        let normalized = args.trim().to_ascii_lowercase();
        let simplified = normalized.replace(['-', '_'], " ");
        let tokens: std::collections::HashSet<&str> = simplified.split_whitespace().collect();
        if tokens.is_empty() {
            return false;
        }

        let wants_auto_drive = (tokens.contains("auto") && tokens.contains("drive"))
            || tokens.contains("autodrive")
            || tokens.contains("auto-drive");
        let wants_card = tokens.contains("card") || tokens.contains("cards");
        let wants_background = tokens.contains("bg")
            || tokens.contains("background")
            || tokens.contains("backgrounds")
            || tokens.contains("color")
            || tokens.contains("colors")
            || tokens.contains("colour")
            || tokens.contains("colours");

        wants_auto_drive && (wants_card || wants_background)
    }

    fn add_perf_output(&mut self, text: String) {
        let mut lines: Vec<ratatui::text::Line<'static>> = Vec::new();
        lines.push(ratatui::text::Line::from("performance".dim()));
        for l in text.lines() {
            lines.push(ratatui::text::Line::from(l.to_string()))
        }
        let state = history_cell::plain_message_state_from_lines(
            lines,
            crate::history_cell::HistoryCellType::Notice,
        );
        self.history_push_plain_state(state);
    }

    pub(crate) fn add_diff_output(&mut self, diff_output: String) {
        self.history_push_diff(None, diff_output);
    }

    pub(crate) fn add_status_output(&mut self) {
        self.history_push_plain_state(history_cell::new_status_output(
            &self.config,
            &self.total_token_usage,
            &self.last_token_usage,
        ));
    }

    pub(crate) fn show_limits_settings_ui(&mut self) {
        self.ensure_settings_overlay_section(SettingsSection::Limits);

        if let Some(cached) = self.limits.cached_content.take() {
            self.update_limits_settings_content(cached);
        }

        let snapshot = self.rate_limit_snapshot.clone();
        let needs_refresh = self.should_refresh_limits();

        if self.rate_limit_fetch_inflight || needs_refresh {
            self.set_limits_overlay_content(LimitsOverlayContent::Loading);
        } else {
            let reset_info = self.rate_limit_reset_info();
            let tabs = self.build_limits_tabs(snapshot.clone(), reset_info);
            self.set_limits_overlay_tabs(tabs);
        }

        self.request_redraw();

        if needs_refresh {
            self.request_latest_rate_limits(snapshot.is_none());
        }

        self.refresh_limits_for_other_accounts_if_due();
    }

    fn refresh_limits_for_other_accounts_if_due(&mut self) {
        let code_home = self.config.code_home.clone();
        let active_id = auth_accounts::get_active_account_id(&code_home)
            .ok()
            .flatten();
        let accounts = auth_accounts::list_accounts(&code_home).unwrap_or_default();
        if accounts.is_empty() {
            return;
        }

        let usage_records = account_usage::list_rate_limit_snapshots(&code_home).unwrap_or_default();
        let snapshot_map: HashMap<String, StoredRateLimitSnapshot> = usage_records
            .into_iter()
            .map(|record| (record.account_id.clone(), record))
            .collect();
        let now = Utc::now();
        let stale_interval = account_usage::rate_limit_refresh_stale_interval();

        for account in accounts {
            if active_id.as_deref() == Some(account.id.as_str()) {
                continue;
            }

            let reset_at = snapshot_map
                .get(&account.id)
                .and_then(|record| record.secondary_next_reset_at);
            let plan = account
                .tokens
                .as_ref()
                .and_then(|tokens| tokens.id_token.get_chatgpt_plan_type());

            let should_refresh = account_usage::mark_rate_limit_refresh_attempt_if_due(
                &code_home,
                &account.id,
                plan.as_deref(),
                reset_at,
                now,
                stale_interval,
            )
            .unwrap_or(false);

            if should_refresh {
                start_rate_limit_refresh_for_account(
                    self.app_event_tx.clone(),
                    self.config.clone(),
                    self.config.debug,
                    account,
                    false,
                    false,
                );
            }
        }
    }

    fn request_latest_rate_limits(&mut self, show_loading: bool) {
        if self.rate_limit_fetch_inflight {
            return;
        }

        if show_loading {
            self.set_limits_overlay_content(LimitsOverlayContent::Loading);
            self.request_redraw();
        }

        self.rate_limit_fetch_inflight = true;

        start_rate_limit_refresh(
            self.app_event_tx.clone(),
            self.config.clone(),
            self.config.debug,
        );
    }

    fn should_refresh_limits(&self) -> bool {
        if self.rate_limit_fetch_inflight {
            return false;
        }
        match self.rate_limit_last_fetch_at {
            Some(ts) => Utc::now() - ts > RATE_LIMIT_REFRESH_INTERVAL,
            None => true,
        }
    }

    pub(crate) fn on_auto_upgrade_completed(&mut self, version: String) {
        let notice = format!("Auto-upgraded to version {version}");
        self.latest_upgrade_version = None;
        self.push_background_tail(notice.clone());
        self.bottom_pane.flash_footer_notice(notice);
        self.request_redraw();
    }

    pub(crate) fn on_rate_limit_refresh_failed(&mut self, message: String) {
        self.rate_limit_fetch_inflight = false;

        let content = if self.rate_limit_snapshot.is_some() {
            LimitsOverlayContent::Error(message.clone())
        } else {
            LimitsOverlayContent::Placeholder
        };
        self.set_limits_overlay_content(content);
        self.request_redraw();

        if self.rate_limit_snapshot.is_some() {
            self.history_push_plain_state(history_cell::new_warning_event(message));
        }
    }

    pub(crate) fn on_rate_limit_snapshot_stored(&mut self, _account_id: String) {
        self.refresh_settings_overview_rows();
        let refresh_limits_settings = self
            .settings
            .overlay
            .as_ref()
            .map(|overlay| {
                overlay.active_section() == SettingsSection::Limits && !overlay.is_menu_active()
            })
            .unwrap_or(false);
        if refresh_limits_settings {
            self.show_limits_settings_ui();
        } else {
            self.request_redraw();
        }
    }

    fn rate_limit_reset_info(&self) -> RateLimitResetInfo {
        let auto_compact_limit = self
            .config
            .model_auto_compact_token_limit
            .and_then(|limit| (limit > 0).then_some(limit as u64));
        let auto_compact_tokens_used = auto_compact_limit.map(|_| {
            // Use the latest turn's context footprint, which best matches when
            // auto-compaction triggers, instead of the lifetime session total.
            self.last_token_usage.tokens_in_context_window()
        });
        let context_window = self.config.model_context_window;
        let context_tokens_used = context_window.map(|_| self.last_token_usage.tokens_in_context_window());

        RateLimitResetInfo {
            primary_next_reset: self.rate_limit_primary_next_reset_at,
            secondary_next_reset: self.rate_limit_secondary_next_reset_at,
            auto_compact_tokens_used,
            auto_compact_limit,
            overflow_auto_compact: true,
            context_window,
            context_tokens_used,
        }
    }

    fn rate_limit_display_config_for_account(
        account: Option<&StoredAccount>,
    ) -> RateLimitDisplayConfig {
        if matches!(account.map(|acc| acc.mode), Some(McpAuthMode::ApiKey)) {
            RateLimitDisplayConfig {
                show_usage_sections: false,
                show_chart: false,
            }
        } else {
            DEFAULT_DISPLAY_CONFIG
        }
    }

    fn update_rate_limit_resets(&mut self, current: &RateLimitSnapshotEvent) {
        let now = Utc::now();
        if let Some(secs) = current.primary_reset_after_seconds {
            self.rate_limit_primary_next_reset_at =
                Some(now + ChronoDuration::seconds(secs as i64));
        } else {
            self.rate_limit_primary_next_reset_at = None;
        }
        if let Some(secs) = current.secondary_reset_after_seconds {
            self.rate_limit_secondary_next_reset_at =
                Some(now + ChronoDuration::seconds(secs as i64));
        } else {
            self.rate_limit_secondary_next_reset_at = None;
        }
        self.maybe_schedule_rate_limit_refresh();
    }

    fn maybe_schedule_rate_limit_refresh(&mut self) {
        let Some(reset_at) = self.rate_limit_secondary_next_reset_at else {
            self.rate_limit_refresh_scheduled_for = None;
            self.rate_limit_refresh_schedule_id.fetch_add(1, Ordering::SeqCst);
            return;
        };

        if self.rate_limit_refresh_scheduled_for == Some(reset_at) {
            return;
        }

        self.rate_limit_refresh_scheduled_for = Some(reset_at);
        let schedule_id = self
            .rate_limit_refresh_schedule_id
            .fetch_add(1, Ordering::SeqCst)
            .saturating_add(1);
        let schedule_token = self.rate_limit_refresh_schedule_id.clone();
        let app_event_tx = self.app_event_tx.clone();
        let config = self.config.clone();
        let debug_enabled = self.config.debug;
        let account = auth_accounts::get_active_account_id(&config.code_home)
            .ok()
            .flatten()
            .and_then(|id| auth_accounts::find_account(&config.code_home, &id).ok())
            .flatten();

        if account.is_none() {
            return;
        }

        if thread_spawner::spawn_lightweight("rate-reset-refresh", move || {
            let now = Utc::now();
            let delay = reset_at.signed_duration_since(now) + ChronoDuration::seconds(1);
            if let Ok(delay) = delay.to_std() {
                if !delay.is_zero() {
                    std::thread::sleep(delay);
                }
            }

            if schedule_token.load(Ordering::SeqCst) != schedule_id {
                return;
            }

            let Some(account) = account else {
                return;
            };

            let plan = account
                .tokens
                .as_ref()
                .and_then(|tokens| tokens.id_token.get_chatgpt_plan_type());
            let should_refresh = account_usage::mark_rate_limit_refresh_attempt_if_due(
                &config.code_home,
                &account.id,
                plan.as_deref(),
                Some(reset_at),
                Utc::now(),
                account_usage::rate_limit_refresh_stale_interval(),
            )
            .unwrap_or(false);

            if should_refresh {
                start_rate_limit_refresh_for_account(
                    app_event_tx,
                    config,
                    debug_enabled,
                    account,
                    true,
                    false,
                );
            }
        })
        .is_none()
        {
            tracing::warn!("rate reset refresh scheduling failed: worker unavailable");
        }
    }

    pub(crate) fn handle_update_command(&mut self, command_args: &str) {
        let trimmed = command_args.trim();
        if trimmed.eq_ignore_ascii_case("settings")
            || trimmed.eq_ignore_ascii_case("ui")
            || trimmed.eq_ignore_ascii_case("config")
        {
            self.ensure_updates_settings_overlay();
            return;
        }

        // Always surface the update settings overlay before kicking off any upgrade flow.
        self.ensure_updates_settings_overlay();

        if !crate::updates::upgrade_ui_enabled() {
            return;
        }

        match crate::updates::resolve_upgrade_resolution() {
            crate::updates::UpgradeResolution::Command { command, display } => {
                if command.is_empty() {
                    self.history_push_plain_state(history_cell::new_error_event(
                        "`/update` — no upgrade command available for this install.".to_string(),
                    ));
                    self.request_redraw();
                    return;
                }

                let latest = self.latest_upgrade_version.clone();
                self.push_background_tail(
                    "Opening a guided upgrade terminal to finish installing updates.".to_string(),
                );
                if let Some(launch) = self.launch_update_command(command, display, latest) {
                    self.app_event_tx.send(AppEvent::OpenTerminal(launch));
                }
            }
            crate::updates::UpgradeResolution::Manual { instructions } => {
                self.push_background_tail(instructions);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn handle_notifications_command(&mut self, args: String) {
        let trimmed = args.trim();
        if trimmed.is_empty() {
            self.show_settings_overlay(Some(SettingsSection::Notifications));
            return;
        }

        let keyword = trimmed.split_whitespace().next().unwrap_or("").to_ascii_lowercase();
        match keyword.as_str() {
            "status" => {
                match &self.config.tui.notifications {
                    Notifications::Enabled(true) => {
                        self.push_background_tail("🔔 TUI notifications are enabled.".to_string());
                    }
                    Notifications::Enabled(false) => {
                        self.push_background_tail("🔕 TUI notifications are disabled.".to_string());
                    }
                    Notifications::Custom(entries) => {
                        let filters = if entries.is_empty() {
                            "<none>".to_string()
                        } else {
                            entries.join(", ")
                        };
                        self.push_background_tail(format!(
                            "🔔 TUI notifications use custom filters: [{}]",
                            filters
                        ));
                    }
                }
            }
            "on" | "off" => {
                let enable = keyword == "on";
                match &self.config.tui.notifications {
                    Notifications::Enabled(current) => {
                        if *current == enable {
                            self.push_background_tail(format!(
                                "TUI notifications already {}.",
                                if enable { "enabled" } else { "disabled" }
                            ));
                        } else {
                            self.app_event_tx
                                .send(AppEvent::UpdateTuiNotifications(enable));
                        }
                    }
                    Notifications::Custom(entries) => {
                        let filters = if entries.is_empty() {
                            "<none>".to_string()
                        } else {
                            entries.join(", ")
                        };
                        self.push_background_tail(format!(
                            "TUI notifications use custom filters ([{}]); edit ~/.code/config.toml to change them.",
                            filters
                        ));
                    }
                }
            }
            _ => {
                self.push_background_tail(
                    "Usage: /notifications [status|on|off]".to_string(),
                );
            }
        }
    }

    pub(crate) fn handle_prompts_command(&mut self, args: &str) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /prompts".to_string(),
            ));
            return;
        }

        self.submit_op(Op::ListCustomPrompts);
        self.show_settings_overlay(Some(SettingsSection::Prompts));
    }

    pub(crate) fn handle_skills_command(&mut self, args: &str) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /skills".to_string(),
            ));
            return;
        }

        self.submit_op(Op::ListSkills);
        self.show_settings_overlay(Some(SettingsSection::Skills));
    }

    #[allow(dead_code)]
    pub(crate) fn add_agents_output(&mut self) {
        use ratatui::text::Line;

        // Gather active agents from current UI state
        let mut lines: Vec<Line<'static>> = Vec::new();
        lines.push(Line::from("/agents").fg(crate::colors::keyword()));
        lines.push(Line::from(""));
        // Show current subagent command configuration summary
        lines.push(Line::from("Subagents configuration".bold()));
        if self.config.subagent_commands.is_empty() {
            lines.push(Line::from(
                "  • No subagent commands in config (using defaults)",
            ));
        } else {
            for cmd in &self.config.subagent_commands {
                let mode = if cmd.read_only { "read-only" } else { "write" };
                let agents = if cmd.agents.is_empty() {
                    "<inherit>".to_string()
                } else {
                    cmd.agents.join(", ")
                };
                lines.push(Line::from(format!(
                    "  • {} — {} — [{}]",
                    cmd.name, mode, agents
                )));
            }
        }
        lines.push(Line::from(""));
        lines.push(Line::from("Manage in the overlay:".bold()));
        lines.push(Line::from(
            "  /agents  — configure agents (↑↓ navigate • Enter edit • Esc back)"
                .fg(crate::colors::text_dim()),
        ));
        lines.push(Line::from(""));

        // Platform + environment summary to aid debugging
        lines.push(Line::from(vec!["🖥  ".into(), "Environment".bold()]));
        let os = std::env::consts::OS;
        let arch = std::env::consts::ARCH;
        lines.push(Line::from(format!("  • Platform: {os}-{arch}")));
        lines.push(Line::from(format!(
            "  • CWD: {}",
            self.config.cwd.display()
        )));
        let in_git = code_core::git_info::get_git_repo_root(&self.config.cwd).is_some();
        lines.push(Line::from(format!(
            "  • Git repo: {}",
            if in_git { "yes" } else { "no" }
        )));
        // PATH summary
        if let Some(path_os) = std::env::var_os("PATH") {
            let entries: Vec<String> = std::env::split_paths(&path_os)
                .map(|p| p.display().to_string())
                .collect();
            let shown = entries
                .iter()
                .take(6)
                .cloned()
                .collect::<Vec<_>>()
                .join("; ");
            let suffix = if entries.len() > 6 {
                format!(" (+{} more)", entries.len() - 6)
            } else {
                String::new()
            };
            lines.push(Line::from(format!(
                "  • PATH ({} entries): {}{}",
                entries.len(),
                shown,
                suffix
            )));
        }
        #[cfg(target_os = "windows")]
        if let Ok(pathext) = std::env::var("PATHEXT") {
            lines.push(Line::from(format!("  • PATHEXT: {}", pathext)));
        }
        lines.push(Line::from(""));

        // Section: Active agents
        lines.push(Line::from(vec!["🤖 ".into(), "Active Agents".bold()]));
        if self.active_agents.is_empty() {
            if self.agents_ready_to_start {
                lines.push(Line::from("  • preparing agents…"));
            } else {
                lines.push(Line::from("  • No active agents"));
            }
        } else {
            for a in &self.active_agents {
                let status = match a.status {
                    AgentStatus::Pending => "pending",
                    AgentStatus::Running => "running",
                    AgentStatus::Completed => "completed",
                    AgentStatus::Failed => "failed",
                    AgentStatus::Cancelled => "cancelled",
                };
                lines.push(Line::from(format!("  • {} — {}", a.name, status)));
            }
        }

        lines.push(Line::from(""));

        // Section: Availability
        lines.push(Line::from(vec!["🧭 ".into(), "Availability".bold()]));

        // Determine which agents to check: configured (enabled) or defaults
        let mut to_check: Vec<(String, String, bool)> = Vec::new();
        if !self.config.agents.is_empty() {
            for a in &self.config.agents {
                if !a.enabled {
                    continue;
                }
                let name = a.name.clone();
                let cmd = if let Some(spec) = agent_model_spec(&a.name) {
                    spec.cli.to_string()
                } else {
                    a.command.clone()
                };
                let builtin = matches!(cmd.as_str(), "code" | "codex" | "cloud");
                to_check.push((name, cmd, builtin));
            }
        } else {
            for spec in enabled_agent_model_specs() {
                let name = spec.slug.to_string();
                let cmd = spec.cli.to_string();
                let builtin = matches!(spec.cli, "code" | "codex" | "cloud");
                to_check.push((name, cmd, builtin));
            }
        }

        // Helper: PATH presence + resolved path
        let resolve_cmd = |cmd: &str| -> Option<String> {
            which::which(cmd).ok().map(|p| p.display().to_string())
        };

        for (name, cmd, builtin) in to_check {
            if builtin {
                let exe = std::env::current_exe()
                    .ok()
                    .map(|p| p.display().to_string())
                    .unwrap_or_else(|| "(unknown)".to_string());
                lines.push(Line::from(format!(
                    "  • {} — available (built-in, exe: {})",
                    name, exe
                )));
            } else if let Some(path) = resolve_cmd(&cmd) {
                lines.push(Line::from(format!(
                    "  • {} — available ({} at {})",
                    name, cmd, path
                )));
            } else {
                lines.push(Line::from(format!(
                    "  • {} — not found (command: {})",
                    name, cmd
                )));
                // Short cross-platform hint
                lines.push(Line::from(
                    "      Debug: ensure the CLI is installed and on PATH",
                ));
                lines.push(Line::from(
                    "      Windows: run `where <cmd>`; macOS/Linux: `which <cmd>`",
                ));
            }
        }

        let state = history_cell::plain_message_state_from_lines(
            lines,
            crate::history_cell::HistoryCellType::Notice,
        );
        self.history_push_plain_state(state);
        self.request_redraw();
    }

    pub(crate) fn handle_agents_command(&mut self, args: String) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /agents".to_string(),
            ));
        }
        self.show_settings_overlay(Some(SettingsSection::Agents));
    }

    pub(crate) fn handle_limits_command(&mut self, args: String) {
        if !args.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Usage: /limits".to_string(),
            ));
        }
        self.show_settings_overlay(Some(SettingsSection::Limits));
    }

    pub(crate) fn handle_login_command(&mut self) {
        self.show_login_accounts_view();
    }

    pub(crate) fn auth_manager(&self) -> Arc<AuthManager> {
        self.auth_manager.clone()
    }

    pub(crate) fn reload_auth(&self) -> bool {
        self.auth_manager.reload()
    }

    pub(crate) fn show_login_accounts_view(&mut self) {
        let ticket = self.make_background_tail_ticket();
        let (view, state_rc) = LoginAccountsView::new(
            self.config.code_home.clone(),
            self.app_event_tx.clone(),
            ticket,
        );
        self.login_view_state = Some(LoginAccountsState::weak_handle(&state_rc));
        self.login_add_view_state = None;
        self.bottom_pane.show_login_accounts(view);
        self.request_redraw();
    }

    pub(crate) fn show_login_add_account_view(&mut self) {
        let ticket = self.make_background_tail_ticket();
        let (view, state_rc) = LoginAddAccountView::new(
            self.config.code_home.clone(),
            self.app_event_tx.clone(),
            ticket,
        );
        self.login_add_view_state = Some(LoginAddAccountState::weak_handle(&state_rc));
        self.login_view_state = None;
        self.bottom_pane.show_login_add_account(view);
        self.request_redraw();
    }

    fn with_login_add_view<F>(&mut self, f: F) -> bool
    where
        F: FnOnce(&mut LoginAddAccountState),
    {
        if let Some(weak) = &self.login_add_view_state {
            if let Some(state_rc) = weak.upgrade() {
                f(&mut state_rc.borrow_mut());
                self.request_redraw();
                return true;
            }
        }
        false
    }

    pub(crate) fn notify_login_chatgpt_started(&mut self, auth_url: String) {
        if self.with_login_add_view(|state| state.acknowledge_chatgpt_started(auth_url.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_chatgpt_failed(&mut self, error: String) {
        if self.with_login_add_view(|state| state.acknowledge_chatgpt_failed(error.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_chatgpt_complete(&mut self, result: Result<(), String>) {
        if self.with_login_add_view(|state| state.on_chatgpt_complete(result.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_device_code_pending(&mut self) {
        let _ = self.with_login_add_view(|state| state.begin_device_code_flow());
    }

    pub(crate) fn notify_login_device_code_ready(&mut self, authorize_url: String, user_code: String) {
        let _ = self.with_login_add_view(|state| state.set_device_code_ready(authorize_url.clone(), user_code.clone()));
    }

    pub(crate) fn notify_login_device_code_failed(&mut self, error: String) {
        let _ = self.with_login_add_view(|state| state.on_device_code_failed(error.clone()));
    }

    pub(crate) fn notify_login_device_code_complete(&mut self, result: Result<(), String>) {
        if self.with_login_add_view(|state| state.on_chatgpt_complete(result.clone())) {
            return;
        }
    }

    pub(crate) fn notify_login_flow_cancelled(&mut self) {
        let _ = self.with_login_add_view(|state| state.cancel_active_flow());
    }

    pub(crate) fn login_add_view_active(&self) -> bool {
        self.login_add_view_state
            .as_ref()
            .and_then(|weak| weak.upgrade())
            .is_some()
    }

    pub(crate) fn set_using_chatgpt_auth(&mut self, using: bool) {
        self.config.using_chatgpt_auth = using;
        self.bottom_pane.set_using_chatgpt_auth(using);
    }

    fn spawn_update_refresh(&self, shared_state: std::sync::Arc<std::sync::Mutex<UpdateSharedState>>) {
        let config = self.config.clone();
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            let result = crate::updates::check_for_updates_now(&config).await;
            let mut state = shared_state.lock().expect("update state poisoned");
            match result {
                Ok(info) => {
                    state.checking = false;
                    state.latest_version = info.latest_version;
                    state.error = None;
                }
                Err(err) => {
                    state.checking = false;
                    state.latest_version = None;
                    state.error = Some(err.to_string());
                }
            }
            drop(state);
            let _ = tx.send(AppEvent::RequestRedraw);
        });
    }

    fn prepare_update_settings_view(&mut self) -> Option<UpdateSettingsView> {
        let allow_refresh = crate::updates::upgrade_ui_enabled();

        let shared_state = std::sync::Arc::new(std::sync::Mutex::new(UpdateSharedState {
            checking: allow_refresh,
            latest_version: None,
            error: None,
        }));

        let resolution = crate::updates::resolve_upgrade_resolution();
        let (command, display, instructions) = match &resolution {
            crate::updates::UpgradeResolution::Command { command, display } => (
                Some(command.clone()),
                Some(display.clone()),
                None,
            ),
            crate::updates::UpgradeResolution::Manual { instructions } => {
                (None, None, Some(instructions.clone()))
            }
        };

        let view = UpdateSettingsView::new(
            self.app_event_tx.clone(),
            self.make_background_tail_ticket(),
            code_version::version().to_string(),
            self.config.auto_upgrade_enabled,
            command,
            display,
            instructions,
            shared_state.clone(),
        );

        if allow_refresh {
            self.spawn_update_refresh(shared_state);
        }
        Some(view)
    }

    fn build_updates_settings_content(&mut self) -> Option<UpdatesSettingsContent> {
        self.prepare_update_settings_view()
            .map(UpdatesSettingsContent::new)
    }

    fn build_accounts_settings_content(&self) -> AccountsSettingsContent {
        let view = crate::bottom_pane::AccountSwitchSettingsView::new(
            self.app_event_tx.clone(),
            self.config.auto_switch_accounts_on_rate_limit,
            self.config.api_key_fallback_on_all_accounts_limited,
        );
        AccountsSettingsContent::new(view)
    }

    fn build_validation_settings_content(&mut self) -> ValidationSettingsContent {
        let groups = vec![
            (
                GroupStatus {
                    group: ValidationGroup::Functional,
                    name: "Functional checks",
                },
                self.config.validation.groups.functional,
            ),
            (
                GroupStatus {
                    group: ValidationGroup::Stylistic,
                    name: "Stylistic checks",
                },
                self.config.validation.groups.stylistic,
            ),
        ];

        let tool_rows: Vec<ToolRow> = validation_settings_view::detect_tools()
            .into_iter()
            .map(|status| {
                let group = match status.category {
                    ValidationCategory::Functional => ValidationGroup::Functional,
                    ValidationCategory::Stylistic => ValidationGroup::Stylistic,
                };
                let requested = self.validation_tool_requested(status.name);
                let group_enabled = self.validation_group_enabled(group);
                ToolRow { status, enabled: requested, group_enabled }
            })
            .collect();

        let view = ValidationSettingsView::new(
            groups,
            tool_rows,
            self.app_event_tx.clone(),
        );
        ValidationSettingsContent::new(view)
    }

    fn build_review_settings_content(&mut self) -> ReviewSettingsContent {
        let auto_resolve_enabled = self.config.tui.review_auto_resolve;
        let auto_review_enabled = self.config.tui.auto_review_enabled;
        let attempts = self.configured_auto_resolve_re_reviews();
        let view = ReviewSettingsView::new(
            self.config.review_use_chat_model,
            self.config.review_model.clone(),
            self.config.review_model_reasoning_effort,
            self.config.review_resolve_use_chat_model,
            self.config.review_resolve_model.clone(),
            self.config.review_resolve_model_reasoning_effort,
            auto_resolve_enabled,
            attempts,
            auto_review_enabled,
            self.config.auto_review_use_chat_model,
            self.config.auto_review_model.clone(),
            self.config.auto_review_model_reasoning_effort,
            self.config.auto_review_resolve_use_chat_model,
            self.config.auto_review_resolve_model.clone(),
            self.config.auto_review_resolve_model_reasoning_effort,
            self.config.auto_drive.auto_review_followup_attempts.get(),
            self.app_event_tx.clone(),
        );
        ReviewSettingsContent::new(view)
    }

    fn build_planning_settings_content(&mut self) -> PlanningSettingsContent {
        let view = PlanningSettingsView::new(
            self.config.planning_use_chat_model,
            self.config.planning_model.clone(),
            self.config.planning_model_reasoning_effort,
            self.app_event_tx.clone(),
        );
        PlanningSettingsContent::new(view)
    }

    fn build_auto_drive_settings_content(&mut self) -> AutoDriveSettingsContent {
        let model = self.config.auto_drive.model.clone();
        let model_effort = self.config.auto_drive.model_reasoning_effort;
        let use_chat_model = self.config.auto_drive_use_chat_model;
        let review = self.auto_state.review_enabled;
        let agents = self.auto_state.subagents_enabled;
        let cross = self.auto_state.cross_check_enabled;
        let qa = self.auto_state.qa_automation_enabled;
        let mode = self.auto_state.continue_mode;
        let view = AutoDriveSettingsView::new(
            self.app_event_tx.clone(),
            model,
            model_effort,
            use_chat_model,
            review,
            agents,
            cross,
            qa,
            mode,
        );
        AutoDriveSettingsContent::new(view)
    }

    fn ensure_updates_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::Updates));
            return;
        }
        if let Some(content) = self.build_updates_settings_content() {
            if let Some(overlay) = self.settings.overlay.as_mut() {
                overlay.set_updates_content(content);
            }
        }
        self.ensure_settings_overlay_section(SettingsSection::Updates);
        self.request_redraw();
    }

    fn ensure_validation_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::Validation));
            return;
        }
        let content = self.build_validation_settings_content();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_validation_content(content);
        }
        self.ensure_settings_overlay_section(SettingsSection::Validation);
        self.request_redraw();
    }

    fn ensure_auto_drive_settings_overlay(&mut self) {
        if self.settings.overlay.is_none() {
            self.show_settings_overlay(Some(SettingsSection::AutoDrive));
            return;
        }
        let content = self.build_auto_drive_settings_content();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_auto_drive_content(content);
        }
        self.ensure_settings_overlay_section(SettingsSection::AutoDrive);
        self.request_redraw();
    }

    pub(crate) fn show_agents_overview_ui(&mut self) {
        let (rows, commands) = self.collect_agents_overview_rows();
        let total_rows = rows
            .len()
            .saturating_add(commands.len())
            .saturating_add(AGENTS_OVERVIEW_STATIC_ROWS);
        let selected = if total_rows == 0 {
            0
        } else {
            self
                .agents_overview_selected_index
                .min(total_rows.saturating_sub(1))
        };
        self.agents_overview_selected_index = selected;

        self.ensure_settings_overlay_section(SettingsSection::Agents);

        let updated = self.try_update_agents_settings_overview(
            rows.clone(),
            commands.clone(),
            selected,
        );

        if !updated {
            if let Some(overlay) = self.settings.overlay.as_mut() {
                let content = AgentsSettingsContent::new_overview(
                    rows,
                    commands,
                    selected,
                    self.app_event_tx.clone(),
                );
                overlay.set_agents_content(content);
            }
        }

        self.request_redraw();
    }

    fn try_update_agents_settings_overview(
        &mut self,
        rows: Vec<AgentOverviewRow>,
        commands: Vec<String>,
        selected: usize,
    ) -> bool {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_overview(rows, commands, selected);
                } else {
                    overlay.set_agents_content(AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    ));
                }
                return true;
            }
        }
        false
    }

    fn try_set_agents_settings_editor(&mut self, editor: SubagentEditorView) -> bool {
        let mut editor = Some(editor);
        let mut needs_content = false;

        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_editor(editor.take().expect("editor set once"));
                    self.request_redraw();
                    return true;
                } else {
                    needs_content = true;
                }
            }
        }

        if needs_content {
            let (rows, commands) = self.collect_agents_overview_rows();
            let total = rows
                .len()
                .saturating_add(commands.len())
                .saturating_add(AGENTS_OVERVIEW_STATIC_ROWS);
            let selected = if total == 0 {
                0
            } else {
                self.agents_overview_selected_index.min(total.saturating_sub(1))
            };
            self.agents_overview_selected_index = selected;

            if let Some(overlay) = self.settings.overlay.as_mut() {
                if overlay.active_section() == SettingsSection::Agents {
                    let mut content = AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    );
                    content.set_editor(editor.take().expect("editor set once"));
                    overlay.set_agents_content(content);
                    self.request_redraw();
                    return true;
                }
            }
        }

        false
    }

    fn try_set_agents_settings_agent_editor(&mut self, editor: AgentEditorView) -> bool {
        let mut editor = Some(editor);
        let mut needs_content = false;

        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_agent_editor(editor.take().expect("editor set once"));
                    self.request_redraw();
                    return true;
                } else {
                    needs_content = true;
                }
            }
        }

        if needs_content {
            let (rows, commands) = self.collect_agents_overview_rows();
            let total = rows
                .len()
                .saturating_add(commands.len())
                .saturating_add(AGENTS_OVERVIEW_STATIC_ROWS);
            let selected = if total == 0 {
                0
            } else {
                self.agents_overview_selected_index.min(total.saturating_sub(1))
            };
            self.agents_overview_selected_index = selected;

            if let Some(overlay) = self.settings.overlay.as_mut() {
                if overlay.active_section() == SettingsSection::Agents {
                    let mut content = AgentsSettingsContent::new_overview(
                        rows,
                        commands,
                        selected,
                        self.app_event_tx.clone(),
                    );
                    content.set_agent_editor(editor.take().expect("editor set once"));
                    overlay.set_agents_content(content);
                    self.request_redraw();
                    return true;
                }
            }
        }

        false
    }

    pub(crate) fn set_agents_overview_selection(&mut self, index: usize) {
        self.agents_overview_selected_index = index;
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if overlay.active_section() == SettingsSection::Agents {
                if let Some(content) = overlay.agents_content_mut() {
                    content.set_overview_selection(index);
                }
            }
        }
    }

    fn agent_batch_metadata(&self, batch_id: &str) -> AgentBatchMetadata {
        if let Some(key) = self.tools_state.agent_run_by_batch.get(batch_id) {
            if let Some(tracker) = self.tools_state.agent_runs.get(key) {
                return AgentBatchMetadata {
                    label: tracker.overlay_display_label(),
                    prompt: tracker.overlay_task(),
                    context: tracker.overlay_context(),
                };
            }
        }
        AgentBatchMetadata::default()
    }

    fn append_agents_overlay_section(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
        title: &str,
        text: &str,
    ) {
        let trimmed = text.trim();
        if trimmed.is_empty() {
            return;
        }
        let header_style = ratatui::style::Style::default()
            .fg(crate::colors::text())
            .add_modifier(ratatui::style::Modifier::BOLD);
        lines.push(ratatui::text::Line::from(vec![
            ratatui::text::Span::raw(" "),
            ratatui::text::Span::styled(title.to_string(), header_style),
        ]));
        for raw_line in trimmed.lines() {
            let content = raw_line.trim_end();
            lines.push(ratatui::text::Line::from(vec![
                ratatui::text::Span::raw("   "),
                ratatui::text::Span::styled(
                    content.to_string(),
                    ratatui::style::Style::default().fg(crate::colors::text()),
                ),
            ]));
        }
    }

    fn truncate_overlay_text(&self, text: &str, limit: usize) -> String {
        let collapsed = text
            .split_whitespace()
            .collect::<Vec<_>>()
            .join(" ");
        let normalized = if collapsed.trim().is_empty() {
            text.trim().to_string()
        } else {
            collapsed.trim().to_string()
        };

        if normalized.chars().count() <= limit {
            return normalized;
        }

        let mut out: String = normalized.chars().take(limit.saturating_sub(1)).collect();
        out.push('…');
        out
    }

    fn append_agent_highlights(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
        entry: &AgentTerminalEntry,
        available_width: u16,
        collapsed: bool,
    ) {
        let mut bullets: Vec<(String, ratatui::style::Style)> = Vec::new();

        if matches!(entry.source_kind, Some(AgentSourceKind::AutoReview)) {
            let is_terminal = matches!(
                entry.status,
                AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled
            );

            if is_terminal {
                let (mut has_findings, findings_count, summary) =
                    Self::parse_agent_review_result(entry.result.as_deref());

                // Avoid showing a warning when we didn't get an explicit findings list.
                // Some heuristic parses can claim "issues" but provide a zero count; treat those as clean
                // to keep the UI consistent with successful, issue-free reviews.
                if has_findings && findings_count == 0 {
                    has_findings = false;
                }

                let mut label = if has_findings {
                    let plural = if findings_count == 1 { "issue" } else { "issues" };
                    format!("Auto Review: {findings_count} {plural} found")
                } else if matches!(entry.status, AgentStatus::Completed) {
                    "Auto Review: no issues found".to_string()
                } else {
                    String::new()
                };
                if label.is_empty() {
                    label = "Auto Review".to_string();
                }

                if has_findings || matches!(entry.status, AgentStatus::Completed) {
                    let color = if has_findings {
                        ratatui::style::Style::default().fg(crate::colors::warning())
                    } else {
                        ratatui::style::Style::default().fg(crate::colors::success())
                    };
                    bullets.push((label, color));
                }

                if let Some(summary_text) = summary {
                    for line in summary_text.lines() {
                        let trimmed = line.trim();
                        if trimmed.is_empty() {
                            continue;
                        }
                        bullets.push((
                            self.truncate_overlay_text(trimmed, 280),
                            ratatui::style::Style::default().fg(crate::colors::text_dim()),
                        ));
                    }
                }
            }
        }

        if let Some(result) = entry.result.as_ref() {
            let text = self.truncate_overlay_text(result, 320);
            if !text.is_empty() {
                bullets.push((
                    format!("Final: {text}"),
                    ratatui::style::Style::default().fg(crate::colors::text_dim()),
                ));
            }
        }

        match entry.status {
            AgentStatus::Failed => {
                if entry.error.is_none() {
                    bullets.push((
                        "Failed".to_string(),
                        ratatui::style::Style::default().fg(crate::colors::error()),
                    ));
                }
            }
            AgentStatus::Cancelled => {
                if entry.error.is_none() {
                    bullets.push((
                        "Cancelled".to_string(),
                        ratatui::style::Style::default().fg(crate::colors::warning()),
                    ));
                }
            }
            AgentStatus::Pending | AgentStatus::Running => {
                if bullets.is_empty() {
                    if let Some(progress) = entry.last_progress.as_ref() {
                        let text = self.truncate_overlay_text(progress, 200);
                        if !text.is_empty() {
                            bullets.push((
                                format!("Latest progress: {text}"),
                                ratatui::style::Style::default()
                                    .fg(crate::colors::text_dim()),
                            ));
                        }
                    }
                }
            }
            _ => {}
        }

        let header_style = ratatui::style::Style::default()
            .fg(crate::colors::text())
            .add_modifier(ratatui::style::Modifier::BOLD);
        let chevron = if collapsed { "▶" } else { "▼" };
        let title = format!("╭ Highlights (h) {chevron} ");
        let title_width = unicode_width::UnicodeWidthStr::width(title.as_str()) as u16;
        let pad = available_width
            .saturating_sub(title_width)
            .saturating_sub(1);
        let mut heading = title;
        heading.push_str(&"─".repeat(pad as usize));
        heading.push('╮');
        lines.push(ratatui::text::Line::from(ratatui::text::Span::styled(
            heading,
            header_style,
        )));

        if collapsed || bullets.is_empty() {
            let footer_width = available_width.saturating_sub(1);
            let mut footer = String::from("╰");
            footer.push_str(&"─".repeat(footer_width as usize));
            lines.push(ratatui::text::Line::from(footer));
            self.ensure_trailing_blank_line(lines);
            return;
        }

        let wrap_width = available_width.saturating_sub(6).max(12) as usize;
        for (text, style) in bullets.into_iter() {
            let opts = textwrap::Options::new(wrap_width)
                .break_words(false)
                .word_splitter(textwrap::word_splitters::WordSplitter::NoHyphenation)
                .initial_indent("• ")
                .subsequent_indent("  ");
            for (idx, wrapped) in textwrap::wrap(text.as_str(), opts).into_iter().enumerate() {
                let prefix = if idx == 0 { "│   " } else { "│     " };
                lines.push(ratatui::text::Line::from(vec![
                    ratatui::text::Span::raw(prefix),
                    ratatui::text::Span::styled(wrapped.to_string(), style),
                ]));
            }
        }

        if let Some(error_text) = entry
            .error
            .as_ref()
            .map(|e| self.truncate_overlay_text(e, 320))
        {
            if !error_text.is_empty() {
                let msg = format!("Last error: {error_text}");
                for (idx, wrapped) in textwrap::wrap(msg.as_str(), wrap_width).into_iter().enumerate() {
                    let prefix = if idx == 0 { "│   " } else { "│     " };
                    lines.push(ratatui::text::Line::from(vec![
                        ratatui::text::Span::raw(prefix),
                        ratatui::text::Span::styled(
                            wrapped.to_string(),
                            ratatui::style::Style::default().fg(crate::colors::error()),
                        ),
                    ]));
                }
            }
        }

        let footer_width = available_width.saturating_sub(1);
        let mut footer = String::from("╰");
        footer.push_str(&"─".repeat(footer_width as usize));
        lines.push(ratatui::text::Line::from(footer));
        self.ensure_trailing_blank_line(lines);
    }

    fn append_agent_log_lines(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
        _idx: usize,
        log: &AgentLogEntry,
        available_width: u16,
        is_new_kind: bool,
    ) {
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line, Span};

        let time_text = log.timestamp.format("%H:%M").to_string();
        let time_style = Style::default().fg(crate::colors::text_dim());
        let kind_style = Style::default()
            .fg(agent_log_color(log.kind))
            .add_modifier(Modifier::BOLD);
        let message_base_style = if matches!(log.kind, AgentLogKind::Error) {
            Style::default().fg(crate::colors::error())
        } else {
            Style::default().fg(crate::colors::text())
        };

        // Insert a section header when the log kind changes (TYPE column removed).
        if is_new_kind {
            let header = agent_log_label(log.kind).to_uppercase();
            lines.push(Line::from(vec![Span::styled(header, kind_style)]));
        }

        // Compact prefix: time only, kept short per request.
        let prefix_plain = format!("{time_text}  ");
        let prefix_width = unicode_width::UnicodeWidthStr::width(prefix_plain.as_str()) as u16;
        let wrap_width = available_width.saturating_sub(prefix_width).max(4);

        // Break message into lines, sanitizing and keeping ANSI colors.
        let mut message_lines: Vec<&str> = log.message.split('\n').collect();
        if log.message.ends_with('\n') {
            message_lines.push("");
        }

        for (line_idx, raw_line) in message_lines.into_iter().enumerate() {
            let sanitized = self.sanitize_agent_log_line(raw_line);
            let parsed = ansi_escape_line(&sanitized);
            let wrapped = crate::insert_history::word_wrap_lines(&[self.apply_log_fallback_style(parsed, message_base_style)], wrap_width);

            for (wrap_idx, wrapped_line) in wrapped.into_iter().enumerate() {
                let mut spans: Vec<Span> = Vec::new();
                if wrap_idx == 0 && line_idx == 0 {
                    // First visible line: show time prefix.
                    spans.push(Span::styled(time_text.clone(), time_style));
                    spans.push(Span::raw("  "));
                } else {
                    // Continuation lines align under the message body.
                    spans.push(Span::raw(" ".repeat(prefix_width as usize)));
                }

                if wrapped_line.spans.is_empty() {
                    spans.push(Span::raw(""));
                } else {
                    spans.extend(wrapped_line.spans.into_iter());
                }

                lines.push(Line::from(spans));
            }

        }
    }

    fn sanitize_agent_log_line(&self, raw: &str) -> String {
        let without_ts = Self::strip_leading_timestamp(raw.trim_end_matches('\r'));
        sanitize_for_tui(
            without_ts,
            SanitizeMode::AnsiPreserving,
            SanitizeOptions {
                expand_tabs: true,
                tabstop: 4,
                ..Default::default()
            },
        )
    }

    fn apply_log_fallback_style(
        &self,
        mut line: ratatui::text::Line<'static>,
        base: ratatui::style::Style,
    ) -> ratatui::text::Line<'static> {
        for span in line.spans.iter_mut() {
            span.style = base.patch(span.style);
        }
        line
    }

    fn strip_leading_timestamp<'a>(text: &'a str) -> &'a str {
        fn is_digit(b: u8) -> bool { b.is_ascii_digit() }

        fn consume_hms(bytes: &[u8]) -> usize {
            if bytes.len() < 5 {
                return 0;
            }
            if !(is_digit(bytes[0]) && is_digit(bytes[1]) && bytes[2] == b':' && is_digit(bytes[3]) && is_digit(bytes[4])) {
                return 0;
            }
            let mut idx = 5;
            if idx + 2 < bytes.len() && bytes[idx] == b':' && is_digit(bytes[idx + 1]) && is_digit(bytes[idx + 2]) {
                idx += 3;
                while idx < bytes.len() && (bytes[idx].is_ascii_digit() || bytes[idx] == b'.') {
                    idx += 1;
                }
            }
            idx
        }

        fn consume_ymd(bytes: &[u8]) -> usize {
            if bytes.len() < 10 {
                return 0;
            }
            if !(is_digit(bytes[0])
                && is_digit(bytes[1])
                && is_digit(bytes[2])
                && is_digit(bytes[3])
                && bytes[4] == b'-'
                && is_digit(bytes[5])
                && is_digit(bytes[6])
                && bytes[7] == b'-'
                && is_digit(bytes[8])
                && is_digit(bytes[9]))
            {
                return 0;
            }
            let mut idx = 10;
            if idx < bytes.len() && (bytes[idx] == b'T' || bytes[idx] == b' ') {
                idx += 1;
                idx += consume_hms(&bytes[idx..]);
            }
            idx
        }

        let trimmed = text.trim_start();
        let mut candidate = trimmed.strip_prefix('[').unwrap_or(trimmed);
        let bytes = candidate.as_bytes();

        let mut consumed = consume_ymd(bytes);
        if consumed == 0 {
            consumed = consume_hms(bytes);
        }

        if consumed == 0 {
            return text;
        }

        candidate = &candidate[consumed..];
        if let Some(rest) = candidate.strip_prefix(']') {
            candidate = rest;
        }
        candidate.trim_start()
    }

    fn ensure_trailing_blank_line(
        &self,
        lines: &mut Vec<ratatui::text::Line<'static>>,
    ) {
        if lines
            .last()
            .map(|line| {
                line.spans.is_empty()
                    || (line.spans.len() == 1 && line.spans[0].content.is_empty())
            })
            .unwrap_or(false)
        {
            return;
        }
        lines.push(ratatui::text::Line::from(""));
    }

    fn update_agents_terminal_state(
        &mut self,
        agents: &[code_core::protocol::AgentInfo],
        context: Option<String>,
        task: Option<String>,
    ) {
        self.agents_terminal.shared_context = context;
        self.agents_terminal.shared_task = task;

        let mut saw_new_agent = false;
        for info in agents {
            let status = agent_status_from_str(info.status.as_str());
            let batch_metadata = info
                .batch_id
                .as_deref()
                .map(|id| self.agent_batch_metadata(id))
                .unwrap_or_default();
            let is_new = !self.agents_terminal.entries.contains_key(&info.id);
            if is_new
                && !self
                    .agents_terminal
                    .order
                    .iter()
                    .any(|id| id == &info.id)
            {
                self.agents_terminal.order.push(info.id.clone());
                saw_new_agent = true;
            }

            let entry = self.agents_terminal.entries.entry(info.id.clone());
            let entry = entry.or_insert_with(|| {
                saw_new_agent = true;
                let mut new_entry = AgentTerminalEntry::new(
                    info.name.clone(),
                    info.model.clone(),
                    status.clone(),
                    info.batch_id.clone(),
                );
                new_entry.source_kind = info.source_kind.clone();
                new_entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(status.clone())),
                );
                new_entry
            });

            entry.name = info.name.clone();
            entry.batch_id = info.batch_id.clone();
            entry.model = info.model.clone();
            entry.source_kind = info.source_kind.clone();

            let AgentBatchMetadata { label, prompt: meta_prompt, context: meta_context } = batch_metadata;
            let auto_review_label = matches!(entry.source_kind, Some(AgentSourceKind::AutoReview))
                .then(|| "Auto Review".to_string());
            let previous_label = entry.batch_label.clone();
            entry.batch_label = label
                .or(auto_review_label)
                .or_else(|| info.batch_id.clone())
                .or(previous_label);

            let fallback_prompt = self
                .agents_terminal
                .shared_task
                .clone()
                .or_else(|| self.agent_task.clone());
            let previous_prompt = entry.batch_prompt.clone();
            entry.batch_prompt = meta_prompt
                .or(fallback_prompt)
                .or(previous_prompt);

            let fallback_context = self
                .agents_terminal
                .shared_context
                .clone()
                .or_else(|| self.agent_context.clone());
            let previous_context = entry.batch_context.clone();
            entry.batch_context = meta_context
                .or(fallback_context)
                .or(previous_context);

            if entry.status != status {
                entry.status = status.clone();
                entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(status.clone())),
                );
            }

            if let Some(progress) = info.last_progress.as_ref() {
                if entry.last_progress.as_ref() != Some(progress) {
                    entry.last_progress = Some(progress.clone());
                    entry.push_log(AgentLogKind::Progress, progress.clone());
                }
            }

            if let Some(result) = info.result.as_ref() {
                if entry.result.as_ref() != Some(result) {
                    entry.result = Some(result.clone());
                    entry.push_log(AgentLogKind::Result, result.clone());
                }
            }

            if let Some(error) = info.error.as_ref() {
                if entry.error.as_ref() != Some(error) {
                    entry.error = Some(error.clone());
                    entry.push_log(AgentLogKind::Error, error.clone());
                }
            }
        }

        if let Some(pending) = self.agents_terminal.pending_stop.clone() {
            let still_running = self
                .agents_terminal
                .entries
                .get(&pending.agent_id)
                .map(|entry| matches!(entry.status, AgentStatus::Pending | AgentStatus::Running))
                .unwrap_or(false);
            if !still_running {
                self.agents_terminal.clear_stop_prompt();
            }
        }

        self.agents_terminal.clamp_selected_index();

        if saw_new_agent && self.agents_terminal.active {
            self.layout.scroll_offset = 0;
        }
    }

    fn enter_agents_terminal_mode(&mut self) {
        if self.agents_terminal.active {
            return;
        }
        self.browser_overlay_visible = false;
        self.agents_terminal.active = true;
        self.agents_terminal.focus_sidebar();
        self.agents_terminal.clear_stop_prompt();
        self.bottom_pane.set_input_focus(false);
        self.agents_terminal.saved_scroll_offset = self.layout.scroll_offset;
        if self.agents_terminal.order.is_empty() {
            for agent in &self.active_agents {
                if !self
                    .agents_terminal
                    .entries
                    .contains_key(&agent.id)
                {
                    self.agents_terminal.order.push(agent.id.clone());
                    let mut entry = AgentTerminalEntry::new(
                        agent.name.clone(),
                        agent.model.clone(),
                        agent.status.clone(),
                        agent.batch_id.clone(),
                    );
                    let batch_metadata = agent
                        .batch_id
                        .as_deref()
                        .map(|id| self.agent_batch_metadata(id))
                        .unwrap_or_default();
                    let AgentBatchMetadata { label, prompt: meta_prompt, context: meta_context } = batch_metadata;
                    entry.batch_label = label
                        .or_else(|| agent.batch_id.clone())
                        .or(entry.batch_label.clone());
                    let fallback_prompt = self
                        .agents_terminal
                        .shared_task
                        .clone()
                        .or_else(|| self.agent_task.clone());
                    entry.batch_prompt = meta_prompt
                        .or(fallback_prompt)
                        .or(entry.batch_prompt.clone());
                    let fallback_context = self
                        .agents_terminal
                        .shared_context
                        .clone()
                        .or_else(|| self.agent_context.clone());
                    entry.batch_context = meta_context
                        .or(fallback_context)
                        .or(entry.batch_context.clone());
                    if let Some(progress) = agent.last_progress.as_ref() {
                        entry.last_progress = Some(progress.clone());
                        entry.push_log(AgentLogKind::Progress, progress.clone());
                    }
                    if let Some(result) = agent.result.as_ref() {
                        entry.result = Some(result.clone());
                        entry.push_log(AgentLogKind::Result, result.clone());
                    }
                    if let Some(error) = agent.error.as_ref() {
                        entry.error = Some(error.clone());
                        entry.push_log(AgentLogKind::Error, error.clone());
                    }
                    self.agents_terminal
                        .entries
                        .insert(agent.id.clone(), entry);
                }
            }
        }
        self.agents_terminal.clamp_selected_index();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }

    fn exit_agents_terminal_mode(&mut self) {
        if !self.agents_terminal.active {
            return;
        }
        self.record_current_agent_scroll();
        self.agents_terminal.active = false;
        self.agents_terminal.clear_stop_prompt();
        self.agents_terminal.focus_sidebar();
        self.layout.scroll_offset = self.agents_terminal.saved_scroll_offset;
        self.bottom_pane.set_input_focus(true);
        self.request_redraw();
    }

    fn record_current_agent_scroll(&mut self) {
        if let Some(entry) = self.agents_terminal.current_sidebar_entry() {
            let capped = self.layout.scroll_offset.min(self.layout.last_max_scroll.get());
            self
                .agents_terminal
                .scroll_offsets
                .insert(entry.scroll_key(), capped);
        }
    }

    fn restore_selected_agent_scroll(&mut self) {
        if let Some(entry) = self.agents_terminal.current_sidebar_entry() {
            // Always reset to the top when switching agents; use a sentinel so the
            // next render clamps to the new agent's maximum scroll.
            let key = entry.scroll_key();
            self
                .agents_terminal
                .scroll_offsets
                .insert(key, u16::MAX);
            self.layout.scroll_offset = u16::MAX;
        } else {
            self.layout.scroll_offset = 0;
        }
    }

    fn sync_agents_terminal_scroll(&mut self) {
        if !self.agents_terminal.active {
            return;
        }
        let applied = self
            .agents_terminal
            .last_render_scroll
            .get()
            .min(self.layout.last_max_scroll.get());
        self.layout.scroll_offset = applied;
        if let Some(entry) = self.agents_terminal.current_sidebar_entry() {
            self
                .agents_terminal
                .scroll_offsets
                .insert(entry.scroll_key(), applied);
        }
    }

    fn prompt_stop_selected_agent(&mut self) {
        let Some(AgentsSidebarEntry::Agent(agent_id)) = self.agents_terminal.current_sidebar_entry() else {
            return;
        };

        let is_active = self
            .active_agents
            .iter()
            .any(|agent| agent.id == agent_id && matches!(agent.status, AgentStatus::Pending | AgentStatus::Running));
        let is_entry_active = self
            .agents_terminal
            .entries
            .get(agent_id.as_str())
            .map(|entry| matches!(entry.status, AgentStatus::Pending | AgentStatus::Running))
            .unwrap_or(false);

        if !(is_active || is_entry_active) {
            return;
        }

        let agent_name = self
            .agents_terminal
            .entries
            .get(agent_id.as_str())
            .map(|entry| entry.name.clone())
            .or_else(|| {
                self.active_agents
                    .iter()
                    .find(|a| a.id == agent_id)
                    .map(|a| a.name.clone())
            })
            .unwrap_or_else(|| agent_id.clone());

        self.agents_terminal
            .set_stop_prompt(agent_id.clone(), agent_name);
        self.request_redraw();
    }

    fn cancel_agent_by_id(&mut self, agent_id: &str) -> bool {
        let mut can_cancel = false;
        for agent in &self.active_agents {
            if agent.id == agent_id
                && matches!(agent.status, AgentStatus::Pending | AgentStatus::Running)
            {
                can_cancel = true;
                break;
            }
        }

        if !can_cancel {
            can_cancel = self
                .agents_terminal
                .entries
                .get(agent_id)
                .map(|entry| matches!(entry.status, AgentStatus::Pending | AgentStatus::Running))
                .unwrap_or(false);
        }

        if !can_cancel {
            return false;
        }

        let agent_name = self
            .agents_terminal
            .entries
            .get(agent_id)
            .map(|entry| entry.name.clone())
            .or_else(|| {
                self.active_agents
                    .iter()
                    .find(|a| a.id == agent_id)
                    .map(|a| a.name.clone())
            })
            .unwrap_or_else(|| agent_id.to_string());

        self.push_background_tail(format!("Cancelling agent {agent_name}…"));
        self.bottom_pane
            .update_status_text(format!("Cancelling {agent_name}…"));
        self.bottom_pane.set_task_running(true);
        self.agents_ready_to_start = false;

        self.submit_op(Op::CancelAgents {
            batch_ids: Vec::new(),
            agent_ids: vec![agent_id.to_string()],
        });

        for agent in &mut self.active_agents {
            if agent.id == agent_id
                && matches!(agent.status, AgentStatus::Pending | AgentStatus::Running)
            {
                agent.status = AgentStatus::Cancelled;
                agent.error.get_or_insert_with(|| "Cancelled by user".to_string());
            }
        }

        if let Some(entry) = self.agents_terminal.entries.get_mut(agent_id) {
            if matches!(entry.status, AgentStatus::Pending | AgentStatus::Running) {
                entry.status = AgentStatus::Cancelled;
                entry.push_log(
                    AgentLogKind::Status,
                    format!("Status → {}", agent_status_label(AgentStatus::Cancelled)),
                );
            }
        }

        self.request_redraw();
        true
    }

    fn navigate_agents_terminal_selection(&mut self, delta: isize) {
        let entries = self.agents_terminal.sidebar_entries();
        if entries.is_empty() {
            return;
        }
        self.agents_terminal.focus_sidebar();
        let len = entries.len() as isize;
        self.record_current_agent_scroll();
        let mut new_index = self.agents_terminal.selected_index as isize + delta;
        if new_index >= len {
            new_index %= len;
        }
        while new_index < 0 {
            new_index += len;
        }
        self.agents_terminal.selected_index = new_index as usize;
        self.agents_terminal.clamp_selected_index();
        self.agents_terminal.clear_stop_prompt();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }

    fn navigate_agents_terminal_page(&mut self, delta_pages: isize) {
        let entries = self.agents_terminal.sidebar_entries();
        if entries.is_empty() {
            return;
        }
        let page = self.layout.last_history_viewport_height.get() as isize;
        let step = if page > 0 { page.saturating_sub(1) } else { 1 };
        let delta = step.max(1) * delta_pages;
        self.navigate_agents_terminal_selection(delta);
    }

    fn navigate_agents_terminal_home(&mut self) {
        let entries = self.agents_terminal.sidebar_entries();
        if entries.is_empty() {
            return;
        }
        self.agents_terminal.selected_index = 0;
        self.agents_terminal.clamp_selected_index();
        self.agents_terminal.clear_stop_prompt();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }

    fn navigate_agents_terminal_end(&mut self) {
        let entries = self.agents_terminal.sidebar_entries();
        if entries.is_empty() {
            return;
        }
        self.agents_terminal.selected_index = entries.len().saturating_sub(1);
        self.agents_terminal.clamp_selected_index();
        self.agents_terminal.clear_stop_prompt();
        self.restore_selected_agent_scroll();
        self.request_redraw();
    }
    fn resolve_agent_install_command(&self, agent_name: &str) -> Option<(Vec<String>, String)> {
        let cmd = self
            .config
            .agents
            .iter()
            .find(|a| a.name.eq_ignore_ascii_case(agent_name))
            .map(|cfg| cfg.command.clone())
            .filter(|s| !s.trim().is_empty())
            .unwrap_or_else(|| agent_name.to_string());
        if cmd.trim().is_empty() {
            return None;
        }

        #[cfg(target_os = "windows")]
        {
            let script = format!(
                "if (Get-Command {cmd} -ErrorAction SilentlyContinue) {{ Write-Output \"{cmd} already installed\"; exit 0 }} else {{ Write-Warning \"{cmd} is not installed.\"; Write-Output \"Please install {cmd} via winget, Chocolatey, or the vendor installer.\"; exit 1 }}",
                cmd = cmd
            );
            let command = vec![
                "powershell.exe".to_string(),
                "-NoProfile".to_string(),
                "-ExecutionPolicy".to_string(),
                "Bypass".to_string(),
                "-Command".to_string(),
                script.clone(),
            ];
            return Some((command, format!("PowerShell install check for {cmd}")));
        }

        #[cfg(target_os = "macos")]
        {
            let brew_formula = macos_brew_formula_for_command(&cmd);
            let script = format!("brew install {brew_formula}");
            let command = vec!["/bin/bash".to_string(), "-lc".to_string(), script.clone()];
            return Some((command, script));
        }

        #[cfg(not(any(target_os = "windows", target_os = "macos")))]
        {
            fn linux_agent_install_script(agent_cmd: &str, npm_package: &str) -> String {
                format!(
                    "set -euo pipefail\n\
if ! command -v npm >/dev/null 2>&1; then\n\
    echo \"npm is required to install {agent_cmd}. Install Node.js 20+ and rerun.\" >&2\n\
    exit 1\n\
fi\n\
prefix=\"$(npm config get prefix 2>/dev/null || true)\"\n\
if [ -z \"$prefix\" ] || [ ! -w \"$prefix\" ]; then\n\
    prefix=\"$HOME/.npm-global\"\n\
fi\n\
mkdir -p \"$prefix/bin\"\n\
export PATH=\"$prefix/bin:$PATH\"\n\
export npm_config_prefix=\"$prefix\"\n\
node_major=0\n\
if command -v node >/dev/null 2>&1; then\n\
    node_major=\"$(node -v | sed 's/^v\\([0-9][0-9]*\\).*/\\1/')\"\n\
fi\n\
if [ \"$node_major\" -lt 20 ]; then\n\
    npm install -g n\n\
    export N_PREFIX=\"${{N_PREFIX:-$HOME/.n}}\"\n\
    mkdir -p \"$N_PREFIX/bin\"\n\
    export PATH=\"$N_PREFIX/bin:$PATH\"\n\
    n 20.18.1\n\
    hash -r\n\
    node_major=\"$(node -v | sed 's/^v\\([0-9][0-9]*\\).*/\\1/')\"\n\
    if [ \"$node_major\" -lt 20 ]; then\n\
        echo \"Failed to activate Node.js 20+. Check that $N_PREFIX/bin is on PATH.\" >&2\n\
        exit 1\n\
    fi\n\
else\n\
    export N_PREFIX=\"${{N_PREFIX:-$HOME/.n}}\"\n\
    if [ -d \"$N_PREFIX/bin\" ]; then\n\
        export PATH=\"$N_PREFIX/bin:$PATH\"\n\
    fi\n\
fi\n\
npm install -g {npm_package}\n\
hash -r\n\
if ! command -v {agent_cmd} >/dev/null 2>&1; then\n\
    echo \"{agent_cmd} installed but not found on PATH. Add 'export PATH=\\\"$prefix/bin:$PATH\\\"' to your shell profile.\" >&2\n\
    exit 1\n\
fi\n\
{agent_cmd} --version\n",
                    agent_cmd = agent_cmd,
                    npm_package = npm_package,
                )
            }

            let lowercase = agent_name.trim().to_ascii_lowercase();
            let script = match lowercase.as_str() {
                "claude" => linux_agent_install_script(&cmd, "@anthropic-ai/claude-code"),
                "gemini" => linux_agent_install_script(&cmd, "@google/gemini-cli"),
                "qwen" => linux_agent_install_script(&cmd, "@qwen-code/qwen-code"),
                _ => format!(
                    "{cmd} --version || (echo \"Please install {cmd} via your package manager\" && false)",
                    cmd = cmd
                ),
            };
            let command = vec!["/bin/bash".to_string(), "-lc".to_string(), script.clone()];
            return Some((command, script));
        }

        #[allow(unreachable_code)]
        {
            None
        }
    }

    pub(crate) fn launch_agent_install(
        &mut self,
        name: String,
        selected_index: usize,
    ) -> Option<TerminalLaunch> {
        self.agents_overview_selected_index = selected_index;
        let Some((_, default_command)) = self.resolve_agent_install_command(&name) else {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "No install command available for agent '{name}' on this platform."
            )));
            self.show_agents_overview_ui();
            return None;
        };
        let id = self.terminal.alloc_id();
        self.terminal.after = Some(TerminalAfter::RefreshAgentsAndClose { selected_index });
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        self.push_background_before_next_output(format!(
            "Starting guided install for agent '{name}'"
        ));
        start_agent_install_session(
            self.app_event_tx.clone(),
            id,
            name.clone(),
            default_command.clone(),
            Some(cwd),
            controller.clone(),
            controller_rx,
            selected_index,
            self.config.debug,
        );
        Some(TerminalLaunch {
            id,
            title: format!("Install {name}"),
            command: Vec::new(),
            command_display: "Preparing install assistant…".to_string(),
            controller: Some(controller),
            auto_close_on_success: false,
            start_running: true,
        })
    }

    pub(crate) fn launch_validation_tool_install(
        &mut self,
        tool_name: &str,
        install_hint: &str,
    ) -> Option<TerminalLaunch> {
        let trimmed = install_hint.trim();
        if trimmed.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "No install command available for validation tool '{tool_name}'."
            )));
            self.request_redraw();
            return None;
        }

        let wrapped = wrap_command(trimmed);
        if wrapped.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(format!(
                "Unable to build install command for validation tool '{tool_name}'."
            )));
            self.request_redraw();
            return None;
        }

        let id = self.terminal.alloc_id();
        let display = Self::truncate_with_ellipsis(trimmed, 128);
        let launch = TerminalLaunch {
            id,
            title: format!("Install {tool_name}"),
            command: wrapped,
            command_display: display,
            controller: None,
            auto_close_on_success: false,
            start_running: true,
        };

        self.push_background_before_next_output(format!(
            "Installing validation tool '{tool_name}' with `{trimmed}`"
        ));
        Some(launch)
    }

    fn try_handle_terminal_shortcut(&mut self, raw_text: &str) -> bool {
        let trimmed = raw_text.trim_start();
        if let Some(rest) = trimmed.strip_prefix("$$") {
            let prompt = rest.trim();
            if prompt.is_empty() {
                self.history_push_plain_state(history_cell::new_error_event(
                    "No prompt provided after '$$'.".to_string(),
                ));
                self.app_event_tx.send(AppEvent::RequestRedraw);
            } else {
                self.launch_guided_terminal_prompt(prompt);
            }
            return true;
        }
        if let Some(rest) = trimmed.strip_prefix('$') {
            let command = rest.trim();
            if command.is_empty() {
                self.launch_manual_terminal();
            } else {
                self.run_terminal_command(command);
            }
            return true;
        }
        false
    }

    fn launch_manual_terminal(&mut self) {
        let id = self.terminal.alloc_id();
        let launch = TerminalLaunch {
            id,
            title: "Shell".to_string(),
            command: Vec::new(),
            command_display: String::new(),
            controller: None,
            auto_close_on_success: false,
            start_running: false,
        };
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
    }

    fn run_terminal_command(&mut self, command: &str) {
        if wrap_command(command).is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "Unable to build shell command for execution.".to_string(),
            ));
            self.app_event_tx.send(AppEvent::RequestRedraw);
            return;
        }

        let id = self.terminal.alloc_id();
        let title = Self::truncate_with_ellipsis(&format!("Shell: {command}"), 64);
        let display = Self::truncate_with_ellipsis(command, 128);
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let launch = TerminalLaunch {
            id,
            title,
            command: Vec::new(),
            command_display: display,
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };
        self.push_background_before_next_output(format!(
            "Terminal command: {command}"
        ));
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_direct_terminal_session(
            self.app_event_tx.clone(),
            id,
            command.to_string(),
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn launch_guided_terminal_prompt(&mut self, prompt: &str) {
        let id = self.terminal.alloc_id();
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        let title = Self::truncate_with_ellipsis(&format!("Guided: {prompt}"), 64);
        let display = Self::truncate_with_ellipsis(prompt, 128);

        let launch = TerminalLaunch {
            id,
            title,
            command: Vec::new(),
            command_display: display.clone(),
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };

        self.push_background_before_next_output(format!(
            "Guided terminal request: {prompt}"
        ));
        self.app_event_tx.send(AppEvent::OpenTerminal(launch));
        start_prompt_terminal_session(
            self.app_event_tx.clone(),
            id,
            prompt.to_string(),
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn is_cli_running(&self) -> bool {
        if !self.exec.running_commands.is_empty() {
            return true;
        }
        if !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty()
        {
            return true;
        }
        if self.stream.is_write_cycle_active() {
            return true;
        }
        if !self.active_task_ids.is_empty() {
            return true;
        }
        if self.active_agents.iter().any(|agent| {
            let is_auto_review = matches!(agent.source_kind, Some(AgentSourceKind::AutoReview))
                || agent
                    .batch_id
                    .as_deref()
                    .is_some_and(|batch| batch.eq_ignore_ascii_case("auto-review"));
            matches!(agent.status, AgentStatus::Pending | AgentStatus::Running) && !is_auto_review
        }) {
            return true;
        }
        false
    }

    fn refresh_auto_drive_visuals(&mut self) {
        if self.auto_state.is_active()
            || self.auto_state.should_show_goal_entry()
            || self.auto_state.last_run_summary.is_some()
        {
            self.auto_rebuild_live_ring();
        }
    }

    fn auto_reduced_motion_preference() -> bool {
        match std::env::var("CODE_TUI_REDUCED_MOTION") {
            Ok(value) => {
                let normalized = value.trim().to_ascii_lowercase();
                !matches!(normalized.as_str(), "" | "0" | "false" | "off" | "no")
            }
            Err(_) => false,
        }
    }

    fn auto_reset_intro_timing(&mut self) {
        self.auto_state.reset_intro_timing();
    }

    fn auto_ensure_intro_timing(&mut self) {
        let reduced_motion = Self::auto_reduced_motion_preference();
        self.auto_state.ensure_intro_timing(reduced_motion);
    }

    fn auto_show_goal_entry_panel(&mut self) {
        self.auto_state.set_phase(AutoRunPhase::AwaitingGoalEntry);
        self.auto_state.goal = None;
        self.auto_pending_goal_request = false;
        self.auto_goal_bootstrap_done = false;
        let seed_intro = self.auto_state.take_intro_pending();
        if seed_intro {
            self.auto_reset_intro_timing();
            self.auto_ensure_intro_timing();
        }
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        let hint = "Let's do this! What's your goal?".to_string();
        let status_lines = vec![hint];
        let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
            goal: None,
            status_lines,
            cli_prompt: None,
            cli_context: None,
            show_composer: true,
            awaiting_submission: false,
            waiting_for_response: false,
            coordinator_waiting: false,
            waiting_for_review: false,
            countdown: None,
            button: None,
            manual_hint: None,
            ctrl_switch_hint: String::new(),
            cli_running: false,
            turns_completed: 0,
            started_at: None,
            elapsed: None,
            status_sent_to_user: None,
            status_title: None,
            session_tokens: self.auto_session_tokens(),
            editing_prompt: false,
            intro_started_at: self.auto_state.intro_started_at,
            intro_reduced_motion: self.auto_state.intro_reduced_motion,
        });
        self.bottom_pane.show_auto_coordinator_view(model);
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.update_status_text("Auto Drive".to_string());
        self.auto_update_terminal_hint();
        self.bottom_pane.ensure_input_focus();
        self.clear_composer();
        self.request_redraw();
    }

    fn auto_exit_goal_entry_preserve_draft(&mut self) -> bool {
        if !self.auto_state.should_show_goal_entry() {
            return false;
        }

        let last_run_summary = self.auto_state.last_run_summary.clone();
        let last_decision_summary = self.auto_state.last_decision_summary.clone();
        let last_decision_status_sent_to_user =
            self.auto_state.last_decision_status_sent_to_user.clone();
        let last_decision_status_title =
            self.auto_state.last_decision_status_title.clone();
        let last_decision_display = self.auto_state.last_decision_display.clone();
        let last_decision_display_is_summary = self.auto_state.last_decision_display_is_summary;

        self.auto_state.reset();
        self.auto_state.last_run_summary = last_run_summary;
        self.auto_state.last_decision_summary = last_decision_summary;
        self.auto_state.last_decision_status_sent_to_user = last_decision_status_sent_to_user;
        self.auto_state.last_decision_status_title = last_decision_status_title;
        self.auto_state.last_decision_display = last_decision_display;
        self.auto_state.last_decision_display_is_summary = last_decision_display_is_summary;
        self.auto_state.set_phase(AutoRunPhase::Idle);
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        self.bottom_pane.clear_auto_coordinator_view(true);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());
        self.auto_rebuild_live_ring();
        self.request_redraw();
        true
    }

    fn auto_launch_with_goal(
        &mut self,
        goal: String,
        derive_goal_from_history: bool,
        review_enabled: bool,
        subagents_enabled: bool,
        cross_check_enabled: bool,
        qa_automation_enabled: bool,
        continue_mode: AutoContinueMode,
    ) {
        let conversation = self.rebuild_auto_history();
        let reduced_motion = Self::auto_reduced_motion_preference();
        self.auto_state.prepare_launch(
            goal.clone(),
            review_enabled,
            subagents_enabled,
            cross_check_enabled,
            qa_automation_enabled,
            continue_mode,
            reduced_motion,
        );
        self.config.auto_drive.cross_check_enabled = cross_check_enabled;
        self.config.auto_drive.qa_automation_enabled = qa_automation_enabled;
        let coordinator_events = {
            let app_event_tx = self.app_event_tx.clone();
            AutoCoordinatorEventSender::new(move |event| {
                match event {
                    AutoCoordinatorEvent::Decision {
                        seq,
                        status,
                        status_title,
                        status_sent_to_user,
                        goal,
                        cli,
                        agents_timing,
                        agents,
                        transcript,
                    } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorDecision {
                            seq,
                            status,
                            status_title,
                            status_sent_to_user,
                            goal,
                            cli,
                            agents_timing,
                            agents,
                            transcript,
                        });
                    }
                    AutoCoordinatorEvent::Thinking { delta, summary_index } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorThinking { delta, summary_index });
                    }
                    AutoCoordinatorEvent::Action { message } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorAction { message });
                    }
                    AutoCoordinatorEvent::UserReply {
                        user_response,
                        cli_command,
                    } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorUserReply {
                            user_response,
                            cli_command,
                        });
                    }
                    AutoCoordinatorEvent::TokenMetrics {
                        total_usage,
                        last_turn_usage,
                        turn_count,
                        duplicate_items,
                        replay_updates,
                    } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorTokenMetrics {
                            total_usage,
                            last_turn_usage,
                            turn_count,
                            duplicate_items,
                            replay_updates,
                        });
                    }
                    AutoCoordinatorEvent::CompactedHistory { conversation, show_notice } => {
                        app_event_tx.send(AppEvent::AutoCoordinatorCompactedHistory {
                            conversation,
                            show_notice,
                        });
                    }
                    AutoCoordinatorEvent::StopAck => {
                        app_event_tx.send(AppEvent::AutoCoordinatorStopAck);
                    }
                }
            })
        };

        let mut auto_config = self.config.clone();
        auto_config.model = self.config.auto_drive.model.trim().to_string();
        if auto_config.model.is_empty() {
            auto_config.model = code_auto_drive_core::MODEL_SLUG.to_string();
        }
        auto_config.model_reasoning_effort = self.config.auto_drive.model_reasoning_effort;

        let mut pid_guard = AutoDrivePidFile::write(
            &self.config.code_home,
            Some(goal.as_str()),
            AutoDriveMode::Tui,
        );

        match start_auto_coordinator(
            coordinator_events,
            goal.clone(),
            conversation,
            auto_config,
            self.config.debug,
            derive_goal_from_history,
        ) {
            Ok(handle) => {
                self.auto_handle = Some(handle);
                self.auto_drive_pid_guard = pid_guard.take();
                let placeholder = auto_drive_strings::next_auto_drive_phrase().to_string();
                let effects = self
                    .auto_state
                    .launch_succeeded(goal.clone(), Some(placeholder), Instant::now());
                self.auto_apply_controller_effects(effects);
            }
            Err(err) => {
                drop(pid_guard);
                let effects = self
                    .auto_state
                    .launch_failed(goal.clone(), err.to_string());
                self.auto_apply_controller_effects(effects);
            }
        }
    }

    pub(crate) fn handle_auto_command(&mut self, goal: Option<String>) {
        let provided = goal.unwrap_or_default();
        let trimmed = provided.trim();

        if trimmed.eq_ignore_ascii_case("settings") {
            self.ensure_auto_drive_settings_overlay();
            return;
        }

        let full_auto_enabled = matches!(
            (&self.config.sandbox_policy, self.config.approval_policy),
            (SandboxPolicy::DangerFullAccess, AskForApproval::Never)
        );

        if !full_auto_enabled && !(trimmed.is_empty() && self.auto_state.is_active()) {
            self.push_background_tail(
                "Please use Shift+Tab to switch to Full Auto before using Auto Drive"
                    .to_string(),
            );
            self.request_redraw();
            return;
        }
        if trimmed.is_empty() {
            if self.auto_state.is_active() {
                self.auto_stop(None);
            }
            let started = self.auto_start_bootstrap_from_history();
            if !started {
                self.auto_state.reset();
                self.auto_state.set_phase(AutoRunPhase::Idle);
                self.auto_show_goal_entry_panel();
            }
            self.request_redraw();
            return;
        }

        let goal_text = trimmed.to_string();

        if self.auto_state.is_active() {
            self.auto_stop(None);
        }

        let defaults = self.config.auto_drive.clone();
        let default_mode = auto_continue_from_config(defaults.continue_mode);

        self.auto_state.mark_intro_pending();
        self.auto_launch_with_goal(
            goal_text,
            false,
            defaults.review_enabled,
            defaults.agents_enabled,
            defaults.cross_check_enabled,
            defaults.qa_automation_enabled,
            default_mode,
        );
    }

    pub(crate) fn show_auto_drive_settings(&mut self) {
        self.history_render.invalidate_all();
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        self.ensure_auto_drive_settings_overlay();
    }

    pub(crate) fn close_auto_drive_settings(&mut self) {
        if matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::AutoDrive)
        ) {
            self.close_settings_overlay();
        }
        self.history_render.invalidate_all();
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        let should_rebuild_view = if self.auto_state.is_active() {
            !self.auto_state.is_paused_manual()
        } else {
            self.auto_state.should_show_goal_entry() || self.auto_state.last_run_summary.is_some()
        };

        if should_rebuild_view {
            self.auto_rebuild_live_ring();
        }
        self.bottom_pane.ensure_input_focus();
    }

    pub(crate) fn apply_auto_drive_settings(
        &mut self,
        review_enabled: bool,
        agents_enabled: bool,
        cross_check_enabled: bool,
        qa_automation_enabled: bool,
        continue_mode: AutoContinueMode,
    ) {
        let mut changed = false;
        if self.auto_state.review_enabled != review_enabled {
            self.auto_state.review_enabled = review_enabled;
            changed = true;
        }
        if self.auto_state.subagents_enabled != agents_enabled {
            self.auto_state.subagents_enabled = agents_enabled;
            changed = true;
        }
        if self.auto_state.cross_check_enabled != cross_check_enabled {
            self.auto_state.cross_check_enabled = cross_check_enabled;
            changed = true;
        }
        if self.auto_state.qa_automation_enabled != qa_automation_enabled {
            self.auto_state.qa_automation_enabled = qa_automation_enabled;
            changed = true;
        }
        if self.auto_state.continue_mode != continue_mode {
            let effects = self.auto_state.update_continue_mode(continue_mode);
            self.auto_apply_controller_effects(effects);
            changed = true;
        }

        if !changed {
            return;
        }

        self.config.auto_drive.review_enabled = review_enabled;
        self.config.auto_drive.agents_enabled = agents_enabled;
        self.config.auto_drive.cross_check_enabled = cross_check_enabled;
        self.config.auto_drive.qa_automation_enabled = qa_automation_enabled;
        self.config.auto_drive.continue_mode = auto_continue_to_config(continue_mode);
        self.restore_auto_resolve_attempts_if_lost();

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_auto_drive_settings(
                &home,
                &self.config.auto_drive,
                self.config.auto_drive_use_chat_model,
            )
            {
                tracing::warn!("Failed to persist Auto Drive settings: {err}");
            }
        } else {
            tracing::warn!("Could not locate config home to persist Auto Drive settings");
        }

        self.refresh_settings_overview_rows();
        self.refresh_auto_drive_visuals();
        self.request_redraw();
    }

    fn auto_send_conversation(&mut self) {
        if !self.auto_state.is_active() || self.auto_state.is_waiting_for_response() {
            return;
        }
        self.auto_state.on_complete_review();
        if !self.auto_state.is_paused_manual() {
            self.auto_state.clear_bypass_coordinator_flag();
        }
        let conversation = std::sync::Arc::<[ResponseItem]>::from(self.current_auto_history());
        let Some(handle) = self.auto_handle.as_ref() else {
            return;
        };
        if handle
            .send(AutoCoordinatorCommand::UpdateConversation(conversation.into()))
            .is_err()
        {
            self.auto_stop(Some("Coordinator stopped unexpectedly.".to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.auto_state.on_prompt_submitted();
            self.auto_state.set_coordinator_waiting(true);
            self.auto_state.current_summary = None;
            self.auto_state.current_status_sent_to_user = None;
            self.auto_state.current_status_title = None;
            self.auto_state.current_cli_prompt = None;
            self.auto_state.current_cli_context = None;
            self.auto_state.hide_cli_context_in_ui = false;
            self.auto_state.last_broadcast_summary = None;
            self.auto_state.current_summary_index = None;
            self.auto_state.current_display_line = None;
            self.auto_state.current_display_is_summary = false;
            self.auto_state.current_reasoning_title = None;
            self.auto_state.placeholder_phrase =
                Some(auto_drive_strings::next_auto_drive_phrase().to_string());
            self.auto_state.thinking_prefix_stripped = false;
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_send_conversation_force(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }
        if !self.auto_state.is_paused_manual() {
            self.auto_state.clear_bypass_coordinator_flag();
        }
        let conversation = std::sync::Arc::<[ResponseItem]>::from(self.current_auto_history());
        let Some(handle) = self.auto_handle.as_ref() else {
            return;
        };
        if handle
            .send(AutoCoordinatorCommand::UpdateConversation(conversation.into()))
            .is_err()
        {
            self.auto_stop(Some("Coordinator stopped unexpectedly.".to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
            self.auto_state.on_prompt_submitted();
            self.auto_state.set_coordinator_waiting(true);
            self.auto_state.current_summary = None;
            self.auto_state.current_status_sent_to_user = None;
            self.auto_state.current_status_title = None;
            self.auto_state.current_cli_prompt = None;
            self.auto_state.current_cli_context = None;
            self.auto_state.hide_cli_context_in_ui = false;
            self.auto_state.last_broadcast_summary = None;
            self.auto_state.current_summary_index = None;
            self.auto_state.current_display_line = None;
            self.auto_state.current_display_is_summary = false;
            self.auto_state.current_reasoning_title = None;
            self.auto_state.placeholder_phrase =
                Some(auto_drive_strings::next_auto_drive_phrase().to_string());
            self.auto_state.thinking_prefix_stripped = false;
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_send_user_prompt_to_coordinator(
        &mut self,
        prompt: String,
        conversation: Vec<ResponseItem>,
    ) -> bool {
        let Some(handle) = self.auto_handle.as_ref() else {
            return false;
        };
        let command = AutoCoordinatorCommand::HandleUserPrompt {
            _prompt: prompt,
            conversation: conversation.into(),
        };
        match handle.send(command) {
            Ok(()) => {
                self.auto_state.on_prompt_submitted();
                self.auto_state.set_coordinator_waiting(true);
                self.auto_state.placeholder_phrase =
                    Some(auto_drive_strings::next_auto_drive_phrase().to_string());
                self.auto_rebuild_live_ring();
                self.request_redraw();
                true
            }
            Err(err) => {
                tracing::warn!("failed to dispatch user prompt to coordinator: {err}");
                false
            }
        }
    }

    fn auto_failure_is_transient(message: &str) -> bool {
        let lower = message.to_ascii_lowercase();
        const TRANSIENT_MARKERS: &[&str] = &[
            "stream error",
            "network error",
            "timed out",
            "timeout",
            "temporarily unavailable",
            "retry window exceeded",
            "retry limit exceeded",
            "connection reset",
            "connection refused",
            "broken pipe",
            "dns error",
            "host unreachable",
            "send request",
        ];
        TRANSIENT_MARKERS.iter().any(|needle| lower.contains(needle))
    }

    fn auto_schedule_restart_event(&self, token: u64, attempt: u32, delay: Duration) {
        let tx = self.app_event_tx.clone();
        if let Ok(handle) = tokio::runtime::Handle::try_current() {
            handle.spawn(async move {
                if !delay.is_zero() {
                    tokio::time::sleep(delay).await;
                }
                tx.send(AppEvent::AutoCoordinatorRestart { token, attempt });
            });
        } else {
            std::thread::spawn(move || {
                if !delay.is_zero() {
                    std::thread::sleep(delay);
                }
                tx.send(AppEvent::AutoCoordinatorRestart { token, attempt });
            });
        }
    }

    fn auto_pause_for_transient_failure(&mut self, message: String) {
        warn!("auto drive transient failure: {}", message);

        if let Some(handle) = self.auto_handle.take() {
            handle.cancel();
        }

        self.pending_turn_descriptor = None;
        self.pending_auto_turn_config = None;

        let effects = self
            .auto_state
            .pause_for_transient_failure(Instant::now(), message);
        self.auto_apply_controller_effects(effects);
    }

    pub(crate) fn auto_handle_decision(
        &mut self,
        seq: u64,
        status: AutoCoordinatorStatus,
        status_title: Option<String>,
        status_sent_to_user: Option<String>,
        goal: Option<String>,
        cli: Option<AutoTurnCliAction>,
        agents_timing: Option<AutoTurnAgentsTiming>,
        agents: Vec<AutoTurnAgentsAction>,
        transcript: Vec<code_protocol::models::ResponseItem>,
    ) {
        if !self.auto_state.is_active() {
            if let Some(handle) = self.auto_handle.as_ref() {
                let _ = handle.send(code_auto_drive_core::AutoCoordinatorCommand::AckDecision { seq });
            }
            return;
        }

        self.auto_pending_goal_request = false;

        if let Some(goal_text) = goal.as_ref().map(|g| g.trim()).filter(|g| !g.is_empty()) {
            let derived_goal = goal_text.to_string();
            self.auto_state.goal = Some(derived_goal.clone());
            self.auto_goal_bootstrap_done = true;
            self.auto_card_set_goal(Some(derived_goal));
        }

        let status_title = Self::normalize_status_field(status_title);
        let status_sent_to_user = Self::normalize_status_field(status_sent_to_user);

        self.auto_state.turns_completed = self.auto_state.turns_completed.saturating_add(1);

        if !transcript.is_empty() {
            self.auto_history.append_raw(&transcript);
        }

        if let Some(handle) = self.auto_handle.as_ref() {
            let _ = handle.send(code_auto_drive_core::AutoCoordinatorCommand::AckDecision { seq });
        }

        self.auto_state.current_status_sent_to_user = status_sent_to_user.clone();
        self.auto_state.current_status_title = status_title.clone();
        self.auto_state.last_decision_status_sent_to_user = status_sent_to_user.clone();
        self.auto_state.last_decision_status_title = status_title.clone();
        let planning_turn = cli
            .as_ref()
            .map(|action| action.suppress_ui_context)
            .unwrap_or(false);
        let cli_context_raw = cli
            .as_ref()
            .and_then(|action| action.context.clone());
        let cli_context = Self::normalize_status_field(cli_context_raw);
        let cli_prompt = cli.as_ref().map(|action| action.prompt.clone());

        self.auto_state.current_cli_context = cli_context.clone();
        self.auto_state.hide_cli_context_in_ui = planning_turn;
        self.auto_state.suppress_next_cli_display = planning_turn;
        if let Some(ref prompt_text) = cli_prompt {
            self.auto_state.current_cli_prompt = Some(prompt_text.clone());
        } else {
            self.auto_state.current_cli_prompt = None;
        }

        let summary_text = Self::compose_status_summary(&status_title, &status_sent_to_user);
        self.auto_state.last_decision_summary = Some(summary_text.clone());
        self.auto_state.set_coordinator_waiting(false);
        self.auto_on_reasoning_final(&summary_text);
        self.auto_state.last_decision_display = self.auto_state.current_display_line.clone();
        self.auto_state.last_decision_display_is_summary =
            self.auto_state.current_display_is_summary;
            self.auto_state.on_resume_from_manual();

        self.pending_turn_descriptor = None;
        self.pending_auto_turn_config = None;

        if let Some(current) = status_title
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            self.auto_card_add_action(
                format!("Status: {current}"),
                AutoDriveActionKind::Info,
            );
        }

        let mut promoted_agents: Vec<String> = Vec::new();
        let continue_status = matches!(status, AutoCoordinatorStatus::Continue);

        let resolved_agents: Vec<AutoTurnAgentsAction> = agents
            .into_iter()
            .map(|mut action| {
                let original = action.write;
                let requested = action.write_requested;
                let resolved = self.resolve_agent_write_flag(requested);
                if resolved && !original {
                    promoted_agents.push(action.prompt.clone());
                }
                action.write = resolved;
                action
            })
            .collect();

        if continue_status {
            self.auto_state.pending_agent_actions = resolved_agents;
            self.auto_state.pending_agent_timing = agents_timing
                .filter(|_| !self.auto_state.pending_agent_actions.is_empty());
        } else {
            self.auto_state.pending_agent_actions.clear();
            self.auto_state.pending_agent_timing = None;
        }

        if !promoted_agents.is_empty() {
            let joined = promoted_agents
                .into_iter()
                .map(|prompt| {
                    let trimmed = prompt.trim();
                    if trimmed.is_empty() {
                        "<empty prompt>".to_string()
                    } else {
                        format!("\"{trimmed}\"")
                    }
                })
                .collect::<Vec<_>>()
                .join(", ");
            self.auto_card_add_action(
                format!("Auto Drive enabled write mode for agent prompt(s): {joined}"),
                AutoDriveActionKind::Info,
            );
        }

        if !matches!(status, AutoCoordinatorStatus::Failed) {
            self.auto_state.transient_restart_attempts = 0;
           self.auto_state.on_recovery_attempt();
            self.auto_state.pending_restart = None;
        }

        match status {
            AutoCoordinatorStatus::Continue => {
                let Some(prompt_text) = cli_prompt else {
                    self.auto_stop(Some("Coordinator response omitted a prompt.".to_string()));
                    return;
                };
                if planning_turn {
                    self.push_background_tail("Auto Drive: Planning started".to_string());
                    if let Some(full_prompt) = self.build_auto_turn_message(&prompt_text) {
                        self.auto_dispatch_cli_prompt(full_prompt);
                    } else {
                        self.auto_stop(Some(
                            "Coordinator produced an empty planning prompt.".to_string(),
                        ));
                    }
                } else {
                    self.schedule_auto_cli_prompt(seq, prompt_text);
                }
            }
            AutoCoordinatorStatus::Success => {
                let normalized = summary_text.trim();
                let message = if normalized.is_empty() {
                    "Coordinator success.".to_string()
                } else if normalized
                    .to_ascii_lowercase()
                    .starts_with("coordinator success:")
                {
                    summary_text
                } else {
                    format!("Coordinator success: {summary_text}")
                };

                let diagnostics_goal = self
                    .auto_state
                    .goal
                    .as_deref()
                    .unwrap_or("(goal unavailable)");

                let prompt_text = format!(
                    r#"Here was the original goal:
{diagnostics_goal}

Have we met every part of this goal and is there no further work to do?"#
                );

                let tf = TextFormat {
                    r#type: "json_schema".to_string(),
                    name: Some("auto_drive_diagnostics".to_string()),
                    strict: Some(true),
                    schema: Some(code_auto_drive_diagnostics::AutoDriveDiagnostics::completion_schema()),
                };
                self.submit_op(Op::SetNextTextFormat { format: tf.clone() });
                self.next_cli_text_format = Some(tf);
                self.auto_state.pending_stop_message = Some(message);
                self.auto_card_add_action(
                    "Auto Drive Diagnostics: Validating progress".to_string(),
                    AutoDriveActionKind::Info,
                );
                self.schedule_auto_cli_prompt(seq, prompt_text);
                self.auto_submit_prompt();
                return;
            }
            AutoCoordinatorStatus::Failed => {
                let normalized = summary_text.trim();
                let message = if normalized.is_empty() {
                    "Coordinator error.".to_string()
                } else if normalized
                    .to_ascii_lowercase()
                    .starts_with("coordinator error:")
                {
                    summary_text
                } else {
                    format!("Coordinator error: {summary_text}")
                };
                if Self::auto_failure_is_transient(&message) {
                    self.auto_pause_for_transient_failure(message);
                } else {
                    self.auto_stop(Some(message));
                }
                return;
            }
        }
    }

    pub(crate) fn auto_handle_user_reply(
        &mut self,
        user_response: Option<String>,
        cli_command: Option<String>,
    ) {
        if let Some(text) = user_response.clone() {
            if let Some(item) = Self::auto_drive_make_assistant_message(text.clone()) {
                self.auto_history
                    .append_raw(std::slice::from_ref(&item));
            }
            let mut lines = Vec::with_capacity(2);
            lines.push("AUTO DRIVE RESPONSE".to_string());
            lines.push(text);
            self.history_push_plain_paragraphs(PlainMessageKind::Notice, lines);
        }

        if let Some(command) = cli_command {
            if command.trim_start().starts_with('/') {
                self.app_event_tx
                    .send(AppEvent::DispatchCommand(SlashCommand::Auto, command));
            } else {
                let mut message: UserMessage = command.into();
                message.suppress_persistence = true;
                self.submit_user_message(message);
            }
        } else {
            self.auto_state.set_phase(AutoRunPhase::Active);
            self.auto_state.placeholder_phrase = None;
        }

        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    pub(crate) fn auto_handle_token_metrics(
        &mut self,
        total_usage: TokenUsage,
        last_turn_usage: TokenUsage,
        turn_count: u32,
        duplicate_items: u32,
        replay_updates: u32,
    ) {
        self.auto_history
            .apply_token_metrics(
                total_usage,
                last_turn_usage,
                turn_count,
                duplicate_items,
                replay_updates,
            );
        self.request_redraw();
    }

    fn auto_session_tokens(&self) -> Option<u64> {
        let total = self.auto_history.total_tokens().blended_total();
        (total > 0).then_some(total)
    }

    pub(crate) fn auto_handle_compacted_history(
        &mut self,
        conversation: std::sync::Arc<[ResponseItem]>,
        show_notice: bool,
    ) {
        let (previous_items, previous_indices) = self.export_auto_drive_items_with_indices();
        let conversation = conversation.as_ref().to_vec();
        self.auto_compaction_overlay = self
            .derive_compaction_overlay(&previous_items, &previous_indices, &conversation);
        self.auto_history.replace_all(conversation);
        if show_notice {
            self.history_push_plain_paragraphs(
                PlainMessageKind::Notice,
                [COMPACTION_CHECKPOINT_MESSAGE],
            );
        }
        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    fn schedule_auto_cli_prompt(&mut self, decision_seq: u64, prompt_text: String) {
        self.schedule_auto_cli_prompt_with_override(decision_seq, prompt_text, None);
    }

    fn schedule_auto_cli_prompt_with_override(
        &mut self,
        decision_seq: u64,
        prompt_text: String,
        countdown_override: Option<u8>,
    ) {
        self.auto_state.suppress_next_cli_display = false;
        let effects = self
            .auto_state
            .schedule_cli_prompt(decision_seq, prompt_text, countdown_override);
        self.auto_apply_controller_effects(effects);
    }

    fn auto_can_bootstrap_from_history(&self) -> bool {
        self.history_cells.iter().any(|cell| match cell.kind() {
            HistoryCellType::User | HistoryCellType::Assistant | HistoryCellType::Plain => true,
            HistoryCellType::Exec { .. } => true,
            _ => false,
        })
    }

    fn auto_apply_controller_effects(&mut self, effects: Vec<AutoControllerEffect>) {
        for effect in effects {
        match effect {
            AutoControllerEffect::RefreshUi => {
                    self.auto_rebuild_live_ring();
                    self.request_redraw();
                }
                AutoControllerEffect::StartCountdown {
                    countdown_id,
                    decision_seq,
                    seconds,
                } => {
                    if seconds == 0 {
                        let _ = self.app_event_tx.send(AppEvent::AutoCoordinatorCountdown {
                            countdown_id,
                            seconds_left: 0,
                        });
                    } else {
                        self.auto_spawn_countdown(countdown_id, decision_seq, seconds);
                    }
                }
                AutoControllerEffect::SubmitPrompt => {
                    if self.auto_state.should_bypass_coordinator_next_submit()
                        && self.auto_state.is_paused_manual()
                    {
                        self.auto_state.clear_bypass_coordinator_flag();
                        self.auto_state.set_phase(AutoRunPhase::Active);
                    }
                    if !self.auto_state.should_bypass_coordinator_next_submit() {
                        self.auto_submit_prompt();
                    }
                }
                AutoControllerEffect::LaunchStarted { goal } => {
                    self.bottom_pane.set_task_running(false);
                    self.bottom_pane.update_status_text("Auto Drive".to_string());
                    self.auto_card_start(Some(goal.clone()));
                    self.auto_card_add_action(
                        format!("Auto Drive started: {goal}"),
                        AutoDriveActionKind::Info,
                    );
                    self.auto_card_set_status(AutoDriveStatus::Running);
                }
                AutoControllerEffect::LaunchFailed { goal, error } => {
                    let message = format!(
                        "Coordinator failed to start for goal '{goal}': {error}"
                    );
                    self.auto_card_finalize(
                        Some(message),
                        AutoDriveStatus::Failed,
                        AutoDriveActionKind::Error,
                    );
                    self.auto_request_session_summary();
                }
                AutoControllerEffect::StopCompleted { summary, message } => {
                    if let Some(handle) = self.auto_handle.take() {
                        handle.cancel();
                        let _ = handle.send(AutoCoordinatorCommand::Stop);
                    }
                    let final_message = message.or_else(|| summary.message.clone());
                    if let Some(msg) = final_message.clone() {
                        if !msg.trim().is_empty() {
                            self.auto_card_finalize(
                                Some(msg),
                                AutoDriveStatus::Stopped,
                                AutoDriveActionKind::Info,
                            );
                        } else {
                            self.auto_card_finalize(None, AutoDriveStatus::Stopped, AutoDriveActionKind::Info);
                        }
                    } else {
                        self.auto_card_finalize(None, AutoDriveStatus::Stopped, AutoDriveActionKind::Info);
                    }
                    self.schedule_auto_drive_card_celebration(
                        Duration::from_secs(0),
                        self.auto_state.last_completion_explanation.clone(),
                    );
                    self.auto_turn_review_state = None;
                    if ENABLE_WARP_STRIPES {
                        self.header_wave.set_enabled(false, Instant::now());
                    }
                    self.auto_request_session_summary();
                }
                AutoControllerEffect::TransientPause {
                    attempt,
                    delay,
                    reason,
                } => {
                    let human_delay = format_duration(delay);
                    self.bottom_pane.set_task_running(false);
                    self.bottom_pane
                        .update_status_text("Auto Drive paused".to_string());
                    self.bottom_pane.set_standard_terminal_hint(Some(
                        "Press Esc again to exit Auto Drive".to_string(),
                    ));
                    let message = format!(
                        "Auto Drive will retry automatically in {human_delay} (attempt {attempt}). Last error: {reason}"
                    );
                    self.auto_card_add_action(message, AutoDriveActionKind::Warning);
                    self.auto_card_set_status(AutoDriveStatus::Paused);
                }
                AutoControllerEffect::ScheduleRestart {
                    token,
                    attempt,
                    delay,
                } => {
                    self.auto_schedule_restart_event(token, attempt, delay);
                }
                AutoControllerEffect::CancelCoordinator => {
                    if let Some(handle) = self.auto_handle.take() {
                        handle.cancel();
                        let _ = handle.send(AutoCoordinatorCommand::Stop);
                    }
                }
                AutoControllerEffect::ResetHistory => {
                    self.auto_history.clear();
                    self.reset_auto_compaction_overlay();
                }
                AutoControllerEffect::UpdateTerminalHint { hint } => {
                    self.bottom_pane.set_standard_terminal_hint(hint);
                }
                AutoControllerEffect::SetTaskRunning { running } => {
                    let has_activity = running
                        || !self.exec.running_commands.is_empty()
                        || !self.tools_state.running_custom_tools.is_empty()
                        || !self.tools_state.web_search_sessions.is_empty()
                        || !self.tools_state.running_wait_tools.is_empty()
                        || !self.tools_state.running_kill_tools.is_empty()
                        || self.stream.is_write_cycle_active()
                        || !self.active_task_ids.is_empty();

                    self.bottom_pane.set_task_running(has_activity);
                    if !has_activity {
                        self.bottom_pane.update_status_text(String::new());
                    }
                }
                AutoControllerEffect::EnsureInputFocus => {
                    self.bottom_pane.ensure_input_focus();
                }
                AutoControllerEffect::ClearCoordinatorView => {
                    self.bottom_pane.clear_auto_coordinator_view(true);
                }
                AutoControllerEffect::ShowGoalEntry => {
                    self.auto_show_goal_entry_panel();
                }
            }
        }
    }

    fn auto_spawn_countdown(&self, countdown_id: u64, decision_seq: u64, seconds: u8) {
        let tx = self.app_event_tx.clone();
        let fallback_tx = tx.clone();
        if thread_spawner::spawn_lightweight("countdown", move || {
            let mut remaining = seconds;
            tracing::debug!(
                target: "auto_drive::coordinator",
                countdown_id,
                decision_seq,
                seconds,
                "spawned countdown"
            );
            while remaining > 0 {
                std::thread::sleep(std::time::Duration::from_secs(1));
                remaining -= 1;
                if !tx.send_with_result(AppEvent::AutoCoordinatorCountdown {
                    countdown_id,
                    seconds_left: remaining,
                }) {
                    break;
                }
            }
        })
        .is_none()
        {
            let _ = fallback_tx.send(AppEvent::AutoCoordinatorCountdown {
                countdown_id,
                seconds_left: 0,
            });
        }
    }

    pub(crate) fn auto_handle_countdown(&mut self, countdown_id: u64, seconds_left: u8) {
        let decision_seq = self.auto_state.countdown_decision_seq;
        let effects = self
            .auto_state
            .handle_countdown_tick(countdown_id, decision_seq, seconds_left);
        if effects.is_empty() {
            return;
        }
        self.auto_apply_controller_effects(effects);
    }

    pub(crate) fn auto_handle_restart(&mut self, token: u64, attempt: u32) {
        if !self.auto_state.is_active() || !self.auto_state.in_transient_recovery() {
            return;
        }
        let Some(restart) = self.auto_state.pending_restart.clone() else {
            return;
        };
        if restart.token != token || restart.attempt != attempt {
            return;
        }

        let Some(goal) = self.auto_state.goal.clone() else {
            self.auto_card_add_action(
                "Auto Drive restart skipped because the goal is no longer available.".to_string(),
                AutoDriveActionKind::Warning,
            );
            self.auto_state.pending_restart = None;
            self.auto_state.on_recovery_attempt();
            self.auto_stop(Some("Auto Drive restart aborted.".to_string()));
            return;
        };

        let cross_check_enabled = self.auto_state.cross_check_enabled;
        let continue_mode = self.auto_state.continue_mode;
        let previous_turns = self.auto_state.turns_completed;
        let previous_started_at = self.auto_state.started_at;
        let restart_attempts = self.auto_state.transient_restart_attempts;
        let review_enabled = self.auto_state.review_enabled;
        let agents_enabled = self.auto_state.subagents_enabled;
        let qa_automation_enabled = self.auto_state.qa_automation_enabled;

        self.auto_state.pending_restart = None;
        self.auto_state.on_recovery_attempt();
        self.auto_state.restart_token = token;

        let resume_message = if restart.reason.is_empty() {
            format!("Auto Drive resuming automatically (attempt {attempt}).")
        } else {
            format!(
                "Auto Drive resuming automatically (attempt {attempt}); previous error: {}",
                restart.reason
            )
        };
        self.auto_card_add_action(resume_message, AutoDriveActionKind::Info);
        self.auto_card_set_status(AutoDriveStatus::Running);

        self.auto_launch_with_goal(
            goal,
            false,
            review_enabled,
            agents_enabled,
            cross_check_enabled,
            qa_automation_enabled,
            continue_mode,
        );

        if previous_turns > 0 {
            self.auto_state.turns_completed = previous_turns;
        }
        if let Some(started_at) = previous_started_at {
            self.auto_state.started_at = Some(started_at);
        }
        self.auto_state.transient_restart_attempts = restart_attempts;
        self.auto_state.current_status_title = None;
        self.auto_state.current_status_sent_to_user = None;
        self.auto_rebuild_live_ring();
        self.auto_update_terminal_hint();
        self.request_redraw();
        self.rebuild_auto_history();
    }

    pub(crate) fn auto_handle_thinking(&mut self, delta: String, summary_index: Option<u32>) {
        if !self.auto_state.is_active() {
            return;
        }
        self.auto_on_reasoning_delta(&delta, summary_index);
    }

    pub(crate) fn auto_handle_action(&mut self, message: String) {
        if !self.auto_state.is_active() {
            return;
        }
        self.auto_card_add_action(message, AutoDriveActionKind::Info);
    }

    #[cfg(any(test, feature = "test-helpers"))]
    #[allow(dead_code)]
    fn auto_handle_post_turn_review(
        &mut self,
        cfg: TurnConfig,
        descriptor: Option<&TurnDescriptor>,
    ) {
        if !self.auto_state.review_enabled {
            self.auto_turn_review_state = None;
            return;
        }
        if cfg.read_only {
            self.auto_turn_review_state = None;
            return;
        }

        match self.auto_prepare_commit_scope() {
            AutoReviewOutcome::Skip => {
                self.auto_turn_review_state = None;
                if self.auto_state.awaiting_review() {
                    self.maybe_resume_auto_after_review();
                }
            }
            AutoReviewOutcome::Workspace => {
                self.auto_turn_review_state = None;
                self.auto_start_post_turn_review(None, descriptor);
            }
            AutoReviewOutcome::Commit(scope) => {
                self.auto_turn_review_state = None;
                self.auto_start_post_turn_review(Some(scope), descriptor);
            }
        }
    }

    #[cfg(any(test, feature = "test-helpers"))]
    #[allow(dead_code)]
    fn auto_prepare_commit_scope(&mut self) -> AutoReviewOutcome {
        let Some(state) = self.auto_turn_review_state.take() else {
            return AutoReviewOutcome::Workspace;
        };

        let Some(base_commit) = state.base_commit else {
            return AutoReviewOutcome::Workspace;
        };

        let final_commit = match self.capture_auto_turn_commit("auto turn change snapshot", Some(&base_commit)) {
            Ok(commit) => commit,
            Err(err) => {
                tracing::warn!("failed to capture auto turn change snapshot: {err}");
                return AutoReviewOutcome::Workspace;
            }
        };

        let diff_paths = match self.git_diff_name_only_between(base_commit.id(), final_commit.id()) {
            Ok(paths) => paths,
            Err(err) => {
                tracing::warn!("failed to diff auto turn snapshots: {err}");
                return AutoReviewOutcome::Workspace;
            }
        };

        if diff_paths.is_empty() {
            self.push_background_tail("Auto review skipped: no file changes detected this turn.".to_string());
            return AutoReviewOutcome::Skip;
        }

        AutoReviewOutcome::Commit(AutoReviewCommitScope {
            commit: final_commit.id().to_string(),
            file_count: diff_paths.len(),
        })
    }

    #[cfg(any(test, feature = "test-helpers"))]
    #[allow(dead_code)]
    fn auto_turn_has_diff(&self) -> bool {
        if self.worktree_has_uncommitted_changes().unwrap_or(false) {
            return true;
        }

        if let Some(base_commit) = self
            .auto_turn_review_state
            .as_ref()
            .and_then(|state| state.base_commit.as_ref())
        {
            if let Some(head) = self.current_head_commit_sha() {
                if let Ok(paths) = self.git_diff_name_only_between(base_commit.id(), &head) {
                    if !paths.is_empty() {
                        return true;
                    }
                }
            }
        }

        false
    }

    fn prepare_auto_turn_review_state(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.review_enabled {
            self.auto_turn_review_state = None;
            return;
        }

        let read_only = self
            .pending_auto_turn_config
            .as_ref()
            .map(|cfg| cfg.read_only)
            .unwrap_or(false);

        if read_only {
            self.auto_turn_review_state = None;
            return;
        }

        let existing_base = self
            .auto_turn_review_state
            .as_ref()
            .and_then(|state| state.base_commit.as_ref());

        if existing_base.is_some() {
            return;
        }

        #[cfg(test)]
        {
            if CAPTURE_AUTO_TURN_COMMIT_STUB.lock().unwrap().is_some() {
                return;
            }
        }

        match self.capture_auto_turn_commit("auto turn base snapshot", None) {
            Ok(commit) => {
                self.auto_turn_review_state = Some(AutoTurnReviewState {
                    base_commit: Some(commit),
                });
            }
            Err(err) => {
                tracing::warn!("failed to capture auto turn base snapshot: {err}");
                self.auto_turn_review_state = None;
            }
        }
    }

    fn capture_auto_turn_commit(
        &self,
        message: &'static str,
        parent: Option<&GhostCommit>,
    ) -> Result<GhostCommit, GitToolingError> {
        #[cfg(test)]
        if let Some(stub) = CAPTURE_AUTO_TURN_COMMIT_STUB.lock().unwrap().as_ref() {
            let parent_id = parent.map(|commit| commit.id().to_string());
            return stub(message, parent_id);
        }
        let mut options = CreateGhostCommitOptions::new(self.config.cwd.as_path()).message(message);
        if let Some(parent_commit) = parent {
            options = options.parent(parent_commit.id());
        }
        let hook_repo_follow = self.config.cwd.clone();
        let hook = move || bump_snapshot_epoch_for(&hook_repo_follow);
        let result = create_ghost_commit(&options.post_commit_hook(&hook));
        if result.is_ok() {
            bump_snapshot_epoch_for(&self.config.cwd);
        }
        result
    }

    fn capture_auto_review_baseline_for_path(
        repo_path: PathBuf,
    ) -> Result<GhostCommit, GitToolingError> {
        #[cfg(test)]
        if let Some(stub) = CAPTURE_AUTO_TURN_COMMIT_STUB.lock().unwrap().as_ref() {
            return stub("auto review baseline snapshot", None);
        }
        let hook_repo = repo_path.clone();
        let options =
            CreateGhostCommitOptions::new(repo_path.as_path()).message("auto review baseline snapshot");
        let hook = move || bump_snapshot_epoch_for(&hook_repo);
        let result = create_ghost_commit(&options.post_commit_hook(&hook));
        if result.is_ok() {
            bump_snapshot_epoch_for(&repo_path);
        }
        result
    }

    fn spawn_auto_review_baseline_capture(&mut self) {
        let turn_sequence = self.turn_sequence;
        let repo_path = self.config.cwd.clone();
        let app_event_tx = self.app_event_tx.clone();

        if let Ok(handle) = tokio::runtime::Handle::try_current() {
            handle.spawn(async move {
                let result = tokio::task::spawn_blocking(move || {
                    ChatWidget::capture_auto_review_baseline_for_path(repo_path)
                })
                .await
                .unwrap_or_else(|err| {
                    Err(GitToolingError::Io(io::Error::new(
                        io::ErrorKind::Other,
                        format!("auto review baseline task failed: {err}"),
                    )))
                });
                app_event_tx.send(AppEvent::AutoReviewBaselineCaptured {
                    turn_sequence,
                    result,
                });
            });
        } else {
            std::thread::spawn(move || {
                let result = ChatWidget::capture_auto_review_baseline_for_path(repo_path);
                app_event_tx.send(AppEvent::AutoReviewBaselineCaptured {
                    turn_sequence,
                    result,
                });
            });
        }
    }

    pub(crate) fn handle_auto_review_baseline_captured(
        &mut self,
        turn_sequence: u64,
        result: Result<GhostCommit, GitToolingError>,
    ) {
        if turn_sequence != self.turn_sequence {
            tracing::debug!(
                "ignored auto review baseline for stale turn_sequence={turn_sequence}"
            );
            return;
        }
        if self.auto_review_baseline.is_some() {
            tracing::debug!("auto review baseline already set; skipping update");
            return;
        }
        match result {
            Ok(commit) => {
                self.auto_review_baseline = Some(commit);
            }
            Err(err) => {
                tracing::warn!("failed to capture auto review baseline: {err}");
            }
        }
    }

    #[cfg(any(test, feature = "test-helpers"))]
    #[allow(dead_code)]
    fn git_diff_name_only_between(
        &self,
        base_commit: &str,
        head_commit: &str,
    ) -> Result<Vec<String>, String> {
        #[cfg(test)]
        if let Some(stub) = GIT_DIFF_NAME_ONLY_BETWEEN_STUB.lock().unwrap().as_ref() {
            return stub(base_commit.to_string(), head_commit.to_string());
        }
        self.run_git_command(
            ["diff", "--name-only", base_commit, head_commit],
            |stdout| {
                let changes = stdout
                    .lines()
                    .map(str::trim)
                    .filter(|line| !line.is_empty())
                    .map(|line| line.to_string())
                    .collect();
                Ok(changes)
            },
        )
    }

    fn auto_submit_prompt(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }

        if self.auto_pending_goal_request {
            self.auto_pending_goal_request = false;
            self.auto_send_conversation_force();
            return;
        }

        let Some(original_prompt) = self.auto_state.current_cli_prompt.clone() else {
            self.auto_stop(Some("Coordinator prompt missing when attempting to submit.".to_string()));
            return;
        };

        if original_prompt.trim().is_empty() {
            self.auto_stop(Some("Coordinator produced an empty prompt.".to_string()));
            return;
        }

        let Some(full_prompt) = self.build_auto_turn_message(&original_prompt) else {
            self.auto_stop(Some("Coordinator produced an empty prompt.".to_string()));
            return;
        };

        self.auto_dispatch_cli_prompt(full_prompt);
    }

    fn auto_start_bootstrap_from_history(&mut self) -> bool {
        if !self.auto_can_bootstrap_from_history() {
            return false;
        }

        let defaults = self.config.auto_drive.clone();
        let default_mode = auto_continue_from_config(defaults.continue_mode);

        if self.auto_state.is_active() {
            self.auto_stop(None);
        }

        self.auto_state.mark_intro_pending();
        self.auto_launch_with_goal(
            AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string(),
            true,
            defaults.review_enabled,
            defaults.agents_enabled,
            defaults.cross_check_enabled,
            defaults.qa_automation_enabled,
            default_mode,
        );

        if self.auto_handle.is_none() {
            return false;
        }

        self.auto_state.current_cli_context = None;
        self.auto_state.hide_cli_context_in_ui = false;
        self.auto_state.current_cli_prompt = Some(String::new());
        self.auto_pending_goal_request = true;
        self.auto_goal_bootstrap_done = false;

        let override_seconds = if matches!(
            self.auto_state.continue_mode,
            AutoContinueMode::Immediate
        ) {
            Some(10)
        } else {
            None
        };
        self.schedule_auto_cli_prompt_with_override(0, String::new(), override_seconds);
        true
    }

    fn auto_dispatch_cli_prompt(&mut self, full_prompt: String) {
        self.auto_pending_goal_request = false;

        self.bottom_pane.set_standard_terminal_hint(None);
        self.auto_state.on_prompt_submitted();
        self.auto_state.set_coordinator_waiting(false);
        self.auto_state.clear_bypass_coordinator_flag();
        self.auto_state.seconds_remaining = 0;
        let post_submit_display = self.auto_state.last_decision_display.clone();
        self.auto_state.current_summary = None;
        self.auto_state.current_status_sent_to_user = None;
        self.auto_state.current_status_title = None;
        self.auto_state.last_broadcast_summary = None;
        self.auto_state.current_display_line = post_submit_display.clone();
        self.auto_state.current_display_is_summary =
            self.auto_state.last_decision_display_is_summary && post_submit_display.is_some();
        self.auto_state.current_summary_index = None;
        self.auto_state.placeholder_phrase = post_submit_display.is_none().then(|| {
            auto_drive_strings::next_auto_drive_phrase().to_string()
        });
        self.auto_state.current_reasoning_title = None;
        self.auto_state.thinking_prefix_stripped = false;

        let should_prepare_agents = self.auto_state.subagents_enabled
            && !self.auto_state.pending_agent_actions.is_empty();
        if should_prepare_agents {
            self.prepare_agents();
        }

        if self.auto_state.review_enabled {
            self.prepare_auto_turn_review_state();
        } else {
            self.auto_turn_review_state = None;
        }
        self.bottom_pane.update_status_text(String::new());
        self.bottom_pane.set_task_running(false);
        let mut message: UserMessage = full_prompt.into();
        message.suppress_persistence = true;
        if self.auto_state.pending_stop_message.is_some() {
            message.display_text.clear();
        } else if self.auto_state.suppress_next_cli_display {
            message.display_text.clear();
        }
        self.submit_user_message(message);
        self.auto_state.pending_agent_actions.clear();
        self.auto_state.pending_agent_timing = None;
        self.auto_rebuild_live_ring();
        self.request_redraw();
        self.auto_state.suppress_next_cli_display = false;
    }

    fn auto_pause_for_manual_edit(&mut self, force: bool) {
        if !self.auto_state.is_active() {
            return;
        }

        if !force && !self.auto_state.awaiting_coordinator_submit() {
            return;
        }

        let prompt_text = self
            .auto_state
            .current_cli_prompt
            .clone()
            .unwrap_or_default();
        let full_prompt = self
            .build_auto_turn_message(&prompt_text)
            .unwrap_or_else(|| prompt_text.clone());

        self.auto_state.on_pause_for_manual(true);
        self.auto_state.set_bypass_coordinator_next_submit();
        self.auto_state.countdown_id = self.auto_state.countdown_id.wrapping_add(1);
        self.auto_state.reset_countdown();
        self.clear_composer();
        if !full_prompt.is_empty() {
            self.insert_str(&full_prompt);
        } else if force && !prompt_text.is_empty() {
            self.insert_str(&prompt_text);
        }
        self.bottom_pane.ensure_input_focus();
        self.bottom_pane.set_task_running(true);
        self.bottom_pane
            .update_status_text("Auto Drive paused".to_string());
        self.show_auto_drive_exit_hint();
        self.auto_rebuild_live_ring();
        self.request_redraw();
    }

    // Build a hidden preface for the next Auto turn based on coordinator hints.
    fn build_auto_turn_message(&self, prompt_cli: &str) -> Option<String> {
        let mut sections: Vec<String> = Vec::new();

        if let Some(ctx) = self
            .auto_state
            .current_cli_context
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            sections.push(ctx.to_string());
        }

        if !prompt_cli.trim().is_empty() {
            sections.push(prompt_cli.trim().to_string());
        }

        let agent_actions = &self.auto_state.pending_agent_actions;
        if !agent_actions.is_empty() {
            let agent_timing = self.auto_state.pending_agent_timing;
            let mut agent_lines = Vec::with_capacity(agent_actions.len() * 4 + 5);
            const BLOCK_PREFIX: &str = "   ";
            const LINE_PREFIX: &str = "      ";

            agent_lines.push(format!("{BLOCK_PREFIX}<agents>"));
            agent_lines.push(format!(
                "{LINE_PREFIX}Please use agents to help you complete this task."
            ));

            for action in agent_actions {
                let prompt = action
                    .prompt
                    .trim()
                    .replace('\n', " ")
                    .replace('"', "\\\"");
                let write_text = if action.write { "write: true" } else { "write: false" };

                agent_lines.push(String::new());
                agent_lines.push(format!(
                    "{LINE_PREFIX}Please run agent.create with {write_text} and prompt like \"{prompt}\"."
                ));

                if let Some(ctx) = action
                    .context
                    .as_deref()
                    .map(str::trim)
                    .filter(|s| !s.is_empty())
                {
                    agent_lines.push(format!(
                        "{LINE_PREFIX}Context: {}",
                        ctx.replace('\n', " ")
                    ));
                }

                if let Some(models) = action
                    .models
                    .as_ref()
                    .filter(|list| !list.is_empty())
                {
                    agent_lines.push(format!(
                        "{LINE_PREFIX}Models: [{}]",
                        models.join(", ")
                    ));
                }
            }

            agent_lines.push(String::new());
            let timing_line = match agent_timing {
                Some(AutoTurnAgentsTiming::Parallel) =>
                    "Timing (parallel): Launch these agents in the background while you continue the CLI prompt. Call agent.wait with the batch_id when you are ready to merge their results.".to_string(),
                Some(AutoTurnAgentsTiming::Blocking) =>
                    "Timing (blocking): Launch these agents first, then wait with agent.wait (use the batch_id from agent.create) and only continue the CLI prompt once their results are ready.".to_string(),
                None =>
                    "Timing (default blocking): After launching the agents, wait with agent.wait (use the batch_id returned by agent.create) and fold their output into your plan.".to_string(),
            };
            agent_lines.push(format!("{LINE_PREFIX}{timing_line}"));
            agent_lines.push(String::new());

            if agent_actions.iter().any(|action| !action.write) {
                agent_lines.push(format!(
                    "{LINE_PREFIX}Call agent.result to get the results from the agent if needed."
                ));
                agent_lines.push(String::new());
            }

            if agent_actions.iter().any(|action| action.write) {
                agent_lines.push(format!(
                    "{LINE_PREFIX}When agents run with write: true, they perform edits in their own worktree. Considering reviewing and merging the best worktree once they complete."
                ));
                agent_lines.push(String::new());
            }

            agent_lines.push(format!("{BLOCK_PREFIX}</agents>"));

            sections.push(agent_lines.join("\n"));
        }

        let combined = sections.join("\n\n");
        if combined.trim().is_empty() {
            None
        } else {
            Some(combined)
        }
    }

    fn auto_agents_can_write(&self) -> bool {
        if code_core::git_info::get_git_repo_root(&self.config.cwd).is_none() {
            return false;
        }
        matches!(
            self.config.sandbox_policy,
            SandboxPolicy::DangerFullAccess | SandboxPolicy::WorkspaceWrite { .. }
        )
    }

    fn resolve_agent_write_flag(&self, requested_write: Option<bool>) -> bool {
        if !self.auto_agents_can_write() {
            return false;
        }
        if !self.auto_state.subagents_enabled {
            return requested_write.unwrap_or(false);
        }
        true
    }

    fn auto_stop(&mut self, message: Option<String>) {
        self.next_cli_text_format = None;
        self.auto_pending_goal_request = false;
        self.auto_goal_bootstrap_done = false;
        self.auto_drive_pid_guard = None;
        let effects = self
            .auto_state
            .stop_run(Instant::now(), message);
        self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        self.auto_apply_controller_effects(effects);
    }

    fn auto_on_assistant_final(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.is_waiting_for_response() {
            return;
        }
        self.auto_state.on_resume_from_manual();
        self.auto_state.reset_countdown();
        self.auto_state.current_summary = Some(String::new());
        self.auto_state.current_status_sent_to_user = None;
        self.auto_state.current_status_title = None;
        self.auto_state.current_summary_index = None;
        self.auto_state.placeholder_phrase = None;
        self.auto_state.thinking_prefix_stripped = false;

        let auto_resolve_blocking = self.auto_resolve_should_block_auto_resume();
        let review_pending = self.is_review_flow_active()
            || (self.auto_state.review_enabled
                && self
                    .pending_auto_turn_config
                    .as_ref()
                    .is_some_and(|cfg| !cfg.read_only));

        if review_pending || auto_resolve_blocking {
            self.auto_state.on_begin_review(false);
            #[cfg(any(test, feature = "test-helpers"))]
            if !self.auto_state.awaiting_review() {
                // Tests can run in parallel, so the shared review lock may already be held.
                // Force the state into AwaitingReview so assertions stay deterministic.
                self.auto_state.set_phase(AutoRunPhase::AwaitingReview {
                    diagnostics_pending: false,
                });
            }
        } else {
            self.auto_state.on_complete_review();
        }
        self.auto_rebuild_live_ring();
        self.request_redraw();
        self.rebuild_auto_history();

        if self.auto_state.awaiting_review() {
            return;
        }

        if !self.auto_state.should_bypass_coordinator_next_submit() {
            self.auto_send_conversation();
        }
    }

    #[cfg(any(test, feature = "test-helpers"))]
    #[allow(dead_code)]
    fn auto_start_post_turn_review(
        &mut self,
        scope: Option<AutoReviewCommitScope>,
        descriptor: Option<&TurnDescriptor>,
    ) {
        if !self.auto_state.review_enabled {
            return;
        }
        let strategy = descriptor.and_then(|d| d.review_strategy.as_ref());
        let (mut prompt, mut hint, mut auto_metadata, mut review_metadata, preparation) = match scope {
            Some(scope) => {
                let commit_id = scope.commit;
                let commit_for_prompt = commit_id.clone();
                let short_sha: String = commit_for_prompt.chars().take(8).collect();
                let file_label = if scope.file_count == 1 {
                    "1 file".to_string()
                } else {
                    format!("{} files", scope.file_count)
                };
                let prompt = format!(
                    "Review commit {} generated during the latest Auto Drive turn. Highlight bugs, regressions, risky patterns, and missing tests before merge.",
                    commit_for_prompt
                );
                let hint = format!("auto turn changes — {} ({})", short_sha, file_label);
                let preparation = format!("Preparing code review for commit {}", short_sha);
                let review_metadata = Some(ReviewContextMetadata {
                    scope: Some("commit".to_string()),
                    commit: Some(commit_id),
                    ..Default::default()
                });
                let auto_metadata = Some(ReviewContextMetadata {
                    scope: Some("workspace".to_string()),
                    ..Default::default()
                });
                (prompt, hint, auto_metadata, review_metadata, preparation)
            }
            None => {
                let prompt = "Review the current workspace changes and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string();
                let hint = "current workspace changes".to_string();
                let review_metadata = Some(ReviewContextMetadata {
                    scope: Some("workspace".to_string()),
                    ..Default::default()
                });
                let preparation = "Preparing code review request...".to_string();
                (
                    prompt,
                    hint,
                    review_metadata.clone(),
                    review_metadata,
                    preparation,
                )
            }
        };

        if let Some(strategy) = strategy {
            if let Some(custom_prompt) = strategy
                .custom_prompt
                .as_ref()
                .and_then(|text| {
                    let trimmed = text.trim();
                    (!trimmed.is_empty()).then_some(trimmed)
                })
            {
                prompt = custom_prompt.to_string();
            }

            if let Some(scope_hint) = strategy
                .scope_hint
                .as_ref()
                .and_then(|text| {
                    let trimmed = text.trim();
                    (!trimmed.is_empty()).then_some(trimmed)
                })
            {
                hint = scope_hint.to_string();

                let apply_scope = |meta: &mut ReviewContextMetadata| {
                    meta.scope = Some(scope_hint.to_string());
                };

                match review_metadata.as_mut() {
                    Some(meta) => apply_scope(meta),
                    None => {
                        review_metadata = Some(ReviewContextMetadata {
                            scope: Some(scope_hint.to_string()),
                            ..Default::default()
                        });
                    }
                }

                match auto_metadata.as_mut() {
                    Some(meta) => apply_scope(meta),
                    None => {
                        auto_metadata = Some(ReviewContextMetadata {
                            scope: Some(scope_hint.to_string()),
                            ..Default::default()
                        });
                    }
                }
            }
        }

        if self.config.tui.review_auto_resolve {
            let max_re_reviews = self.configured_auto_resolve_re_reviews();
            self.auto_resolve_state = Some(AutoResolveState::new_with_limit(
                prompt.clone(),
                hint.clone(),
                auto_metadata.clone(),
                max_re_reviews,
            ));
        } else {
            self.auto_resolve_state = None;
        }
        self.begin_review(prompt, hint, Some(preparation), review_metadata);
    }

    fn auto_rebuild_live_ring(&mut self) {
        if !self.auto_state.is_active() {
            if self.auto_state.should_show_goal_entry() {
                self.auto_show_goal_entry_panel();
                return;
            }
            if let Some(summary) = self.auto_state.last_run_summary.clone() {
                self.bottom_pane.clear_live_ring();
                self.auto_reset_intro_timing();
                self.auto_ensure_intro_timing();
                let mut status_lines: Vec<String> = Vec::new();
                if let Some(msg) = summary.message.as_ref() {
                    let trimmed = msg.trim();
                    if !trimmed.is_empty() {
                        status_lines.push(trimmed.to_string());
                    }
                }
                if status_lines.is_empty() {
                    if let Some(goal) = summary.goal.as_ref() {
                        status_lines.push(format!("Auto Drive completed: {goal}"));
                    } else {
                        status_lines.push("Auto Drive completed.".to_string());
                    }
                }
                let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
                    goal: summary.goal.clone(),
                    status_lines,
                    cli_prompt: None,
                    cli_context: None,
                    show_composer: true,
            awaiting_submission: false,
            waiting_for_response: false,
            coordinator_waiting: false,
            waiting_for_review: false,
                    countdown: None,
                    button: None,
                    manual_hint: None,
                    ctrl_switch_hint: "Esc to exit Auto Drive".to_string(),
                    cli_running: false,
                    turns_completed: summary.turns_completed,
                    started_at: None,
                    elapsed: Some(summary.duration),
                    status_sent_to_user: None,
                    status_title: None,
                    session_tokens: self.auto_session_tokens(),
                    editing_prompt: false,
                    intro_started_at: self.auto_state.intro_started_at,
                    intro_reduced_motion: self.auto_state.intro_reduced_motion,
                });
            self
                .bottom_pane
                .show_auto_coordinator_view(model);
            self.bottom_pane.release_auto_drive_style();
            self.bottom_pane.set_standard_terminal_hint(None);
            return;
        }

        self.bottom_pane.clear_auto_coordinator_view(true);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_standard_terminal_hint(None);
        self.auto_reset_intro_timing();
        return;
    }

    // AutoDrive is active: if intro animation was mid-flight, force reduced motion
    // so a rebuild cannot leave the header half-rendered (issue #431).
    if self.auto_state.intro_started_at.is_some() && !self.auto_state.intro_reduced_motion {
        self.auto_state.intro_reduced_motion = true;
    }

    if self.auto_state.is_paused_manual() {
        self.bottom_pane.clear_auto_coordinator_view(false);
        self.bottom_pane.clear_live_ring();
        self.bottom_pane.set_standard_terminal_hint(None);
        return;
    }

        self.bottom_pane.clear_live_ring();

        let status_text = if self.auto_state.awaiting_review() {
            "waiting for code review...".to_string()
        } else if let Some(line) = self
            .auto_state
            .current_display_line
            .as_ref()
            .filter(|line| !line.trim().is_empty())
        {
            line.clone()
        } else {
            self
                .auto_state
                .placeholder_phrase
                .get_or_insert_with(|| auto_drive_strings::next_auto_drive_phrase().to_string())
                .clone()
        };

        let headline = self.auto_format_status_headline(&status_text);
        let mut status_lines = vec![headline];
        if !self.auto_state.awaiting_review() {
            self.auto_append_status_lines(
                &mut status_lines,
                self.auto_state.current_status_title.as_ref(),
                self.auto_state.current_status_sent_to_user.as_ref(),
            );
            if self.auto_state.is_waiting_for_response() && !self.auto_state.is_coordinator_waiting() {
                let appended = self.auto_append_status_lines(
                    &mut status_lines,
                    self.auto_state.last_decision_status_title.as_ref(),
                    self.auto_state.last_decision_status_sent_to_user.as_ref(),
                );
                if !appended {
                    if let Some(summary) = self.auto_state.last_decision_summary.as_ref() {
                        let trimmed = summary.trim();
                        if !trimmed.is_empty() {
                            let collapsed = trimmed
                                .split_whitespace()
                                .collect::<Vec<_>>()
                                .join(" ");
                            if !collapsed.is_empty() {
                                let current_line = status_lines
                                    .first()
                                    .map(|line| line.trim_end_matches('…').trim())
                                    .unwrap_or("");
                                if collapsed != current_line {
                                    let display = Self::truncate_with_ellipsis(&collapsed, 160);
                                    status_lines.push(display);
                                }
                            }
                        }
                    }
                }
            }
        }
        let cli_running = self.is_cli_running();
        let progress_hint_active = self.auto_state.awaiting_coordinator_submit()
            || (self.auto_state.is_waiting_for_response() && !self.auto_state.is_coordinator_waiting())
            || cli_running;

        // Keep the most recent coordinator status visible across approval and
        // CLI execution. The coordinator clears the current status fields once it
        // starts streaming the next turn, so fall back to the last decision while
        // we are still acting on it.
        let status_title_for_view = if progress_hint_active {
            self.auto_state
                .current_status_title
                .clone()
                .or_else(|| self.auto_state.last_decision_status_title.clone())
        } else {
            None
        };
        let status_sent_to_user_for_view = if progress_hint_active {
            self.auto_state
                .current_status_sent_to_user
                .clone()
                .or_else(|| self.auto_state.last_decision_status_sent_to_user.clone())
        } else {
            None
        };

        let cli_prompt = self
            .auto_state
            .current_cli_prompt
            .clone()
            .filter(|p| !p.trim().is_empty());
        let cli_context = if self.auto_state.hide_cli_context_in_ui {
            None
        } else {
            self.auto_state
                .current_cli_context
                .clone()
                .filter(|value| !value.trim().is_empty())
        };

        let bootstrap_pending = self.auto_pending_goal_request;
        let continue_cta_active = self.auto_should_show_continue_cta();

        let countdown_limit = self.auto_state.countdown_seconds();
        let countdown_active = self.auto_state.countdown_active();
        let countdown = if self.auto_state.awaiting_coordinator_submit() {
            match countdown_limit {
                Some(limit) if limit > 0 => Some(CountdownState {
                    remaining: self.auto_state.seconds_remaining.min(limit),
                }),
                _ => None,
            }
        } else {
            None
        };

        let button = if self.auto_state.awaiting_coordinator_submit() {
            let has_cli_prompt = cli_prompt.is_some();
            let base_label = if bootstrap_pending {
                "Complete Current Task"
            } else if has_cli_prompt {
                "Send prompt"
            } else if continue_cta_active {
                "Continue current task"
            } else {
                "Send prompt"
            };
            let label = if countdown_active {
                format!("{base_label} ({}s)", self.auto_state.seconds_remaining)
            } else {
                base_label.to_string()
            };
            Some(AutoCoordinatorButton {
                label,
                enabled: true,
            })
        } else {
            None
        };

        let manual_hint = if self.auto_state.awaiting_coordinator_submit() {
            if self.auto_state.is_paused_manual() {
                Some("Edit the prompt, then press Enter to continue.".to_string())
            } else if bootstrap_pending {
                None
            } else if continue_cta_active {
                if countdown_active {
                    Some("Enter to continue now • Esc to stop".to_string())
                } else {
                    Some("Enter to continue • Esc to stop".to_string())
                }
            } else if countdown_active {
                Some("Enter to send now • Esc to edit".to_string())
            } else {
                Some("Enter to send • Esc to edit".to_string())
            }
        } else {
            None
        };

        let ctrl_switch_hint = if self.auto_state.awaiting_coordinator_submit() {
            let has_cli_prompt = cli_prompt.is_some();
            if self.auto_state.is_paused_manual() {
                "Esc to cancel".to_string()
            } else if bootstrap_pending {
                "Esc enter new goal".to_string()
            } else if has_cli_prompt {
                "Esc to edit".to_string()
            } else if continue_cta_active {
                "Esc to stop".to_string()
            } else {
                "Esc to edit".to_string()
            }
        } else if self.auto_state.is_waiting_for_response() {
            String::new()
        } else {
            String::new()
        };

        let show_composer =
            !self.auto_state.awaiting_coordinator_submit() || self.auto_state.is_paused_manual();

        let model = AutoCoordinatorViewModel::Active(AutoActiveViewModel {
            goal: self.auto_state.goal.clone(),
            status_lines,
            cli_prompt,
            awaiting_submission: self.auto_state.awaiting_coordinator_submit(),
            waiting_for_response: self.auto_state.is_waiting_for_response(),
            coordinator_waiting: self.auto_state.is_coordinator_waiting(),
            waiting_for_review: self.auto_state.awaiting_review(),
            countdown,
            button,
            manual_hint,
            ctrl_switch_hint,
            cli_running,
            turns_completed: self.auto_state.turns_completed,
            started_at: self.auto_state.started_at,
            elapsed: self.auto_state.elapsed_override,
            status_sent_to_user: status_sent_to_user_for_view,
            status_title: status_title_for_view,
            session_tokens: self.auto_session_tokens(),
            cli_context,
            show_composer,
            editing_prompt: self.auto_state.is_paused_manual(),
            intro_started_at: self.auto_state.intro_started_at,
            intro_reduced_motion: self.auto_state.intro_reduced_motion,
        });

        self
            .bottom_pane
            .show_auto_coordinator_view(model);

        self.auto_update_terminal_hint();

        if self.auto_state.started_at.is_some() {
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(Duration::from_secs(1)));
        }
    }

    fn auto_should_show_continue_cta(&self) -> bool {
        self.auto_state.is_active()
            && self.auto_state.awaiting_coordinator_submit()
            && !self.auto_state.is_paused_manual()
            && self.config.auto_drive.coordinator_routing
            && self.auto_state.continue_mode != AutoContinueMode::Manual
    }

    fn auto_format_status_headline(&self, text: &str) -> String {
        let trimmed = text.trim_end();
        if trimmed.is_empty() {
            return String::new();
        }

        if self.auto_state.current_display_is_summary {
            return trimmed.to_string();
        }

        let show_summary_without_ellipsis = self.auto_state.awaiting_coordinator_submit()
            && self.auto_state.current_reasoning_title.is_none()
            && self
                .auto_state
                .current_summary
                .as_ref()
                .map(|summary| !summary.trim().is_empty())
                .unwrap_or(false);

        if show_summary_without_ellipsis {
            trimmed.to_string()
        } else {
            append_thought_ellipsis(trimmed)
        }
    }

    fn auto_update_terminal_hint(&mut self) {
        if !self.auto_state.is_active() && !self.auto_state.should_show_goal_entry() {
            self.bottom_pane.set_standard_terminal_hint(None);
            return;
        }

        let agents_label = if self.auto_state.subagents_enabled {
            "Agents Enabled"
        } else {
            "Agents Disabled"
        };
        let diagnostics_enabled = self.auto_state.qa_automation_enabled
            && (self.auto_state.review_enabled || self.auto_state.cross_check_enabled);
        let diagnostics_label = if diagnostics_enabled {
            "Diagnostics Enabled"
        } else {
            "Diagnostics Disabled"
        };

        let left = format!("• {agents_label}  • {diagnostics_label}");

        let hint = left.to_string();
        self.bottom_pane
            .set_standard_terminal_hint(Some(hint));
    }

    fn auto_update_display_title(&mut self) {
        if !self.auto_state.is_active() {
            return;
        }

        let Some(summary) = self.auto_state.current_summary.as_ref() else {
            return;
        };

        let display = summary.lines().find_map(|line| {
            let trimmed = line.trim();
            (!trimmed.is_empty()).then(|| Self::truncate_with_ellipsis(trimmed, 160))
        });

        let Some(display) = display else {
            return;
        };

        let needs_update = self
            .auto_state
            .current_display_line
            .as_ref()
            .map(|current| current != &display)
            .unwrap_or(true);

        if needs_update {
            self.auto_state.current_display_line = Some(display);
            self.auto_state.current_display_is_summary = true;
            self.auto_state.placeholder_phrase = None;
            self.auto_state.current_reasoning_title = None;
        }
    }

    fn auto_broadcast_summary(&mut self, raw: &str) {
        if !self.auto_state.is_active() {
            return;
        }

        let display_text = extract_latest_bold_title(raw).or_else(|| {
            raw.lines().find_map(|line| {
                let trimmed = line.trim();
                (!trimmed.is_empty()).then_some(trimmed.to_string())
            })
        });

        let Some(display_text) = display_text else {
            return;
        };

        if self
            .auto_state
            .last_broadcast_summary
            .as_ref()
            .map(|prev| prev == &display_text)
            .unwrap_or(false)
        {
            return;
        }

        self.auto_state.last_broadcast_summary = Some(display_text);
    }

    fn auto_on_reasoning_delta(&mut self, delta: &str, summary_index: Option<u32>) {
        if !self.auto_state.is_active() || delta.trim().is_empty() {
            return;
        }

        let mut needs_refresh = false;

        if let Some(idx) = summary_index {
            if self.auto_state.current_summary_index != Some(idx) {
                self.auto_state.current_summary_index = Some(idx);
                self.auto_state.current_summary = Some(String::new());
                self.auto_state.thinking_prefix_stripped = false;
                self.auto_state.current_reasoning_title = None;
                self.auto_state.current_display_line = None;
                self.auto_state.current_display_is_summary = false;
                self.auto_state.placeholder_phrase =
                    Some(auto_drive_strings::next_auto_drive_phrase().to_string());
                needs_refresh = true;
            }
        }

        let cleaned_delta = if !self.auto_state.thinking_prefix_stripped {
            let (without_prefix, stripped) = strip_role_prefix_if_present(delta);
            if stripped {
                self.auto_state.thinking_prefix_stripped = true;
            }
            without_prefix.to_string()
        } else {
            delta.to_string()
        };

        if !self.auto_state.thinking_prefix_stripped && !cleaned_delta.trim().is_empty() {
            self.auto_state.thinking_prefix_stripped = true;
        }

        {
            let entry = self
                .auto_state
                .current_summary
                .get_or_insert_with(String::new);

            if auto_drive_strings::is_auto_drive_phrase(entry) {
                entry.clear();
            }

            entry.push_str(&cleaned_delta);

            let mut display_updated = false;

            if let Some(title) = extract_latest_bold_title(entry) {
                let needs_update = self
                    .auto_state
                    .current_reasoning_title
                    .as_ref()
                    .map(|existing| existing != &title)
                    .unwrap_or(true);
                if needs_update {
                    self.auto_state.current_reasoning_title = Some(title.clone());
                    self.auto_state.current_display_line = Some(title);
                    self.auto_state.current_display_is_summary = false;
                    self.auto_state.placeholder_phrase = None;
                    display_updated = true;
                }
            } else if self.auto_state.current_reasoning_title.is_none() {
                let previous_line = self.auto_state.current_display_line.clone();
                let previous_is_summary = self.auto_state.current_display_is_summary;
                self.auto_update_display_title();
                let updated_line = self.auto_state.current_display_line.clone();
                let updated_is_summary = self.auto_state.current_display_is_summary;
                if updated_is_summary
                    && (updated_line != previous_line || !previous_is_summary)
                {
                    display_updated = true;
                }
            }

            if display_updated {
                needs_refresh = true;
            }
        }

        if needs_refresh {
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn auto_on_reasoning_final(&mut self, text: &str) {
        if !self.auto_state.is_active() {
            return;
        }

        self.auto_state.current_reasoning_title = None;
        self.auto_state.current_summary = Some(text.to_string());
        self.auto_state.thinking_prefix_stripped = true;
        self.auto_state.current_summary_index = None;
        self.auto_update_display_title();
        self.auto_broadcast_summary(text);

        if self.auto_state.is_waiting_for_response() {
            self.auto_rebuild_live_ring();
            self.request_redraw();
        }
    }

    fn truncate_with_ellipsis(text: &str, max_chars: usize) -> String {
        if max_chars == 0 {
            return String::new();
        }
        let total = text.chars().count();
        if total <= max_chars {
            return text.to_string();
        }
        let take = max_chars.saturating_sub(1);
        let mut out = String::with_capacity(max_chars);
        for (idx, ch) in text.chars().enumerate() {
            if idx >= take {
                break;
            }
            out.push(ch);
        }
        out.push('…');
        out
    }

    fn normalize_status_field(field: Option<String>) -> Option<String> {
        field.and_then(|value| {
            let trimmed = value.trim();
            if trimmed.is_empty() {
                None
            } else {
                Some(trimmed.to_string())
            }
        })
    }

    fn compose_status_summary(
        status_title: &Option<String>,
        status_sent_to_user: &Option<String>,
    ) -> String {
        let mut parts: Vec<String> = Vec::new();
        if let Some(title) = status_title
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            parts.push(title.to_string());
        }
        if let Some(sent) = status_sent_to_user
            .as_ref()
            .map(|value| value.trim())
            .filter(|value| !value.is_empty())
        {
            if !parts.iter().any(|existing| existing.eq_ignore_ascii_case(sent)) {
                parts.push(sent.to_string());
            }
        }

        match parts.len() {
            0 => String::new(),
            1 => parts.into_iter().next().unwrap(),
            _ => parts.join(" · "),
        }
    }

    fn auto_append_status_lines(
        &self,
        lines: &mut Vec<String>,
        status_title: Option<&String>,
        status_sent_to_user: Option<&String>,
    ) -> bool {
        let initial_len = lines.len();
        Self::append_status_line(lines, status_title);
        Self::append_status_line(lines, status_sent_to_user);
        lines.len() > initial_len
    }

    fn append_status_line(lines: &mut Vec<String>, status: Option<&String>) {
        if let Some(status) = status {
            let trimmed = status.trim();
            if trimmed.is_empty() {
                return;
            }
            let display = Self::truncate_with_ellipsis(trimmed, 160);
            if !lines.iter().any(|existing| existing.trim() == display) {
                lines.push(display);
            }
        }
    }

    pub(crate) fn launch_update_command(
        &mut self,
        command: Vec<String>,
        display: String,
        latest_version: Option<String>,
    ) -> Option<TerminalLaunch> {
        if !crate::updates::upgrade_ui_enabled() {
            return None;
        }

        self.pending_upgrade_notice = None;
        if command.is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "`/update` — no upgrade command available for this install.".to_string(),
            ));
            self.request_redraw();
            return None;
        }

        let command_text = if display.trim().is_empty() {
            strip_bash_lc_and_escape(&command)
        } else {
            display.clone()
        };

        if command_text.trim().is_empty() {
            self.history_push_plain_state(history_cell::new_error_event(
                "`/update` — unable to resolve upgrade command text.".to_string(),
            ));
            self.request_redraw();
            return None;
        }

        let id = self.terminal.alloc_id();
        if let Some(version) = &latest_version {
            self.pending_upgrade_notice = Some((id, version.clone()));
        }

        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let display_label = Self::truncate_with_ellipsis(&format!("Guided: {command_text}"), 128);

        let launch = TerminalLaunch {
            id,
            title: "Upgrade Code".to_string(),
            command: Vec::new(),
            command_display: display_label,
            controller: Some(controller.clone()),
            auto_close_on_success: false,
            start_running: true,
        };

        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_upgrade_terminal_session(
            self.app_event_tx.clone(),
            id,
            command_text,
            latest_version,
            Some(cwd),
            controller,
            controller_rx,
            self.config.clone(),
            self.config.debug,
        );

        Some(launch)
    }

    pub(crate) fn terminal_open(&mut self, launch: &TerminalLaunch) {
        let mut overlay = TerminalOverlay::new(
            launch.id,
            launch.title.clone(),
            launch.command_display.clone(),
            launch.auto_close_on_success,
        );
        if !launch.start_running {
            overlay.running = false;
        }
        let visible = self.terminal.last_visible_rows.get();
        overlay.visible_rows = visible;
        overlay.clamp_scroll();
        overlay.ensure_pending_command();
        self.terminal.overlay = Some(overlay);
        self.request_redraw();
    }

    pub(crate) fn terminal_append_chunk(&mut self, id: u64, chunk: &[u8], is_stderr: bool) {
        let mut needs_redraw = false;
        let visible = self.terminal.last_visible_rows.get();
        let visible_cols = self.terminal.last_visible_cols.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                if visible > 0 {
                    overlay.pty_rows = visible;
                }
                if visible_cols > 0 {
                    overlay.pty_cols = visible_cols;
                }
                if visible != overlay.visible_rows {
                    overlay.visible_rows = visible;
                    overlay.clamp_scroll();
                }
                overlay.append_chunk(chunk, is_stderr);
                needs_redraw = true;
            }
        }
        if needs_redraw {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_dimensions_hint(&self) -> Option<(u16, u16)> {
        let rows = self.terminal.last_visible_rows.get();
        let cols = self.terminal.last_visible_cols.get();
        if rows > 0 && cols > 0 {
            Some((rows, cols))
        } else {
            None
        }
    }

    pub(crate) fn terminal_apply_resize(&mut self, id: u64, rows: u16, cols: u16) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id && overlay.update_pty_dimensions(rows, cols) {
                self.request_redraw();
            }
        }
    }

    pub(crate) fn request_terminal_cancel(&mut self, id: u64) {
        let mut needs_redraw = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_info_message("Cancel requested…");
                if overlay.running {
                    overlay.running = false;
                    needs_redraw = true;
                }
            }
        }
        if needs_redraw {
            self.request_redraw();
        }
        self.app_event_tx.send(AppEvent::TerminalCancel { id });
    }

    pub(crate) fn terminal_update_message(&mut self, id: u64, message: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_info_message(&message);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_set_assistant_message(&mut self, id: u64, message: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.push_assistant_message(&message);
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_set_command_display(&mut self, id: u64, command: String) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.command_display = command;
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_prepare_command(
        &mut self,
        id: u64,
        suggestion: String,
        ack: Sender<TerminalCommandGate>,
    ) {
        let mut updated = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.set_pending_command(suggestion, ack);
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_accept_pending_command(&mut self) -> Option<PendingCommandAction> {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.running {
                return None;
            }
            if let Some(action) = overlay.accept_pending_command() {
                match &action {
                    PendingCommandAction::Forwarded(command)
                    | PendingCommandAction::Manual(command) => {
                        overlay.command_display = command.clone();
                    }
                }
                self.request_redraw();
                return Some(action);
            }
        }
        None
    }

    pub(crate) fn terminal_execute_manual_command(&mut self, id: u64, command: String) {
        let trimmed = command.trim();
        if trimmed.is_empty() {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.ensure_pending_command();
            }
            self.request_redraw();
            return;
        }

        if let Some(rest) = trimmed.strip_prefix("$$") {
            let prompt_text = rest.trim();
            if prompt_text.is_empty() {
                if let Some(overlay) = self.terminal.overlay_mut() {
                    overlay.push_info_message("Provide a prompt after '$'.");
                    overlay.ensure_pending_command();
                }
                self.request_redraw();
                return;
            }

            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.cancel_pending_command();
                overlay.running = true;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.push_assistant_message("Preparing guided command…");
            }

            let (controller_tx, controller_rx) = mpsc::channel();
            let controller = TerminalRunController { tx: controller_tx };
            let cwd = self.config.cwd.to_string_lossy().to_string();

            start_prompt_terminal_session(
                self.app_event_tx.clone(),
                id,
                prompt_text.to_string(),
                Some(cwd),
                controller,
                controller_rx,
                self.config.debug,
            );

            self.push_background_before_next_output(format!(
                "Terminal prompt: {prompt_text}"
            ));
            return;
        }

        let mut command_body = trimmed;
        let mut run_direct = false;
        if let Some(rest) = trimmed.strip_prefix('$') {
            let candidate = rest.trim();
            if candidate.is_empty() {
                if let Some(overlay) = self.terminal.overlay_mut() {
                    overlay.push_info_message("Provide a command after '$'.");
                    overlay.ensure_pending_command();
                }
                self.request_redraw();
                return;
            }
            command_body = candidate;
            run_direct = true;
        }

        let command_string = command_body.to_string();
        let wrapped_command = wrap_command(&command_string);
        if wrapped_command.is_empty() {
            self.app_event_tx.send(AppEvent::TerminalSetAssistantMessage {
                id,
                message: "Command could not be constructed.".to_string(),
            });
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.ensure_pending_command();
            }
            self.request_redraw();
            return;
        }

        if !matches!(self.config.sandbox_policy, SandboxPolicy::DangerFullAccess) {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.cancel_pending_command();
            }
            self.pending_manual_terminal.insert(
                id,
                PendingManualTerminal {
                    command: command_string.clone(),
                    run_direct,
                },
            );
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.push_assistant_message("Awaiting approval to run this command…");
                overlay.running = false;
            }
            let ticket = self.make_background_before_next_output_ticket();
            self.bottom_pane.push_approval_request(
                ApprovalRequest::TerminalCommand {
                    id,
                    command: command_string,
                },
                ticket,
            );
            self.request_redraw();
            return;
        }

        if run_direct && self.terminal_dimensions_hint().is_some() {
            self.start_direct_terminal_command(id, command_string, wrapped_command);
        } else {
            self.start_manual_terminal_session(id, command_string);
        }
    }

    fn start_manual_terminal_session(&mut self, id: u64, command: String) {
        if command.is_empty() {
            return;
        }
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay.cancel_pending_command();
            overlay.running = true;
            overlay.exit_code = None;
            overlay.duration = None;
        }
        let (controller_tx, controller_rx) = mpsc::channel();
        let controller = TerminalRunController { tx: controller_tx };
        let cwd = self.config.cwd.to_string_lossy().to_string();
        start_direct_terminal_session(
            self.app_event_tx.clone(),
            id,
            command,
            Some(cwd),
            controller,
            controller_rx,
            self.config.debug,
        );
    }

    fn start_direct_terminal_command(
        &mut self,
        id: u64,
        display: String,
        command: Vec<String>,
    ) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay.cancel_pending_command();
        }
        self.app_event_tx.send(AppEvent::TerminalRunCommand {
            id,
            command,
            command_display: display,
            controller: None,
        });
    }

    pub(crate) fn terminal_send_input(&mut self, id: u64, data: Vec<u8>) {
        if data.is_empty() {
            return;
        }
        self.app_event_tx
            .send(AppEvent::TerminalSendInput { id, data });
    }

    pub(crate) fn terminal_mark_running(&mut self, id: u64) {
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.running = true;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.start_time = Some(Instant::now());
                self.request_redraw();
            }
        }
    }

    pub(crate) fn terminal_finalize(
        &mut self,
        id: u64,
        exit_code: Option<i32>,
        duration: Duration,
    ) -> Option<TerminalAfter> {
        let mut success = false;
        let mut after = None;
        let mut needs_redraw = false;
        let mut should_close = false;
        let mut take_after = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id {
                overlay.cancel_pending_command();
                if visible != overlay.visible_rows {
                    overlay.visible_rows = visible;
                    overlay.clamp_scroll();
                }
                let was_following = overlay.is_following();
                overlay.finalize(exit_code, duration);
                overlay.auto_follow(was_following);
                needs_redraw = true;
                if exit_code == Some(0) {
                    success = true;
                    take_after = true;
                    if overlay.auto_close_on_success {
                        should_close = true;
                    }
                }
                overlay.ensure_pending_command();
            }
        }
        if take_after {
            after = self.terminal.after.take();
        }
        if should_close {
            self.terminal.overlay = None;
        }
        if needs_redraw {
            self.request_redraw();
        }
        if success {
            if crate::updates::upgrade_ui_enabled() {
                if let Some((pending_id, version)) = self.pending_upgrade_notice.take() {
                    if pending_id == id {
                        self.bottom_pane
                            .flash_footer_notice(format!("Upgraded to {version}"));
                        self.latest_upgrade_version = None;
                    } else {
                        self.pending_upgrade_notice = Some((pending_id, version));
                    }
                }
            }
            after
        } else {
            None
        }
    }

    pub(crate) fn terminal_prepare_rerun(&mut self, id: u64) -> bool {
        let mut reset = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.id == id && !overlay.running {
                overlay.reset_for_rerun();
                overlay.visible_rows = visible;
                overlay.clamp_scroll();
                overlay.ensure_pending_command();
                reset = true;
            }
        }
        if reset {
            self.request_redraw();
        }
        reset
    }

    pub(crate) fn handle_terminal_approval_decision(&mut self, id: u64, approved: bool) {
        let pending = self.pending_manual_terminal.remove(&id);
        if approved {
            if let Some(entry) = pending {
                if self
                    .terminal
                    .overlay()
                    .map(|overlay| overlay.id == id)
                    .unwrap_or(false)
                {
                    if let Some(overlay) = self.terminal.overlay_mut() {
                        overlay.push_assistant_message("Approval granted. Running command…");
                    }
                    if entry.run_direct && self.terminal_dimensions_hint().is_some() {
                        let command_vec = wrap_command(&entry.command);
                        self.start_direct_terminal_command(id, entry.command, command_vec);
                    } else {
                        self.start_manual_terminal_session(id, entry.command);
                    }
                    self.request_redraw();
                }
            }
            return;
        }

        if let Some(entry) = pending {
            if let Some(overlay) = self.terminal.overlay_mut() {
                overlay.push_info_message("Command was not approved. You can edit it and try again.");
                overlay.running = false;
                overlay.exit_code = None;
                overlay.duration = None;
                overlay.pending_command = Some(PendingCommand::manual_with_input(entry.command));
            }
            self.request_redraw();
        }
    }

    pub(crate) fn close_terminal_overlay(&mut self) {
        let mut cancel_id = None;
        let mut preserved_visible = None;
        let mut overlay_id = None;
        if let Some(overlay) = self.terminal.overlay_mut() {
            overlay_id = Some(overlay.id);
            if overlay.running {
                cancel_id = Some(overlay.id);
            }
            overlay.cancel_pending_command();
            preserved_visible = Some(overlay.visible_rows);
        }
        if let Some(id) = cancel_id {
            self.app_event_tx.send(AppEvent::TerminalCancel { id });
        }
        if let Some(id) = overlay_id {
            self.pending_manual_terminal.remove(&id);
        }
        if let Some(visible_rows) = preserved_visible {
            self.terminal.last_visible_rows.set(visible_rows);
        }
        self.terminal.clear();
        self.request_redraw();
    }

    pub(crate) fn terminal_overlay_id(&self) -> Option<u64> {
        self.terminal.overlay().map(|o| o.id)
    }

    pub(crate) fn terminal_overlay_active(&self) -> bool {
        self.terminal.overlay().is_some()
    }

    pub(crate) fn terminal_is_running(&self) -> bool {
        self.terminal.overlay().map(|o| o.running).unwrap_or(false)
    }

    pub(crate) fn ctrl_c_requests_exit(&self) -> bool {
        !self.terminal_overlay_active() && self.bottom_pane.ctrl_c_quit_hint_visible()
    }

    pub(crate) fn terminal_has_pending_command(&self) -> bool {
        self.terminal
            .overlay()
            .and_then(|overlay| overlay.pending_command.as_ref())
            .is_some()
    }

    pub(crate) fn terminal_handle_pending_key(&mut self, key_event: KeyEvent) -> bool {
        if self.terminal_is_running() {
            return false;
        }
        if !self.terminal_has_pending_command() {
            return false;
        }
        if !matches!(key_event.kind, KeyEventKind::Press | KeyEventKind::Repeat) {
            return true;
        }

        let mut needs_redraw = false;
        let mut handled = false;

        if let Some(overlay) = self.terminal.overlay_mut() {
            if let Some(pending) = overlay.pending_command.as_mut() {
                match key_event.code {
                    KeyCode::Char(ch) => {
                        if key_event
                            .modifiers
                            .intersects(KeyModifiers::CONTROL | KeyModifiers::ALT | KeyModifiers::SUPER)
                        {
                            handled = true;
                        } else if pending.insert_char(ch) {
                            needs_redraw = true;
                            handled = true;
                        } else {
                            handled = true;
                        }
                    }
                    KeyCode::Backspace => {
                        handled = true;
                        if pending.backspace() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Delete => {
                        handled = true;
                        if pending.delete() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Left => {
                        handled = true;
                        if pending.move_left() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Right => {
                        handled = true;
                        if pending.move_right() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Home => {
                        handled = true;
                        if pending.move_home() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::End => {
                        handled = true;
                        if pending.move_end() {
                            needs_redraw = true;
                        }
                    }
                    KeyCode::Tab => {
                        handled = true;
                    }
                    _ => {}
                }
            }
        }

        if needs_redraw {
            self.request_redraw();
        }
        handled
    }

    pub(crate) fn terminal_scroll_lines(&mut self, delta: i32) {
        let mut updated = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            let current = overlay.scroll as i32;
            let max_scroll = overlay.max_scroll() as i32;
            let mut next = current + delta;
            if next < 0 {
                next = 0;
            } else if next > max_scroll {
                next = max_scroll;
            }
            if next as u16 != overlay.scroll {
                overlay.scroll = next as u16;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_scroll_page(&mut self, direction: i32) {
        let mut delta = None;
        let visible_value = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            let visible = visible_value.max(1);
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            delta = Some((visible.saturating_sub(1)) as i32 * direction);
        }
        if let Some(amount) = delta {
            self.terminal_scroll_lines(amount);
        }
    }

    pub(crate) fn terminal_scroll_to_top(&mut self) {
        let mut updated = false;
        if let Some(overlay) = self.terminal.overlay_mut() {
            if overlay.scroll != 0 {
                overlay.scroll = 0;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn terminal_scroll_to_bottom(&mut self) {
        let mut updated = false;
        let visible = self.terminal.last_visible_rows.get();
        if let Some(overlay) = self.terminal.overlay_mut() {
            if visible != overlay.visible_rows {
                overlay.visible_rows = visible;
            }
            let max_scroll = overlay.max_scroll();
            if overlay.scroll != max_scroll {
                overlay.scroll = max_scroll;
                updated = true;
            }
        }
        if updated {
            self.request_redraw();
        }
    }

    pub(crate) fn handle_terminal_after(&mut self, after: TerminalAfter) {
        match after {
            TerminalAfter::RefreshAgentsAndClose { selected_index } => {
                self.agents_overview_selected_index = selected_index;
                self.show_agents_overview_ui();
            }
        }
    }

    // show_subagent_editor_ui removed; use show_subagent_editor_for_name or show_new_subagent_editor

    pub(crate) fn show_subagent_editor_for_name(&mut self, name: String) {
        // Build available agents from enabled ones (or sensible defaults)
        let available_agents: Vec<String> = if self.config.agents.is_empty() {
            enabled_agent_model_specs()
                .into_iter()
                .map(|spec| spec.slug.to_string())
                .collect()
        } else {
            self.config
                .agents
                .iter()
                .filter(|a| a.enabled)
                .map(|a| a.name.clone())
                .collect()
        };
        let existing = self.config.subagent_commands.clone();
        let app_event_tx = self.app_event_tx.clone();
        let build_editor = || {
            SubagentEditorView::new_with_data(
                name.clone(),
                available_agents.clone(),
                existing.clone(),
                false,
                app_event_tx.clone(),
            )
        };

        if self.try_set_agents_settings_editor(build_editor()) {
            self.request_redraw();
            return;
        }

        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_editor(build_editor());
        self.request_redraw();
    }

    pub(crate) fn show_new_subagent_editor(&mut self) {
        let available_agents: Vec<String> = if self.config.agents.is_empty() {
            enabled_agent_model_specs()
                .into_iter()
                .map(|spec| spec.slug.to_string())
                .collect()
        } else {
            self.config
                .agents
                .iter()
                .filter(|a| a.enabled)
                .map(|a| a.name.clone())
                .collect()
        };
        let existing = self.config.subagent_commands.clone();
        let app_event_tx = self.app_event_tx.clone();
        let build_editor = || {
            SubagentEditorView::new_with_data(
                String::new(),
                available_agents.clone(),
                existing.clone(),
                true,
                app_event_tx.clone(),
            )
        };

        if self.try_set_agents_settings_editor(build_editor()) {
            self.request_redraw();
            return;
        }

        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_editor(build_editor());
        self.request_redraw();
    }

    pub(crate) fn show_agent_editor_ui(&mut self, name: String) {
        if let Some(cfg) = self
            .config
            .agents
            .iter()
            .find(|a| a.name.eq_ignore_ascii_case(&name))
            .cloned()
        {
            let ro = if let Some(ref v) = cfg.args_read_only {
                Some(v.clone())
            } else if !cfg.args.is_empty() {
                Some(cfg.args.clone())
            } else {
                let d = code_core::agent_defaults::default_params_for(
                    &cfg.name, true, /*read_only*/
                );
                if d.is_empty() { None } else { Some(d) }
            };
            let wr = if let Some(ref v) = cfg.args_write {
                Some(v.clone())
            } else if !cfg.args.is_empty() {
                Some(cfg.args.clone())
            } else {
                let d = code_core::agent_defaults::default_params_for(
                    &cfg.name, false, /*read_only*/
                );
                if d.is_empty() { None } else { Some(d) }
            };
            let app_event_tx = self.app_event_tx.clone();
            let cfg_name = cfg.name.clone();
            let cfg_enabled = cfg.enabled;
            let cfg_instructions = cfg.instructions.clone();
            let cfg_command = Self::resolve_agent_command(
                &cfg.name,
                Some(cfg.command.as_str()),
                Some(cfg.command.as_str()),
            );
            let builtin = Self::is_builtin_agent(&cfg.name, &cfg_command);
            let description = Self::agent_description_for(
                &cfg.name,
                Some(&cfg_command),
                cfg.description.as_deref(),
            );
            let build_editor = || {
                AgentEditorView::new(
                    cfg_name.clone(),
                    cfg_enabled,
                    ro.clone(),
                    wr.clone(),
                    cfg_instructions.clone(),
                    description.clone(),
                    cfg_command.clone(),
                    builtin,
                    app_event_tx.clone(),
                )
            };
            if self.try_set_agents_settings_agent_editor(build_editor()) {
                self.request_redraw();
                return;
            }

            self.ensure_settings_overlay_section(SettingsSection::Agents);
            self.show_agents_overview_ui();
            let _ = self.try_set_agents_settings_agent_editor(build_editor());
            self.request_redraw();
        } else {
            // Fallback: synthesize defaults
            let cmd = Self::resolve_agent_command(&name, None, None);
            let ro = code_core::agent_defaults::default_params_for(&name, true /*read_only*/);
            let wr =
                code_core::agent_defaults::default_params_for(&name, false /*read_only*/);
            let app_event_tx = self.app_event_tx.clone();
            let description = Self::agent_description_for(&name, Some(&cmd), None);
            let builtin = Self::is_builtin_agent(&name, &cmd);
            let build_editor = || {
                AgentEditorView::new(
                    name.clone(),
                    true,
                    if ro.is_empty() { None } else { Some(ro.clone()) },
                    if wr.is_empty() { None } else { Some(wr.clone()) },
                    None,
                    description.clone(),
                    cmd.clone(),
                    builtin,
                    app_event_tx.clone(),
                )
            };
            if self.try_set_agents_settings_agent_editor(build_editor()) {
                self.request_redraw();
                return;
            }

            self.ensure_settings_overlay_section(SettingsSection::Agents);
            self.show_agents_overview_ui();
            let _ = self.try_set_agents_settings_agent_editor(build_editor());
            self.request_redraw();
        }
    }

    pub(crate) fn show_agent_editor_new_ui(&mut self) {
        let app_event_tx = self.app_event_tx.clone();
        let build_editor = || {
            AgentEditorView::new(
                String::new(),
                true,
                None,
                None,
                None,
                None,
                String::new(),
                false,
                app_event_tx.clone(),
            )
        };

        if self.try_set_agents_settings_agent_editor(build_editor()) {
            self.request_redraw();
            return;
        }

        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_agent_editor(build_editor());
        self.request_redraw();
    }

    pub(crate) fn apply_subagent_update(
        &mut self,
        cmd: code_core::config_types::SubagentCommandConfig,
    ) {
        if let Some(slot) = self
            .config
            .subagent_commands
            .iter_mut()
            .find(|c| c.name.eq_ignore_ascii_case(&cmd.name))
        {
            *slot = cmd;
        } else {
            self.config.subagent_commands.push(cmd);
        }

        self.refresh_settings_overview_rows();
    }

    pub(crate) fn delete_subagent_by_name(&mut self, name: &str) {
        self.config
            .subagent_commands
            .retain(|c| !c.name.eq_ignore_ascii_case(name));
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn apply_agent_update(
        &mut self,
        name: &str,
        enabled: bool,
        args_ro: Option<Vec<String>>,
        args_wr: Option<Vec<String>>,
        instr: Option<String>,
        description: Option<String>,
        command: String,
    ) {
        let provided_command = if command.trim().is_empty() { None } else { Some(command.as_str()) };
        let existing_index = self
            .config
            .agents
            .iter()
            .position(|a| a.name.eq_ignore_ascii_case(name));

        let existing_command = existing_index
            .and_then(|idx| self.config.agents.get(idx))
            .map(|cfg| cfg.command.clone());
        let resolved = Self::resolve_agent_command(
            name,
            provided_command,
            existing_command.as_deref(),
        );

        let mut candidate_cfg = if let Some(idx) = existing_index {
            self.config.agents.get(idx).cloned().unwrap_or_else(|| AgentConfig {
                name: name.to_string(),
                command: resolved.clone(),
                args: Vec::new(),
                read_only: false,
                enabled,
                description: description.clone(),
                env: None,
                args_read_only: args_ro.clone(),
                args_write: args_wr.clone(),
                instructions: instr.clone(),
            })
        } else {
            AgentConfig {
                name: name.to_string(),
                command: resolved.clone(),
                args: Vec::new(),
                read_only: false,
                enabled,
                description: description.clone(),
                env: None,
                args_read_only: args_ro.clone(),
                args_write: args_wr.clone(),
                instructions: instr.clone(),
            }
        };

        candidate_cfg.command = resolved.clone();
        candidate_cfg.enabled = enabled;
        candidate_cfg.description = description.clone();
        candidate_cfg.args_read_only = args_ro.clone();
        candidate_cfg.args_write = args_wr.clone();
        candidate_cfg.instructions = instr.clone();

        let pending = PendingAgentUpdate { id: Uuid::new_v4(), cfg: candidate_cfg };
        let requires_validation = !self.test_mode && existing_index.is_none();
        if requires_validation {
            self.start_agent_validation(pending);
            return;
        }

        self.commit_agent_update(pending);
    }

    fn start_agent_validation(&mut self, pending: PendingAgentUpdate) {
        let name = pending.cfg.name.clone();
        self.push_background_tail(format!(
            "🧪 Testing agent `{}` (expecting \"ok\")…",
            name
        ));
        self.pending_agent_updates.retain(|_, existing| {
            !existing.cfg.name.eq_ignore_ascii_case(&name)
        });
        let key = pending.key();
        let attempt = pending.clone();
        self.pending_agent_updates.insert(key, pending);
        self.refresh_settings_overview_rows();
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            let cfg = attempt.cfg.clone();
            let agent_name = cfg.name.clone();
            let attempt_id = attempt.id;
            let result = task::spawn_blocking(move || smoke_test_agent_blocking(cfg))
                .await
                .map_err(|e| format!("validation task failed: {e}"))
                .and_then(|res| res);
            tx.send(AppEvent::AgentValidationFinished { name: agent_name, result, attempt_id });
        });
    }

    pub(crate) fn handle_agent_validation_finished(&mut self, name: &str, attempt_id: Uuid, result: Result<(), String>) {
        let key = format!("{}:{}", name.to_ascii_lowercase(), attempt_id);
        let Some(pending) = self.pending_agent_updates.remove(&key) else {
            return;
        };

        match result {
            Ok(()) => {
                self.push_background_tail(format!(
                    "✅ Agent `{}` responded with \"ok\".",
                    name
                ));
                self.commit_agent_update(pending);
            }
            Err(err) => {
                self.history_push_plain_state(history_cell::new_error_event(format!(
                    "❌ Agent `{}` validation failed: {}",
                    name, err
                )));
                self.show_agent_editor_for_pending(&pending);
            }
        }
        self.request_redraw();
    }

    fn commit_agent_update(&mut self, pending: PendingAgentUpdate) {
        let name = pending.cfg.name.clone();
        if let Some(slot) = self
            .config
            .agents
            .iter_mut()
            .find(|a| a.name.eq_ignore_ascii_case(&name))
        {
            *slot = pending.cfg.clone();
        } else {
            self.config.agents.push(pending.cfg.clone());
        }

        self.persist_agent_config(&pending.cfg);
        self.refresh_settings_overview_rows();
        self.show_agents_overview_ui();
    }

    fn persist_agent_config(&self, cfg: &AgentConfig) {
        if let Ok(home) = code_core::config::find_code_home() {
            let name = cfg.name.clone();
            let enabled = cfg.enabled;
            let ro = cfg.args_read_only.clone();
            let wr = cfg.args_write.clone();
            let instr = cfg.instructions.clone();
            let desc = cfg.description.clone();
            let command = cfg.command.clone();
            tokio::spawn(async move {
                let _ = code_core::config_edit::upsert_agent_config(
                    &home,
                    &name,
                    Some(enabled),
                    None,
                    ro.as_deref(),
                    wr.as_deref(),
                    instr.as_deref(),
                    desc.as_deref(),
                    Some(command.as_str()),
                )
                .await;
            });
        }
    }

    fn show_agent_editor_for_pending(&mut self, pending: &PendingAgentUpdate) {
        let cfg = pending.cfg.clone();
        let app_event_tx = self.app_event_tx.clone();
        let name_value = cfg.name.clone();
        let enabled_value = cfg.enabled;
        let ro = cfg.args_read_only.clone();
        let wr = cfg.args_write.clone();
        let instructions = cfg.instructions.clone();
        let description = cfg.description.clone();
        let command = cfg.command.clone();
        let builtin = Self::is_builtin_agent(&cfg.name, &command);
        let build_editor = || {
            AgentEditorView::new(
                name_value.clone(),
                enabled_value,
                ro.clone(),
                wr.clone(),
                instructions.clone(),
                description.clone(),
                command.clone(),
                builtin,
                app_event_tx.clone(),
            )
        };
        if self.try_set_agents_settings_agent_editor(build_editor()) {
            self.request_redraw();
            return;
        }
        self.ensure_settings_overlay_section(SettingsSection::Agents);
        self.show_agents_overview_ui();
        let _ = self.try_set_agents_settings_agent_editor(build_editor());
        self.request_redraw();
    }

    fn resolve_agent_command(
        name: &str,
        provided: Option<&str>,
        existing: Option<&str>,
    ) -> String {
        let spec = agent_model_spec(name);
        if let Some(cmd) = provided {
            if let Some(resolved) = Self::normalize_agent_command(cmd, name, spec) {
                return resolved;
            }
        }
        if let Some(cmd) = existing {
            if let Some(resolved) = Self::normalize_agent_command(cmd, name, spec) {
                return resolved;
            }
        }
        if let Some(spec) = spec {
            return spec.cli.to_string();
        }
        name.to_string()
    }

    fn normalize_agent_command(
        candidate: &str,
        name: &str,
        spec: Option<&code_core::agent_defaults::AgentModelSpec>,
    ) -> Option<String> {
        if candidate.trim().is_empty() {
            return None;
        }
        if let Some(spec) = spec {
            if candidate.eq_ignore_ascii_case(name) && !spec.cli.eq_ignore_ascii_case(name) {
                return Some(spec.cli.to_string());
            }
            if candidate.eq_ignore_ascii_case(spec.slug) && !spec.cli.eq_ignore_ascii_case(spec.slug) {
                return Some(spec.cli.to_string());
            }
        }
        Some(candidate.to_string())
    }

    pub(crate) fn show_diffs_popup(&mut self) {
        use crate::diff_render::create_diff_details_only;
        // Build a latest-first unique file list
        let mut order: Vec<PathBuf> = Vec::new();
        let mut seen: std::collections::HashSet<PathBuf> = std::collections::HashSet::new();
        for changes in self.diffs.session_patch_sets.iter().rev() {
            for (path, change) in changes.iter() {
                // If this change represents a move/rename, show the destination path in the tabs
                let display_path: PathBuf = match change {
                    code_core::protocol::FileChange::Update {
                        move_path: Some(dest),
                        ..
                    } => dest.clone(),
                    _ => path.clone(),
                };
                if seen.insert(display_path.clone()) {
                    order.push(display_path);
                }
            }
        }
        // Build tabs: for each file, create a single unified diff against the original baseline
        let mut tabs: Vec<(String, Vec<DiffBlock>)> = Vec::new();
        for path in order {
            // Resolve baseline (first-seen content) and current (on-disk) content
            let baseline = self
                .diffs
                .baseline_file_contents
                .get(&path)
                .cloned()
                .unwrap_or_default();
            let current = std::fs::read_to_string(&path).unwrap_or_default();
            // Build a unified diff from baseline -> current
            let unified = diffy::create_patch(&baseline, &current).to_string();
            // Render detailed lines (no header) using our diff renderer helpers
            let mut single = HashMap::new();
            single.insert(
                path.clone(),
                code_core::protocol::FileChange::Update {
                    unified_diff: unified.clone(),
                    move_path: None,
                    original_content: baseline.clone(),
                    new_content: current.clone(),
                },
            );
            let detail = create_diff_details_only(&single);
            let mut blocks: Vec<DiffBlock> = vec![DiffBlock { lines: detail }];

            // Count adds/removes for the header label from the unified diff
            let mut total_added: usize = 0;
            let mut total_removed: usize = 0;
            if let Ok(patch) = diffy::Patch::from_str(&unified) {
                for h in patch.hunks() {
                    for l in h.lines() {
                        match l {
                            diffy::Line::Insert(_) => total_added += 1,
                            diffy::Line::Delete(_) => total_removed += 1,
                            _ => {}
                        }
                    }
                }
            } else {
                for l in unified.lines() {
                    if l.starts_with("+++") || l.starts_with("---") || l.starts_with("@@") {
                        continue;
                    }
                    if let Some(b) = l.as_bytes().first() {
                        if *b == b'+' {
                            total_added += 1;
                        } else if *b == b'-' {
                            total_removed += 1;
                        }
                    }
                }
            }
            // Prepend a header block with the full path and counts
            let header_line = {
                use ratatui::style::Modifier;
                use ratatui::style::Style;
                use ratatui::text::Line as RtLine;
                use ratatui::text::Span as RtSpan;
                let mut spans: Vec<RtSpan<'static>> = Vec::new();
                spans.push(RtSpan::styled(
                    path.display().to_string(),
                    Style::default()
                        .fg(crate::colors::text())
                        .add_modifier(Modifier::BOLD),
                ));
                spans.push(RtSpan::raw(" "));
                spans.push(RtSpan::styled(
                    format!("+{}", total_added),
                    Style::default().fg(crate::colors::success()),
                ));
                spans.push(RtSpan::raw(" "));
                spans.push(RtSpan::styled(
                    format!("-{}", total_removed),
                    Style::default().fg(crate::colors::error()),
                ));
                RtLine::from(spans)
            };
            blocks.insert(
                0,
                DiffBlock {
                    lines: vec![header_line],
                },
            );

            // Tab title: file name only
            let title = path
                .file_name()
                .and_then(|s| s.to_str())
                .map(|s| s.to_string())
                .unwrap_or_else(|| path.display().to_string());
            tabs.push((title, blocks));
        }
        if tabs.is_empty() {
            // Nothing to show — surface a small notice so Ctrl+D feels responsive
            self.bottom_pane
                .flash_footer_notice("No diffs recorded this session".to_string());
            return;
        }
        self.diffs.overlay = Some(DiffOverlay::new(tabs));
        self.diffs.confirm = None;
        self.request_redraw();
    }

    pub(crate) fn toggle_diffs_popup(&mut self) {
        if self.diffs.overlay.is_some() {
            self.diffs.overlay = None;
            self.request_redraw();
        } else {
            self.show_diffs_popup();
        }
    }

    pub(crate) fn show_help_popup(&mut self) {
        let t_dim = Style::default().fg(crate::colors::text_dim());
        let t_fg = Style::default().fg(crate::colors::text());

        let mut lines: Vec<RtLine<'static>> = Vec::new();
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Keyboard shortcuts",
            t_fg.add_modifier(Modifier::BOLD),
        )]));

        let kv = |k: &str, v: &str| -> RtLine<'static> {
            RtLine::from(vec![
                // Left-align the key column for improved readability
                RtSpan::styled(format!("{k:<12}"), t_fg),
                RtSpan::raw("  —  "),
                RtSpan::styled(v.to_string(), t_dim),
            ])
        };
        // Top quick action
        lines.push(kv(
            "Shift+Tab",
            "Rotate agent between Read Only / Write with Approval / Full Access",
        ));

        // Global
        lines.push(kv("Ctrl+G", "Guide overlay"));
        lines.push(kv("Ctrl+R", "Toggle reasoning"));
        lines.push(kv("Ctrl+T", "Toggle screen"));
        lines.push(kv("Ctrl+D", "Diff viewer"));
        lines.push(kv("Esc", &format!("{} / close popups", Self::double_esc_hint_label())));
        // Task control shortcuts
        lines.push(kv("Esc", "End current task"));
        lines.push(kv("Ctrl+C", "End current task"));
        lines.push(kv("Ctrl+C twice", "Quit"));
        lines.push(RtLine::from(""));

        // Composer
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Compose field",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("Enter", "Send message"));
        lines.push(kv("Ctrl+J", "Insert newline"));
        lines.push(kv("Shift+Enter", "Insert newline"));
        // Split combined shortcuts into separate rows for readability
        lines.push(kv("Shift+Up", "Browse input history"));
        lines.push(kv("Shift+Down", "Browse input history"));
        lines.push(kv("Ctrl+B", "Move left"));
        lines.push(kv("Ctrl+F", "Move right"));
        lines.push(kv("Alt+Left", "Move by word"));
        lines.push(kv("Alt+Right", "Move by word"));
        // Simplify delete shortcuts; remove Alt+Backspace/Backspace/Delete variants
        lines.push(kv("Ctrl+W", "Delete previous word"));
        lines.push(kv("Ctrl+H", "Delete previous char"));
        lines.push(kv("Ctrl+D", "Delete next char"));
        lines.push(kv("Ctrl+Backspace", "Delete current line"));
        lines.push(kv("Ctrl+U", "Delete to line start"));
        lines.push(kv("Ctrl+K", "Delete to line end"));
        lines.push(kv(
            "Home/End",
            "Jump to line start/end (jump to history start/end when input is empty)",
        ));
        lines.push(RtLine::from(""));

        lines.push(RtLine::from(vec![RtSpan::styled(
            "Terminal",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("$", "Open shell terminal without a preset command"));
        lines.push(kv("$ <command>", "Run shell command immediately"));
        lines.push(kv("$$ <prompt>", "Request guided shell command help"));
        lines.push(RtLine::from(""));

        // Panels
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Panels",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        lines.push(kv("Ctrl+B", "Toggle Browser overlay"));
        lines.push(kv("Ctrl+A", "Open Agents terminal"));

        // Slash command reference
        lines.push(RtLine::from(""));
        lines.push(RtLine::from(vec![RtSpan::styled(
            "Slash commands",
            t_fg.add_modifier(Modifier::BOLD),
        )]));
        for (cmd_str, cmd) in crate::slash_command::built_in_slash_commands() {
            // Hide internal test command from the Help panel
            if cmd_str == "test-approval" {
                continue;
            }
            // Prefer "Code" branding in the Help panel
            let desc = cmd.description().replace("Codex", "Code");
            // Render as "/command  —  description"
            lines.push(RtLine::from(vec![
                RtSpan::styled(format!("/{cmd_str:<12}"), t_fg),
                RtSpan::raw("  —  "),
                RtSpan::styled(desc.to_string(), t_dim),
            ]));
        }

        self.help.overlay = Some(HelpOverlay::new(lines));
        self.request_redraw();
    }

    pub(crate) fn toggle_help_popup(&mut self) {
        if self.help.overlay.is_some() {
            self.help.overlay = None;
        } else {
            self.show_help_popup();
        }
        self.request_redraw();
    }

    fn available_model_presets(&self) -> Vec<ModelPreset> {
        if let Some(presets) = self.remote_model_presets.as_ref() {
            return presets.clone();
        }
        let auth_mode = if self.config.using_chatgpt_auth {
            Some(McpAuthMode::ChatGPT)
        } else {
            Some(McpAuthMode::ApiKey)
        };
        builtin_model_presets(auth_mode)
    }

    pub(crate) fn update_model_presets(
        &mut self,
        presets: Vec<ModelPreset>,
        default_model: Option<String>,
    ) {
        if presets.is_empty() {
            return;
        }

        self.remote_model_presets = Some(presets.clone());
        self.bottom_pane.update_model_selection_presets(presets);

        if let Some(default_model) = default_model {
            self.maybe_apply_remote_default_model(default_model);
        }

        self.request_redraw();
    }

    fn maybe_apply_remote_default_model(&mut self, default_model: String) {
        if !self.allow_remote_default_at_startup {
            return;
        }
        if self.chat_model_selected_explicitly {
            return;
        }
        if self.config.model_explicit {
            return;
        }
        if self.config.model.eq_ignore_ascii_case(&default_model) {
            return;
        }

        self.apply_model_selection_inner(default_model, None, false, false);
    }

    fn preset_effort_for_model(preset: &ModelPreset) -> ReasoningEffort {
        preset.default_reasoning_effort.into()
    }

    fn clamp_reasoning_for_model(model: &str, requested: ReasoningEffort) -> ReasoningEffort {
        let protocol_effort: code_protocol::config_types::ReasoningEffort = requested.into();
        let clamped = clamp_reasoning_effort_for_model(model, protocol_effort);
        ReasoningEffort::from(clamped)
    }

    fn find_model_preset(&self, input: &str, presets: &[ModelPreset]) -> Option<ModelPreset> {
        if presets.is_empty() {
            return None;
        }

        let input_lower = input.to_ascii_lowercase();
        let collapsed_input: String = input_lower
            .chars()
            .filter(|c| !c.is_ascii_whitespace() && *c != '-')
            .collect();

        let mut fallback_medium: Option<ModelPreset> = None;
        let mut fallback_first: Option<ModelPreset> = None;

        for preset in presets.iter() {
            let preset_effort = Self::preset_effort_for_model(preset);

            let id_lower = preset.id.to_ascii_lowercase();
            if Self::candidate_matches(&input_lower, &collapsed_input, &id_lower) {
                return Some(preset.clone());
            }

            let display_name_lower = preset.display_name.to_ascii_lowercase();
            if Self::candidate_matches(&input_lower, &collapsed_input, &display_name_lower) {
                return Some(preset.clone());
            }

            let effort_lower = preset_effort.to_string().to_ascii_lowercase();
            let model_lower = preset.model.to_ascii_lowercase();
            let spaced = format!("{model_lower} {effort_lower}");
            if Self::candidate_matches(&input_lower, &collapsed_input, &spaced) {
                return Some(preset.clone());
            }
            let dashed = format!("{model_lower}-{effort_lower}");
            if Self::candidate_matches(&input_lower, &collapsed_input, &dashed) {
                return Some(preset.clone());
            }

            if model_lower == input_lower
                || Self::candidate_matches(&input_lower, &collapsed_input, &model_lower)
            {
                if fallback_medium.is_none() && preset_effort == ReasoningEffort::Medium {
                    fallback_medium = Some(preset.clone());
                }
                if fallback_first.is_none() {
                    fallback_first = Some(preset.clone());
                }
            }
        }

        fallback_medium.or(fallback_first)
    }

    fn candidate_matches(input: &str, collapsed_input: &str, candidate: &str) -> bool {
        let candidate_lower = candidate.to_ascii_lowercase();
        if candidate_lower == input {
            return true;
        }
        let candidate_collapsed: String = candidate_lower
            .chars()
            .filter(|c| !c.is_ascii_whitespace() && *c != '-')
            .collect();
        candidate_collapsed == collapsed_input
    }

    pub(crate) fn handle_model_command(&mut self, command_args: String) {
        if self.is_task_running() {
            let message = "'/model' is disabled while a task is in progress.".to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        let presets = self.available_model_presets();
        if presets.is_empty() {
            let message =
                "No model presets are available. Update your configuration to define models."
                    .to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        let trimmed = command_args.trim();
        if !trimmed.is_empty() {
            if let Some(preset) = self.find_model_preset(trimmed, &presets) {
                let effort = Self::preset_effort_for_model(&preset);
                self.apply_model_selection(preset.model.to_string(), Some(effort));
            } else {
                let message = format!(
                    "Unknown model preset: '{}'. Use /model with no arguments to open the selector.",
                    trimmed
                );
                self.history_push_plain_state(history_cell::new_error_event(message));
            }
            return;
        }

        self.bottom_pane.show_model_selection(
            presets,
            self.config.model.clone(),
            self.config.model_reasoning_effort,
            false,
            ModelSelectionTarget::Session,
        );
    }

    pub(crate) fn show_review_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for review. Update configuration to define models."
                    .to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::Review);
            self.close_settings_overlay();
        }
        self.bottom_pane.show_model_selection(
            presets,
            self.config.review_model.clone(),
            self.config.review_model_reasoning_effort,
            self.config.review_use_chat_model,
            ModelSelectionTarget::Review,
        );
    }

    pub(crate) fn show_review_resolve_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for review resolution.".to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::Review);
            self.close_settings_overlay();
        }
        let current = if self.config.review_resolve_use_chat_model {
            self.config.model.clone()
        } else {
            self.config.review_resolve_model.clone()
        };
        let effort = if self.config.review_resolve_use_chat_model {
            self.config.model_reasoning_effort
        } else {
            self.config.review_resolve_model_reasoning_effort
        };
        self.bottom_pane.show_model_selection(
            presets,
            current,
            effort,
            self.config.review_resolve_use_chat_model,
            ModelSelectionTarget::ReviewResolve,
        );
    }

    pub(crate) fn show_auto_review_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for Auto Review. Update configuration to define models.".to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::Review);
            self.close_settings_overlay();
        }
        let current = if self.config.auto_review_use_chat_model {
            self.config.model.clone()
        } else {
            self.config.auto_review_model.clone()
        };
        let effort = if self.config.auto_review_use_chat_model {
            self.config.model_reasoning_effort
        } else {
            self.config.auto_review_model_reasoning_effort
        };
        self.bottom_pane.show_model_selection(
            presets,
            current,
            effort,
            self.config.auto_review_use_chat_model,
            ModelSelectionTarget::AutoReview,
        );
    }

    pub(crate) fn show_auto_review_resolve_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for Auto Review resolution.".to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::Review);
            self.close_settings_overlay();
        }
        let current = if self.config.auto_review_resolve_use_chat_model {
            self.config.model.clone()
        } else {
            self.config.auto_review_resolve_model.clone()
        };
        let effort = if self.config.auto_review_resolve_use_chat_model {
            self.config.model_reasoning_effort
        } else {
            self.config.auto_review_resolve_model_reasoning_effort
        };
        self.bottom_pane.show_model_selection(
            presets,
            current,
            effort,
            self.config.auto_review_resolve_use_chat_model,
            ModelSelectionTarget::AutoReviewResolve,
        );
    }

    pub(crate) fn show_planning_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for planning. Update configuration to define models."
                    .to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::Planning);
            self.close_settings_overlay();
        }
        let current = if self.config.planning_use_chat_model {
            self.config.model.clone()
        } else {
            self.config.planning_model.clone()
        };
        let effort = self.config.planning_model_reasoning_effort;
        self.bottom_pane
            .show_model_selection(
                presets,
                current,
                effort,
                self.config.planning_use_chat_model,
                ModelSelectionTarget::Planning,
            );
    }

    pub(crate) fn show_auto_drive_model_selector(&mut self) {
        let presets = self.available_model_presets();
        if presets.is_empty() {
            self.bottom_pane.flash_footer_notice(
                "No model presets are available for Auto Drive. Update configuration to define models."
                    .to_string(),
            );
            return;
        }
        if self.settings.overlay.is_some() {
            self.pending_settings_return = Some(SettingsSection::AutoDrive);
            self.close_settings_overlay();
        }
        self.bottom_pane.show_model_selection(
            presets,
            self.config.auto_drive.model.clone(),
            self.config.auto_drive.model_reasoning_effort,
            self.config.auto_drive_use_chat_model,
            ModelSelectionTarget::AutoDrive,
        );
    }

    pub(crate) fn apply_model_selection(&mut self, model: String, effort: Option<ReasoningEffort>) {
        self.apply_model_selection_inner(model, effort, true, true);
    }

    fn clamp_reasoning_for_model_from_presets(
        model: &str,
        requested: ReasoningEffort,
        presets: &[ModelPreset],
    ) -> ReasoningEffort {
        fn rank(effort: ReasoningEffort) -> u8 {
            match effort {
                ReasoningEffort::Minimal => 0,
                ReasoningEffort::Low => 1,
                ReasoningEffort::Medium => 2,
                ReasoningEffort::High => 3,
                ReasoningEffort::XHigh => 4,
                ReasoningEffort::None => 5,
            }
        }

        let model_lower = model.to_ascii_lowercase();
        let Some(preset) = presets.iter().find(|preset| {
            preset.model.eq_ignore_ascii_case(&model_lower)
                || preset.id.eq_ignore_ascii_case(&model_lower)
                || preset.display_name.eq_ignore_ascii_case(&model_lower)
        }) else {
            return Self::clamp_reasoning_for_model(model, requested);
        };

        let supported: Vec<ReasoningEffort> = preset
            .supported_reasoning_efforts
            .iter()
            .map(|opt| ReasoningEffort::from(opt.effort))
            .collect();
        if supported.iter().any(|effort| *effort == requested) {
            return requested;
        }

        let requested_rank = rank(requested);
        supported
            .into_iter()
            .min_by_key(|effort| {
                let effort_rank = rank(*effort);
                (requested_rank.abs_diff(effort_rank), u8::MAX - effort_rank)
            })
            .unwrap_or(requested)
    }

    fn apply_model_selection_inner(
        &mut self,
        model: String,
        effort: Option<ReasoningEffort>,
        mark_explicit: bool,
        announce: bool,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        if mark_explicit {
            self.chat_model_selected_explicitly = true;
            self.config.model_explicit = true;
        }

        let mut updated = false;
        if !self.config.model.eq_ignore_ascii_case(trimmed) {
            self.config.model = trimmed.to_string();
            let family = find_family_for_model(&self.config.model)
                .unwrap_or_else(|| derive_default_model_family(&self.config.model));
            self.config.model_family = family;
            updated = true;
        }

        if let Some(explicit) = effort {
            if self.config.preferred_model_reasoning_effort != Some(explicit) {
                self.config.preferred_model_reasoning_effort = Some(explicit);
                updated = true;
            }
        }

        let requested_effort = effort
            .or(self.config.preferred_model_reasoning_effort)
            .unwrap_or(self.config.model_reasoning_effort);
        let presets = self.available_model_presets();
        let clamped_effort = Self::clamp_reasoning_for_model_from_presets(trimmed, requested_effort, &presets);

        if self.config.model_reasoning_effort != clamped_effort {
            self.config.model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if updated {
            let op = Op::ConfigureSession {
                provider: self.config.model_provider.clone(),
                model: self.config.model.clone(),
                model_explicit: self.config.model_explicit,
                model_reasoning_effort: self.config.model_reasoning_effort,
                preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
                model_reasoning_summary: self.config.model_reasoning_summary,
                model_text_verbosity: self.config.model_text_verbosity,
                user_instructions: self.config.user_instructions.clone(),
                base_instructions: self.config.base_instructions.clone(),
                approval_policy: self.config.approval_policy.clone(),
                sandbox_policy: self.config.sandbox_policy.clone(),
                disable_response_storage: self.config.disable_response_storage,
                notify: self.config.notify.clone(),
                cwd: self.config.cwd.clone(),
                resume_path: None,
                demo_developer_message: self.config.demo_developer_message.clone(),
            };
            self.submit_op(op);

            self.sync_follow_chat_models();
            self.refresh_settings_overview_rows();
        }

        if announce {
            let placement = self.ui_placement_for_now();
            let state = history_cell::new_model_output(&self.config.model, self.config.model_reasoning_effort);
            let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
            self.push_system_cell(
                Box::new(cell),
                placement,
                Some("ui:model".to_string()),
                None,
                "system",
                Some(HistoryDomainRecord::Plain(state)),
            );
        }

        self.request_redraw();
    }

    fn sync_follow_chat_models(&mut self) {
        if self.config.review_use_chat_model {
            self.config.review_model = self.config.model.clone();
            self.config.review_model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_review_settings_model_row();
        }

        if self.config.review_resolve_use_chat_model {
            self.config.review_resolve_model = self.config.model.clone();
            self.config.review_resolve_model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_review_settings_model_row();
        }

        if self.config.planning_use_chat_model {
            self.config.planning_model = self.config.model.clone();
            self.config.planning_model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_planning_settings_model_row();
        }

        if self.config.auto_drive_use_chat_model {
            self.config.auto_drive.model = self.config.model.clone();
            self.config.auto_drive.model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_auto_drive_settings_model_row();
        }

        if self.config.auto_review_use_chat_model {
            self.config.auto_review_model = self.config.model.clone();
            self.config.auto_review_model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_review_settings_model_row();
        }

        if self.config.auto_review_resolve_use_chat_model {
            self.config.auto_review_resolve_model = self.config.model.clone();
            self.config.auto_review_resolve_model_reasoning_effort = self.config.model_reasoning_effort;
            self.update_review_settings_model_row();
        }
    }

    pub(crate) fn apply_review_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.review_use_chat_model = false;

        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self.config.review_model.eq_ignore_ascii_case(trimmed) {
            self.config.review_model = trimmed.to_string();
            updated = true;
        }

        if self.config.review_model_reasoning_effort != clamped_effort {
            self.config.review_model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Review model unchanged.".to_string());
            return;
        }

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_review_model(
                &home,
                &self.config.review_model,
                self.config.review_model_reasoning_effort,
                self.config.review_use_chat_model,
            ) {
                Ok(_) => format!(
                    "Review model set to {} ({} reasoning)",
                    self.config.review_model,
                    Self::format_reasoning_effort(self.config.review_model_reasoning_effort)
                ),
                Err(err) => {
                    tracing::warn!("Failed to persist review model: {err}");
                    format!(
                        "Review model set for this session (failed to persist): {}",
                        self.config.review_model
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Code home to persist review model");
            format!(
                "Review model set for this session: {}",
                self.config.review_model
            )
        };

        self.bottom_pane.flash_footer_notice(message);
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn apply_review_resolve_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.review_resolve_use_chat_model = false;

        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self
            .config
            .review_resolve_model
            .eq_ignore_ascii_case(trimmed)
        {
            self.config.review_resolve_model = trimmed.to_string();
            updated = true;
        }

        if self.config.review_resolve_model_reasoning_effort != clamped_effort {
            self.config.review_resolve_model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Resolve model unchanged.".to_string());
            return;
        }

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_review_resolve_model(
                &home,
                &self.config.review_resolve_model,
                self.config.review_resolve_model_reasoning_effort,
                self.config.review_resolve_use_chat_model,
            ) {
                Ok(_) => format!(
                    "Resolve model set to {} ({} reasoning)",
                    self.config.review_resolve_model,
                    Self::format_reasoning_effort(self.config.review_resolve_model_reasoning_effort)
                ),
                Err(err) => {
                    tracing::warn!("Failed to persist resolve model: {err}");
                    format!(
                        "Resolve model set for this session (failed to persist): {}",
                        self.config.review_resolve_model
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Code home to persist resolve model");
            format!(
                "Resolve model set for this session: {}",
                self.config.review_resolve_model
            )
        };

        self.bottom_pane.flash_footer_notice(message);
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn set_review_use_chat_model(&mut self, use_chat: bool) {
        if self.config.review_use_chat_model == use_chat {
            return;
        }
        self.config.review_use_chat_model = use_chat;
        if use_chat {
            self.config.review_model = self.config.model.clone();
            self.config.review_model_reasoning_effort = self.config.model_reasoning_effort;
        }

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_review_model(
                &home,
                &self.config.review_model,
                self.config.review_model_reasoning_effort,
                use_chat,
            ) {
                tracing::warn!("Failed to persist review use-chat toggle: {err}");
            }
        }

        let notice = if use_chat {
            "Review model now follows Chat model".to_string()
        } else {
            format!(
                "Review model set to {} ({} reasoning)",
                self.config.review_model,
                Self::format_reasoning_effort(self.config.review_model_reasoning_effort)
            )
        };
        self.bottom_pane.flash_footer_notice(notice);
        self.update_review_settings_model_row();
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn set_review_resolve_use_chat_model(&mut self, use_chat: bool) {
        if self.config.review_resolve_use_chat_model == use_chat {
            return;
        }
        self.config.review_resolve_use_chat_model = use_chat;
        if use_chat {
            self.config.review_resolve_model = self.config.model.clone();
            self.config.review_resolve_model_reasoning_effort = self.config.model_reasoning_effort;
        }

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_review_resolve_model(
                &home,
                &self.config.review_resolve_model,
                self.config.review_resolve_model_reasoning_effort,
                use_chat,
            ) {
                tracing::warn!("Failed to persist resolve use-chat toggle: {err}");
            }
        }

        let notice = if use_chat {
            "Resolve model now follows Chat model".to_string()
        } else {
            format!(
                "Resolve model set to {} ({} reasoning)",
                self.config.review_resolve_model,
                Self::format_reasoning_effort(self.config.review_resolve_model_reasoning_effort)
            )
        };
        self.bottom_pane.flash_footer_notice(notice);
        self.update_review_settings_model_row();
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn apply_auto_review_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.auto_review_use_chat_model = false;
        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self
            .config
            .auto_review_model
            .eq_ignore_ascii_case(trimmed)
        {
            self.config.auto_review_model = trimmed.to_string();
            updated = true;
        }

        if self.config.auto_review_model_reasoning_effort != clamped_effort {
            self.config.auto_review_model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Auto Review model unchanged.".to_string());
            return;
        }

        let notice = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_auto_review_model(
                &home,
                &self.config.auto_review_model,
                self.config.auto_review_model_reasoning_effort,
                self.config.auto_review_use_chat_model,
            ) {
                Ok(_) => format!(
                    "Auto Review model set to {} ({} reasoning)",
                    self.config.auto_review_model,
                    Self::format_reasoning_effort(self.config.auto_review_model_reasoning_effort)
                ),
                Err(err) => {
                    tracing::warn!("Failed to persist Auto Review model: {err}");
                    format!(
                        "Auto Review model set for this session (failed to persist): {}",
                        self.config.auto_review_model
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Code home to persist Auto Review model");
            format!(
                "Auto Review model set for this session: {}",
                self.config.auto_review_model
            )
        };

        self.bottom_pane.flash_footer_notice(notice);
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn set_auto_review_use_chat_model(&mut self, use_chat: bool) {
        if self.config.auto_review_use_chat_model == use_chat {
            return;
        }
        self.config.auto_review_use_chat_model = use_chat;
        if use_chat {
            self.config.auto_review_model = self.config.model.clone();
            self.config.auto_review_model_reasoning_effort = self.config.model_reasoning_effort;
        }

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_auto_review_model(
                &home,
                &self.config.auto_review_model,
                self.config.auto_review_model_reasoning_effort,
                use_chat,
            ) {
                tracing::warn!("Failed to persist Auto Review use-chat toggle: {err}");
            }
        }

        let notice = if use_chat {
            "Auto Review model now follows Chat model".to_string()
        } else {
            format!(
                "Auto Review model set to {} ({} reasoning)",
                self.config.auto_review_model,
                Self::format_reasoning_effort(self.config.auto_review_model_reasoning_effort)
            )
        };
        self.bottom_pane.flash_footer_notice(notice);
        self.update_review_settings_model_row();
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn apply_auto_review_resolve_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.auto_review_resolve_use_chat_model = false;
        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self
            .config
            .auto_review_resolve_model
            .eq_ignore_ascii_case(trimmed)
        {
            self.config.auto_review_resolve_model = trimmed.to_string();
            updated = true;
        }

        if self.config.auto_review_resolve_model_reasoning_effort != clamped_effort {
            self.config.auto_review_resolve_model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Auto Review resolve model unchanged.".to_string());
            return;
        }

        let notice = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_auto_review_resolve_model(
                &home,
                &self.config.auto_review_resolve_model,
                self.config.auto_review_resolve_model_reasoning_effort,
                self.config.auto_review_resolve_use_chat_model,
            ) {
                Ok(_) => format!(
                    "Auto Review resolve model set to {} ({} reasoning)",
                    self.config.auto_review_resolve_model,
                    Self::format_reasoning_effort(self.config.auto_review_resolve_model_reasoning_effort)
                ),
                Err(err) => {
                    tracing::warn!("Failed to persist Auto Review resolve model: {err}");
                    format!(
                        "Auto Review resolve model set for this session (failed to persist): {}",
                        self.config.auto_review_resolve_model
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Code home to persist Auto Review resolve model");
            format!(
                "Auto Review resolve model set for this session: {}",
                self.config.auto_review_resolve_model
            )
        };

        self.bottom_pane.flash_footer_notice(notice);
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn set_auto_review_resolve_use_chat_model(&mut self, use_chat: bool) {
        if self.config.auto_review_resolve_use_chat_model == use_chat {
            return;
        }
        self.config.auto_review_resolve_use_chat_model = use_chat;
        if use_chat {
            self.config.auto_review_resolve_model = self.config.model.clone();
            self.config.auto_review_resolve_model_reasoning_effort =
                self.config.model_reasoning_effort;
        }

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_auto_review_resolve_model(
                &home,
                &self.config.auto_review_resolve_model,
                self.config.auto_review_resolve_model_reasoning_effort,
                use_chat,
            ) {
                tracing::warn!("Failed to persist Auto Review resolve use-chat toggle: {err}");
            }
        }

        let notice = if use_chat {
            "Auto Review resolve model now follows Chat model".to_string()
        } else {
            format!(
                "Auto Review resolve model set to {} ({} reasoning)",
                self.config.auto_review_resolve_model,
                Self::format_reasoning_effort(self.config.auto_review_resolve_model_reasoning_effort)
            )
        };
        self.bottom_pane.flash_footer_notice(notice);
        self.update_review_settings_model_row();
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn set_auto_drive_use_chat_model(&mut self, use_chat: bool) {
        if self.config.auto_drive_use_chat_model == use_chat {
            return;
        }
        self.config.auto_drive_use_chat_model = use_chat;
        if use_chat {
            self.config.auto_drive.model = self.config.model.clone();
            self.config.auto_drive.model_reasoning_effort = self.config.model_reasoning_effort;
        }

        self.restore_auto_resolve_attempts_if_lost();

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_auto_drive_settings(
                &home,
                &self.config.auto_drive,
                use_chat,
            ) {
                tracing::warn!("Failed to persist Auto Drive use-chat toggle: {err}");
            }
        }

        let notice = if use_chat {
            "Auto Drive model now follows Chat model".to_string()
        } else {
            format!(
                "Auto Drive model set to {} ({} reasoning)",
                self.config.auto_drive.model,
                Self::format_reasoning_effort(self.config.auto_drive.model_reasoning_effort)
            )
        };

        self.bottom_pane.flash_footer_notice(notice);
        self.refresh_settings_overview_rows();
        self.update_auto_drive_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn handle_model_selection_closed(&mut self, target: ModelSelectionKind, _accepted: bool) {
        let expected_section = match target {
            ModelSelectionKind::Session => SettingsSection::Model,
            ModelSelectionKind::Review => SettingsSection::Review,
            ModelSelectionKind::Planning => SettingsSection::Planning,
            ModelSelectionKind::AutoDrive => SettingsSection::AutoDrive,
            ModelSelectionKind::ReviewResolve => SettingsSection::Review,
            ModelSelectionKind::AutoReview => SettingsSection::Review,
            ModelSelectionKind::AutoReviewResolve => SettingsSection::Review,
        };

        if let Some(section) = self.pending_settings_return {
            if section == expected_section {
                self.ensure_settings_overlay_section(section);
            }
            self.pending_settings_return = None;
        }

        self.request_redraw();
    }

    pub(crate) fn apply_planning_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.planning_use_chat_model = false;

        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self.config.planning_model.eq_ignore_ascii_case(trimmed) {
            self.config.planning_model = trimmed.to_string();
            updated = true;
        }
        if self.config.planning_model_reasoning_effort != clamped_effort {
            self.config.planning_model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Planning model unchanged.".to_string());
            return;
        }

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_planning_model(
                &home,
                &self.config.planning_model,
                self.config.planning_model_reasoning_effort,
                false,
            ) {
                tracing::warn!("Failed to persist planning model: {err}");
            }
        }

        self.bottom_pane.flash_footer_notice(format!(
            "Planning model set to {} ({} reasoning)",
            self.config.planning_model,
            Self::format_reasoning_effort(self.config.planning_model_reasoning_effort)
        ));
        self.refresh_settings_overview_rows();
        self.update_planning_settings_model_row();
        // If we're currently in plan mode, switch the session model immediately.
        if matches!(self.config.sandbox_policy, code_core::protocol::SandboxPolicy::ReadOnly) {
            self.apply_planning_session_model();
        }
        self.request_redraw();
    }

    fn apply_planning_session_model(&mut self) {
        if self.config.planning_use_chat_model {
            self.restore_planning_session_model();
            return;
        }

        // If we're already on the planning model, do nothing.
        if self.config.model.eq_ignore_ascii_case(&self.config.planning_model)
            && self.config.model_reasoning_effort == self.config.planning_model_reasoning_effort
        {
            return;
        }

        // Save current chat model to restore later.
        self.planning_restore = Some((
            self.config.model.clone(),
            self.config.model_reasoning_effort,
        ));

        self.config.model = self.config.planning_model.clone();
        self.config.model_reasoning_effort = self.config.planning_model_reasoning_effort;

        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_explicit: self.config.model_explicit,
            model_reasoning_effort: self.config.model_reasoning_effort,
            preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
            demo_developer_message: self.config.demo_developer_message.clone(),
        };
        self.submit_op(op);
    }

    fn restore_planning_session_model(&mut self) {
        if let Some((model, effort)) = self.planning_restore.take() {
            self.config.model = model;
            self.config.model_reasoning_effort = effort;

            let op = Op::ConfigureSession {
                provider: self.config.model_provider.clone(),
                model: self.config.model.clone(),
                model_explicit: self.config.model_explicit,
                model_reasoning_effort: self.config.model_reasoning_effort,
                preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
                model_reasoning_summary: self.config.model_reasoning_summary,
                model_text_verbosity: self.config.model_text_verbosity,
                user_instructions: self.config.user_instructions.clone(),
                base_instructions: self.config.base_instructions.clone(),
                approval_policy: self.config.approval_policy.clone(),
                sandbox_policy: self.config.sandbox_policy.clone(),
                disable_response_storage: self.config.disable_response_storage,
                notify: self.config.notify.clone(),
                cwd: self.config.cwd.clone(),
                resume_path: None,
                demo_developer_message: self.config.demo_developer_message.clone(),
            };
            self.submit_op(op);
        }
    }

    pub(crate) fn set_planning_use_chat_model(&mut self, use_chat: bool) {
        if self.config.planning_use_chat_model == use_chat {
            return;
        }
        self.config.planning_use_chat_model = use_chat;

        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(err) = code_core::config::set_planning_model(
                &home,
                &self.config.planning_model,
                self.config.planning_model_reasoning_effort,
                use_chat,
            ) {
                tracing::warn!("Failed to persist planning use-chat toggle: {err}");
            }
        }

        if use_chat {
            self.bottom_pane
                .flash_footer_notice("Planning model now follows Chat model".to_string());
        } else {
            self.bottom_pane.flash_footer_notice(format!(
                "Planning model set to {} ({} reasoning)",
                self.config.planning_model,
                Self::format_reasoning_effort(self.config.planning_model_reasoning_effort)
            ));
        }

        self.update_planning_settings_model_row();
        self.refresh_settings_overview_rows();

        if matches!(self.config.sandbox_policy, code_core::protocol::SandboxPolicy::ReadOnly) {
            self.apply_planning_session_model();
        }
        self.request_redraw();
    }

    pub(crate) fn apply_auto_drive_model_selection(
        &mut self,
        model: String,
        effort: ReasoningEffort,
    ) {
        let trimmed = model.trim();
        if trimmed.is_empty() {
            return;
        }

        self.config.auto_drive_use_chat_model = false;

        let clamped_effort = Self::clamp_reasoning_for_model(trimmed, effort);

        let mut updated = false;
        if !self.config.auto_drive.model.eq_ignore_ascii_case(trimmed) {
            self.config.auto_drive.model = trimmed.to_string();
            updated = true;
        }

        if self.config.auto_drive.model_reasoning_effort != clamped_effort {
            self.config.auto_drive.model_reasoning_effort = clamped_effort;
            updated = true;
        }

        if !updated {
            self.bottom_pane
                .flash_footer_notice("Auto Drive model unchanged.".to_string());
            return;
        }

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_auto_drive_settings(
                &home,
                &self.config.auto_drive,
                self.config.auto_drive_use_chat_model,
            ) {
                Ok(_) => format!(
                    "Auto Drive model set to {} ({} reasoning)",
                    self.config.auto_drive.model,
                    Self::format_reasoning_effort(self.config.auto_drive.model_reasoning_effort)
                ),
                Err(err) => {
                    tracing::warn!("Failed to persist Auto Drive model: {err}");
                    format!(
                        "Auto Drive model set for this session (failed to persist): {}",
                        self.config.auto_drive.model
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Code home to persist Auto Drive model");
            format!(
                "Auto Drive model set for this session: {}",
                self.config.auto_drive.model
            )
        };

        self.bottom_pane.flash_footer_notice(message);
        self.refresh_settings_overview_rows();
        self.update_auto_drive_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn handle_reasoning_command(&mut self, command_args: String) {
        // command_args contains only the arguments after the command (e.g., "high" not "/reasoning high")
        let trimmed = command_args.trim();

        if !trimmed.is_empty() {
            // User specified a level: e.g., "high"
            let new_effort = match trimmed.to_lowercase().as_str() {
                "minimal" | "min" => ReasoningEffort::Minimal,
                "low" => ReasoningEffort::Low,
                "medium" | "med" => ReasoningEffort::Medium,
                "xhigh" | "extra-high" | "extra_high" => ReasoningEffort::XHigh,
                "high" => ReasoningEffort::High,
                // Backwards compatibility: map legacy values to minimal.
                "none" | "off" => ReasoningEffort::Minimal,
                _ => {
                    // Invalid parameter, show error and return
                    let message = format!(
                        "Invalid reasoning level: '{}'. Use: minimal, low, medium, or high",
                        trimmed
                    );
                    self.history_push_plain_state(history_cell::new_error_event(message));
                    return;
                }
            };
            self.set_reasoning_effort(new_effort);
        } else {
            let presets = self.available_model_presets();
            if presets.is_empty() {
                let message =
                    "No model presets are available. Update your configuration to define models."
                        .to_string();
                self.history_push_plain_state(history_cell::new_error_event(message));
                return;
            }

        self.bottom_pane.show_model_selection(
            presets,
            self.config.model.clone(),
            self.config.model_reasoning_effort,
            false,
            ModelSelectionTarget::Session,
        );
            return;
        }
    }

    pub(crate) fn handle_verbosity_command(&mut self, command_args: String) {
        // Verbosity is not supported with ChatGPT auth
        if self.config.using_chatgpt_auth {
            let message =
                "Text verbosity is not available when using Sign in with ChatGPT".to_string();
            self.history_push_plain_state(history_cell::new_error_event(message));
            return;
        }

        // command_args contains only the arguments after the command (e.g., "high" not "/verbosity high")
        let trimmed = command_args.trim();

        if !trimmed.is_empty() {
            // User specified a level: e.g., "high"
            let new_verbosity = match trimmed.to_lowercase().as_str() {
                "low" => TextVerbosity::Low,
                "medium" | "med" => TextVerbosity::Medium,
                "high" => TextVerbosity::High,
                _ => {
                    // Invalid parameter, show error and return
                    let message = format!(
                        "Invalid verbosity level: '{}'. Use: low, medium, or high",
                        trimmed
                    );
                    self.history_push_plain_state(history_cell::new_error_event(message));
                    return;
                }
            };

            // Update the configuration
            self.config.model_text_verbosity = new_verbosity;

            // Display success message
            let message = format!("Text verbosity set to: {}", new_verbosity);
            self.push_background_tail(message);

            // Send the update to the backend
            let op = Op::ConfigureSession {
                provider: self.config.model_provider.clone(),
                model: self.config.model.clone(),
                model_explicit: self.config.model_explicit,
                model_reasoning_effort: self.config.model_reasoning_effort,
                preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
                model_reasoning_summary: self.config.model_reasoning_summary,
                model_text_verbosity: self.config.model_text_verbosity,
                user_instructions: self.config.user_instructions.clone(),
                base_instructions: self.config.base_instructions.clone(),
                approval_policy: self.config.approval_policy,
                sandbox_policy: self.config.sandbox_policy.clone(),
                disable_response_storage: self.config.disable_response_storage,
                notify: self.config.notify.clone(),
                cwd: self.config.cwd.clone(),
                resume_path: None,
                demo_developer_message: self.config.demo_developer_message.clone(),
            };
            let _ = self.code_op_tx.send(op);
        } else {
            // No parameter specified, show interactive UI
            self.bottom_pane
                .show_verbosity_selection(self.config.model_text_verbosity);
            return;
        }
    }

    pub(crate) fn prepare_agents(&mut self) {
        // Set the flag to show agents are ready to start
        self.agents_ready_to_start = true;
        self.agents_terminal.reset();
        if self.agents_terminal.active {
            // Reset scroll offset when a new batch starts to avoid stale positions
            self.layout.scroll_offset = 0;
        }

        // Initialize sparkline with some data so it shows immediately
        {
            let mut sparkline_data = self.sparkline_data.borrow_mut();
            if sparkline_data.is_empty() {
                // Add initial low activity data for preparing phase
                for _ in 0..10 {
                    sparkline_data.push((2, false));
                }
                tracing::info!(
                    "Initialized sparkline data with {} points for preparing phase",
                    sparkline_data.len()
                );
            }
        } // Drop the borrow here

        self.request_redraw();
    }

    /// Update sparkline data with randomized activity based on agent count
    fn update_sparkline_data(&self) {
        let now = std::time::Instant::now();

        // Update every 100ms for smooth animation
        if now
            .duration_since(*self.last_sparkline_update.borrow())
            .as_millis()
            < 100
        {
            return;
        }

        *self.last_sparkline_update.borrow_mut() = now;

        // Calculate base height based on number of agents and status
        let agent_count = self.active_agents.len();
        let is_planning = self.overall_task_status == "planning";
        let base_height = if agent_count == 0 && self.agents_ready_to_start {
            2 // Minimal activity when preparing
        } else if is_planning && agent_count > 0 {
            3 // Low activity during planning phase
        } else if agent_count == 1 {
            5 // Low activity for single agent
        } else if agent_count == 2 {
            10 // Medium activity for two agents
        } else if agent_count >= 3 {
            15 // High activity for multiple agents
        } else {
            0 // No activity when no agents
        };

        // Don't generate data if there's no activity
        if base_height == 0 {
            return;
        }

        // Generate random variation
        use std::collections::hash_map::DefaultHasher;
        use std::hash::Hash;
        use std::hash::Hasher;
        let mut hasher = DefaultHasher::new();
        now.elapsed().as_nanos().hash(&mut hasher);
        let random_seed = hasher.finish();

        // More variation during planning phase for visibility (+/- 50%)
        // Less variation during running for stability (+/- 30%)
        let variation_percent = if self.agents_ready_to_start && self.active_agents.is_empty() {
            50 // More variation during planning for visibility
        } else {
            30 // Standard variation during running
        };

        let variation_range = variation_percent * 2; // e.g., 100 for +/- 50%
        let variation = ((random_seed % variation_range) as i32 - variation_percent as i32)
            * base_height as i32
            / 100;
        let height = ((base_height as i32 + variation).max(1) as u64).min(20);

        // Check if any agents are completed
        let has_completed = self
            .active_agents
            .iter()
            .any(|a| matches!(a.status, AgentStatus::Completed));

        // Keep a rolling window of 60 data points (about 6 seconds at 100ms intervals)
        let mut sparkline_data = self.sparkline_data.borrow_mut();
        sparkline_data.push((height, has_completed));
        if sparkline_data.len() > 60 {
            sparkline_data.remove(0);
        }
    }

    pub(crate) fn set_reasoning_effort(&mut self, new_effort: ReasoningEffort) {
        let clamped_effort = Self::clamp_reasoning_for_model(&self.config.model, new_effort);

        if clamped_effort != new_effort {
            let requested = Self::format_reasoning_effort(new_effort);
            let applied = Self::format_reasoning_effort(clamped_effort);
            self.bottom_pane.flash_footer_notice(format!(
                "{} does not support {} reasoning; using {} instead.",
                self.config.model, requested, applied
            ));
        }

        // Update the config
        self.config.preferred_model_reasoning_effort = Some(new_effort);
        self.config.model_reasoning_effort = clamped_effort;

        // Send ConfigureSession op to update the backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_explicit: self.config.model_explicit,
            model_reasoning_effort: clamped_effort,
            preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
            demo_developer_message: self.config.demo_developer_message.clone(),
        };

        self.submit_op(op);

        // Add status message to history (replaceable system notice)
        let placement = self.ui_placement_for_now();
        let state = history_cell::new_reasoning_output(&self.config.model_reasoning_effort);
        let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:reasoning".to_string()),
            None,
            "system",
            Some(HistoryDomainRecord::Plain(state)),
        );
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn set_text_verbosity(&mut self, new_verbosity: TextVerbosity) {
        // Update the config
        self.config.model_text_verbosity = new_verbosity;

        // Send ConfigureSession op to update the backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_explicit: self.config.model_explicit,
            model_reasoning_effort: self.config.model_reasoning_effort,
            preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: new_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
            demo_developer_message: self.config.demo_developer_message.clone(),
        };

        self.submit_op(op);

        // Add status message to history
        let message = format!("Text verbosity set to: {}", new_verbosity);
        self.push_background_tail(message);
    }

    pub(crate) fn set_auto_upgrade_enabled(&mut self, enabled: bool) {
        if self.config.auto_upgrade_enabled == enabled {
            return;
        }
        self.config.auto_upgrade_enabled = enabled;

        let code_home = self.config.code_home.clone();
        let profile = self.config.active_profile.clone();
        tokio::spawn(async move {
            if let Err(err) = code_core::config_edit::persist_overrides(
                &code_home,
                profile.as_deref(),
                &[(&["auto_upgrade_enabled"], if enabled { "true" } else { "false" })],
            )
            .await
            {
                tracing::warn!("failed to persist auto-upgrade setting: {err}");
            }
        });

        let notice = if enabled {
            "Automatic upgrades enabled"
        } else {
            "Automatic upgrades disabled"
        };
        self.bottom_pane.flash_footer_notice(notice.to_string());

        let should_refresh_updates = matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::Updates)
        );

        if should_refresh_updates {
            if let Some(content) = self.build_updates_settings_content() {
                if let Some(overlay) = self.settings.overlay.as_mut() {
                    overlay.set_updates_content(content);
                }
            }
        }
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn set_auto_switch_accounts_on_rate_limit(&mut self, enabled: bool) {
        if self.config.auto_switch_accounts_on_rate_limit == enabled {
            return;
        }
        self.config.auto_switch_accounts_on_rate_limit = enabled;

        let code_home = self.config.code_home.clone();
        let profile = self.config.active_profile.clone();
        tokio::spawn(async move {
            if let Err(err) = code_core::config_edit::persist_overrides(
                &code_home,
                profile.as_deref(),
                &[(&["auto_switch_accounts_on_rate_limit"], if enabled { "true" } else { "false" })],
            )
            .await
            {
                tracing::warn!("failed to persist account auto-switch setting: {err}");
            }
        });

        let notice = if enabled {
            "Auto-switch accounts enabled"
        } else {
            "Auto-switch accounts disabled"
        };
        self.bottom_pane.flash_footer_notice(notice.to_string());

        let should_refresh_accounts = matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::Accounts)
        );
        if should_refresh_accounts {
            let content = self.build_accounts_settings_content();
            if let Some(overlay) = self.settings.overlay.as_mut() {
                overlay.set_accounts_content(content);
            }
        }

        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn set_api_key_fallback_on_all_accounts_limited(&mut self, enabled: bool) {
        if self.config.api_key_fallback_on_all_accounts_limited == enabled {
            return;
        }
        self.config.api_key_fallback_on_all_accounts_limited = enabled;

        let code_home = self.config.code_home.clone();
        let profile = self.config.active_profile.clone();
        tokio::spawn(async move {
            if let Err(err) = code_core::config_edit::persist_overrides(
                &code_home,
                profile.as_deref(),
                &[(&["api_key_fallback_on_all_accounts_limited"], if enabled { "true" } else { "false" })],
            )
            .await
            {
                tracing::warn!("failed to persist API key fallback setting: {err}");
            }
        });

        let notice = if enabled {
            "API key fallback enabled"
        } else {
            "API key fallback disabled"
        };
        self.bottom_pane.flash_footer_notice(notice.to_string());

        let should_refresh_accounts = matches!(
            self.settings
                .overlay
                .as_ref()
                .map(|overlay| overlay.active_section()),
            Some(SettingsSection::Accounts)
        );
        if should_refresh_accounts {
            let content = self.build_accounts_settings_content();
            if let Some(overlay) = self.settings.overlay.as_mut() {
                overlay.set_accounts_content(content);
            }
        }

        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    /// Forward file-search results to the bottom pane.
    pub(crate) fn apply_file_search_result(&mut self, query: String, matches: Vec<FileMatch>) {
        self.bottom_pane.on_file_search_result(query, matches);
    }

    #[allow(dead_code)]
    pub(crate) fn show_theme_selection(&mut self) {
        let tail_ticket = self.make_background_tail_ticket();
        let before_ticket = self.make_background_before_next_output_ticket();
        self.bottom_pane.show_theme_selection(
            crate::theme::current_theme_name(),
            tail_ticket,
            before_ticket,
        );
    }

    pub(crate) fn show_settings_overlay(&mut self, section: Option<SettingsSection>) {
        let initial_section = section
            .or_else(|| {
                self.settings
                    .overlay
                    .as_ref()
                    .map(|overlay| overlay.active_section())
            })
            .unwrap_or(SettingsSection::Model);

        let mut overlay = SettingsOverlayView::new(initial_section);
        overlay.set_model_content(self.build_model_settings_content());
        overlay.set_planning_content(self.build_planning_settings_content());
        overlay.set_theme_content(self.build_theme_settings_content());
        if let Some(update_content) = self.build_updates_settings_content() {
            overlay.set_updates_content(update_content);
        }
        overlay.set_accounts_content(self.build_accounts_settings_content());
        overlay.set_notifications_content(self.build_notifications_settings_content());
        overlay.set_prompts_content(self.build_prompts_settings_content());
        overlay.set_skills_content(self.build_skills_settings_content());
        if let Some(mcp_content) = self.build_mcp_settings_content() {
            overlay.set_mcp_content(mcp_content);
        }
        overlay.set_agents_content(self.build_agents_settings_content());
        overlay.set_auto_drive_content(self.build_auto_drive_settings_content());
        overlay.set_review_content(self.build_review_settings_content());
        overlay.set_validation_content(self.build_validation_settings_content());
        overlay.set_limits_content(self.build_limits_settings_content());
        overlay.set_chrome_content(self.build_chrome_settings_content(None));
        let overview_rows = self.build_settings_overview_rows();
        overlay.set_overview_rows(overview_rows);

        match section {
            Some(section) => overlay.set_mode_section(section),
            None => overlay.set_mode_menu(None),
        }

        self.settings.overlay = Some(overlay);
        self.request_redraw();
    }

    pub(crate) fn ensure_settings_overlay_section(&mut self, section: SettingsSection) {
        match self.settings.overlay.as_mut() {
            Some(overlay) => {
                let was_menu = overlay.is_menu_active();
                let changed_section = overlay.active_section() != section;
                overlay.set_mode_section(section);
                if was_menu || changed_section {
                    self.request_redraw();
                }
            }
            None => {
                self.show_settings_overlay(Some(section));
            }
        }
    }

    fn build_model_settings_content(&self) -> ModelSettingsContent {
        let presets = self.available_model_presets();
        let current_model = self.config.model.clone();
        let current_effort = self.config.model_reasoning_effort;
        let view = ModelSelectionView::new(
            presets,
            current_model,
            current_effort,
            false,
            ModelSelectionTarget::Session,
            self.app_event_tx.clone(),
        );
        ModelSettingsContent::new(view)
    }

    fn build_theme_settings_content(&mut self) -> ThemeSettingsContent {
        let tail_ticket = self.make_background_tail_ticket();
        let before_ticket = self.make_background_before_next_output_ticket();
        let view = ThemeSelectionView::new(
            crate::theme::current_theme_name(),
            self.app_event_tx.clone(),
            tail_ticket,
            before_ticket,
        );
        ThemeSettingsContent::new(view)
    }

    fn build_notifications_settings_view(&mut self) -> NotificationsSettingsView {
        let mode = match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => NotificationsMode::Toggle { enabled: *enabled },
            Notifications::Custom(entries) => NotificationsMode::Custom { entries: entries.clone() },
        };
        let ticket = self.make_background_tail_ticket();
        NotificationsSettingsView::new(mode, self.app_event_tx.clone(), ticket)
    }

    fn build_notifications_settings_content(&mut self) -> NotificationsSettingsContent {
        NotificationsSettingsContent::new(self.build_notifications_settings_view())
    }

    fn build_prompts_settings_content(&mut self) -> PromptsSettingsContent {
        let prompts = self.bottom_pane.custom_prompts().to_vec();
        let view = PromptsSettingsView::new(prompts, self.app_event_tx.clone());
        PromptsSettingsContent::new(view)
    }

    fn build_skills_settings_content(&mut self) -> SkillsSettingsContent {
        let skills = self.bottom_pane.skills().to_vec();
        let view = SkillsSettingsView::new(skills, self.app_event_tx.clone());
        SkillsSettingsContent::new(view)
    }

    fn build_chrome_settings_content(&self, port: Option<u16>) -> ChromeSettingsContent {
        ChromeSettingsContent::new(self.app_event_tx.clone(), port)
    }

    fn build_mcp_server_rows(&mut self) -> Option<McpServerRows> {
        let home = match code_core::config::find_code_home() {
            Ok(home) => home,
            Err(e) => {
                let msg = format!("Failed to locate CODE_HOME: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
                return None;
            }
        };

        let (enabled, disabled) = match code_core::config::list_mcp_servers(&home) {
            Ok(result) => result,
            Err(e) => {
                let msg = format!("Failed to read MCP config: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
                return None;
            }
        };

        let mut rows: McpServerRows = Vec::new();
        for (name, cfg) in enabled.into_iter() {
            rows.push(McpServerRow {
                name,
                enabled: true,
                summary: Self::format_mcp_summary(&cfg),
            });
        }
        for (name, cfg) in disabled.into_iter() {
            rows.push(McpServerRow {
                name,
                enabled: false,
                summary: Self::format_mcp_summary(&cfg),
            });
        }
        rows.sort_by(|a, b| a.name.cmp(&b.name));
        Some(rows)
    }

    fn build_mcp_settings_content(&mut self) -> Option<McpSettingsContent> {
        let rows = self.build_mcp_server_rows()?;
        let view = McpSettingsView::new(rows, self.app_event_tx.clone());
        Some(McpSettingsContent::new(view))
    }

    fn is_builtin_agent(name: &str, command: &str) -> bool {
        if let Some(spec) = agent_model_spec(name).or_else(|| agent_model_spec(command)) {
            return matches!(spec.family, "code" | "codex" | "cloud");
        }

        name.eq_ignore_ascii_case("code")
            || name.eq_ignore_ascii_case("codex")
            || name.eq_ignore_ascii_case("cloud")
            || name.eq_ignore_ascii_case("coder")
            || command.eq_ignore_ascii_case("code")
            || command.eq_ignore_ascii_case("codex")
            || command.eq_ignore_ascii_case("cloud")
            || command.eq_ignore_ascii_case("coder")
    }

    fn collect_agents_overview_rows(&self) -> (Vec<AgentOverviewRow>, Vec<String>) {
        fn command_exists(cmd: &str) -> bool {
            if cmd.contains(std::path::MAIN_SEPARATOR) || cmd.contains('/') || cmd.contains('\\') {
                return std::fs::metadata(cmd).map(|m| m.is_file()).unwrap_or(false);
            }
            #[cfg(target_os = "windows")]
            {
                which::which(cmd).map(|p| p.is_file()).unwrap_or(false)
            }
            #[cfg(not(target_os = "windows"))]
            {
                use std::os::unix::fs::PermissionsExt;
                let Some(path_os) = std::env::var_os("PATH") else {
                    return false;
                };
                for dir in std::env::split_paths(&path_os) {
                    if dir.as_os_str().is_empty() {
                        continue;
                    }
                    let candidate = dir.join(cmd);
                    if let Ok(meta) = std::fs::metadata(&candidate) {
                        if meta.is_file() && (meta.permissions().mode() & 0o111 != 0) {
                            return true;
                        }
                    }
                }
                false
            }
        }

        fn command_for_check(command: &str) -> String {
            let (base, _) = split_command_and_args(command);
            if base.trim().is_empty() {
                command.trim().to_string()
            } else {
                base
            }
        }

        let mut agent_rows: Vec<AgentOverviewRow> = Vec::new();
        let mut ordered: Vec<String> = enabled_agent_model_specs()
            .into_iter()
            .map(|spec| spec.slug.to_string())
            .collect();
        let mut extras: Vec<String> = Vec::new();
        for agent in &self.config.agents {
            if !ordered.iter().any(|name| agent.name.eq_ignore_ascii_case(name)) {
                extras.push(agent.name.to_ascii_lowercase());
            }
        }
        let mut pending_agents: HashMap<String, AgentConfig> = HashMap::new();
        for pending in self.pending_agent_updates.values() {
            let lower = pending.cfg.name.to_ascii_lowercase();
            pending_agents.insert(lower.clone(), pending.cfg.clone());
            if !ordered.iter().any(|name| name.eq_ignore_ascii_case(&lower)) {
                extras.push(lower);
            }
        }
        extras.sort();
        for extra in extras {
            if !ordered.iter().any(|name| name.eq_ignore_ascii_case(&extra)) {
                ordered.push(extra);
            }
        }

        for name in ordered.iter() {
            let name_lower = name.to_ascii_lowercase();
            if let Some(cfg) = self
                .config
                .agents
                .iter()
                .find(|a| a.name.eq_ignore_ascii_case(name))
            {
                let builtin = Self::is_builtin_agent(&cfg.name, &cfg.command);
                    let spec_cli = agent_model_spec(&cfg.name)
                        .or_else(|| agent_model_spec(&cfg.command))
                        .map(|spec| spec.cli);
                let command_to_check = command_for_check(&cfg.command);
                let installed = if builtin {
                    true
                } else if command_exists(&command_to_check) {
                    true
                } else if let Some(cli) = spec_cli {
                    command_exists(cli)
                } else {
                    false
                };
                agent_rows.push(AgentOverviewRow {
                    name: cfg.name.clone(),
                    enabled: cfg.enabled,
                    installed,
                    description: Self::agent_description_for(
                        &cfg.name,
                        Some(&cfg.command),
                        cfg.description.as_deref(),
                    ),
                });
            } else if let Some(cfg) = pending_agents.get(&name_lower) {
                let builtin = Self::is_builtin_agent(&cfg.name, &cfg.command);
                let spec_cli = agent_model_spec(&cfg.name)
                    .or_else(|| agent_model_spec(&cfg.command))
                    .map(|spec| spec.cli);
                let command_to_check = command_for_check(&cfg.command);
                let installed = if builtin {
                    true
                } else if command_exists(&command_to_check) {
                    true
                } else if let Some(cli) = spec_cli {
                    command_exists(cli)
                } else {
                    false
                };
                agent_rows.push(AgentOverviewRow {
                    name: cfg.name.clone(),
                    enabled: cfg.enabled,
                    installed,
                    description: Self::agent_description_for(
                        &cfg.name,
                        Some(&cfg.command),
                        cfg.description.as_deref(),
                    ),
                });
            } else {
                let cmd = name.clone();
                let builtin = Self::is_builtin_agent(name, &cmd);
                let spec_cli = agent_model_spec(name).map(|spec| spec.cli);
                let installed = if builtin {
                    true
                } else if let Some(cli) = spec_cli {
                    command_exists(cli)
                } else {
                    command_exists(&cmd)
                };
                agent_rows.push(AgentOverviewRow {
                    name: name.clone(),
                    enabled: true,
                    installed,
                    description: Self::agent_description_for(name, Some(&cmd), None),
                });
            }
        }

        let mut commands: Vec<String> = vec!["plan".into(), "solve".into(), "code".into()];
        let custom: Vec<String> = self
            .config
            .subagent_commands
            .iter()
            .map(|c| c.name.clone())
            .filter(|name| !commands.iter().any(|builtin| builtin.eq_ignore_ascii_case(name)))
            .collect();
        commands.extend(custom);

        (agent_rows, commands)
    }

    fn agent_description_for(
        name: &str,
        command: Option<&str>,
        config_description: Option<&str>,
    ) -> Option<String> {
        if let Some(desc) = config_description {
            let trimmed = desc.trim();
            if !trimmed.is_empty() {
                return Some(trimmed.to_string());
            }
        }
        agent_model_spec(name)
            .or_else(|| command.and_then(|cmd| agent_model_spec(cmd)))
            .map(|spec| spec.description.trim().to_string())
            .filter(|desc| !desc.is_empty())
    }

    fn build_agents_settings_content(&mut self) -> AgentsSettingsContent {
        let (rows, commands) = self.collect_agents_overview_rows();
        let total = rows
            .len()
            .saturating_add(commands.len())
            .saturating_add(AGENTS_OVERVIEW_STATIC_ROWS);
        let selected = if total == 0 {
            0
        } else {
            self.agents_overview_selected_index.min(total.saturating_sub(1))
        };
        self.agents_overview_selected_index = selected;
        AgentsSettingsContent::new_overview(rows, commands, selected, self.app_event_tx.clone())
    }

    fn build_limits_settings_content(&mut self) -> LimitsSettingsContent {
        let snapshot = self.rate_limit_snapshot.clone();
        let needs_refresh = self.should_refresh_limits();

        let content = if self.rate_limit_fetch_inflight || needs_refresh {
            LimitsOverlayContent::Loading
        } else {
            let reset_info = self.rate_limit_reset_info();
            let tabs = self.build_limits_tabs(snapshot.clone(), reset_info);
            if tabs.is_empty() {
                LimitsOverlayContent::Placeholder
            } else {
                LimitsOverlayContent::Tabs(tabs)
            }
        };

        if needs_refresh {
            self.request_latest_rate_limits(snapshot.is_none());
        }

        LimitsSettingsContent::new(content)
    }

    fn build_settings_overview_rows(&mut self) -> Vec<SettingsOverviewRow> {
        SettingsSection::ALL
            .iter()
            .copied()
            .map(|section| {
                let summary = match section {
                    SettingsSection::Model => self.settings_summary_model(),
                    SettingsSection::Theme => self.settings_summary_theme(),
                    SettingsSection::Planning => self.settings_summary_planning(),
                    SettingsSection::Updates => self.settings_summary_updates(),
                    SettingsSection::Accounts => self.settings_summary_accounts(),
                    SettingsSection::Agents => self.settings_summary_agents(),
                    SettingsSection::Prompts => self.settings_summary_prompts(),
                    SettingsSection::Skills => self.settings_summary_skills(),
                    SettingsSection::AutoDrive => self.settings_summary_auto_drive(),
                    SettingsSection::Review => self.settings_summary_review(),
                    SettingsSection::Validation => self.settings_summary_validation(),
                    SettingsSection::Chrome => self.settings_summary_chrome(),
                    SettingsSection::Mcp => self.settings_summary_mcp(),
                    SettingsSection::Notifications => self.settings_summary_notifications(),
                    SettingsSection::Limits => self.settings_summary_limits(),
                };
                SettingsOverviewRow::new(section, summary)
            })
            .collect()
    }

    fn settings_summary_model(&self) -> Option<String> {
        let model = self.config.model.trim();
        let model_display_storage;
        let model_display = if model.is_empty() {
            "—"
        } else {
            model_display_storage = Self::format_model_label(model);
            &model_display_storage
        };
        let effort = Self::format_reasoning_effort(self.config.model_reasoning_effort);
        let mut parts: Vec<String> = vec![format!("Model: {} ({})", model_display, effort)];
        if let Some(profile) = self
            .config
            .active_profile
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            parts.push(format!("Profile: {}", profile));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_planning(&self) -> Option<String> {
        if self.config.planning_use_chat_model {
            return Some("Model: Follow Chat Mode".to_string());
        }
        let model = self.config.planning_model.trim();
        let model_display_storage;
        let model_display = if model.is_empty() {
            "(default)"
        } else {
            model_display_storage = Self::format_model_label(model);
            &model_display_storage
        };
        let effort = Self::format_reasoning_effort(self.config.planning_model_reasoning_effort);
        Some(format!("Model: {} ({})", model_display, effort))
    }

    fn settings_summary_theme(&self) -> Option<String> {
        let theme_label = Self::theme_display_name(self.config.tui.theme.name);
        let spinner_name = &self.config.tui.spinner.name;
        let spinner_label = spinner::spinner_label_for(spinner_name);
        Some(format!("Theme: {} · Spinner: {}", theme_label, spinner_label))
    }

    fn settings_summary_updates(&self) -> Option<String> {
        if !crate::updates::upgrade_ui_enabled() {
            return Some("Auto update: Disabled".to_string());
        }
        let status = if self.config.auto_upgrade_enabled {
            "Enabled"
        } else {
            "Disabled"
        };
        let mut parts = vec![format!("Auto update: {}", status)];
        if let Some(latest) = self
            .latest_upgrade_version
            .as_deref()
            .map(str::trim)
            .filter(|value| !value.is_empty())
        {
            parts.push(format!("Latest available: {}", latest));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_accounts(&self) -> Option<String> {
        let auto_switch = if self.config.auto_switch_accounts_on_rate_limit {
            "Auto-switch: On"
        } else {
            "Auto-switch: Off"
        };

        let api_key_fallback = if self.config.api_key_fallback_on_all_accounts_limited {
            "API key fallback: On"
        } else {
            "API key fallback: Off"
        };

        Some(format!("{auto_switch} · {api_key_fallback}"))
    }

    fn settings_summary_agents(&self) -> Option<String> {
        let (enabled, total) = agent_summary_counts(&self.config.agents);
        let commands = self.config.subagent_commands.len();
        let mut parts = vec![format!("Enabled: {}/{}", enabled, total)];
        if commands > 0 {
            parts.push(format!("Custom commands: {}", commands));
        }
        Some(parts.join(" · "))
    }

    fn settings_summary_auto_drive(&self) -> Option<String> {
        let diagnostics_enabled = self.auto_state.qa_automation_enabled
            && (self.auto_state.review_enabled || self.auto_state.cross_check_enabled);
        let (model_text, effort_text) = if self.config.auto_drive_use_chat_model {
            ("Follow Chat Mode".to_string(), None)
        } else {
            let model_label = if self.config.auto_drive.model.trim().is_empty() {
                "(default)".to_string()
            } else {
                Self::format_model_label(&self.config.auto_drive.model)
            };
            let effort = Self::format_reasoning_effort(self.config.auto_drive.model_reasoning_effort);
            (model_label, Some(effort))
        };
        let model_segment = if let Some(effort) = effort_text {
            format!("Model: {} ({})", model_text, effort)
        } else {
            format!("Model: {}", model_text)
        };
        Some(format!(
            "{} · Agents: {} · Diagnostics: {} · Continue: {}",
            model_segment,
            Self::on_off_label(self.auto_state.subagents_enabled),
            Self::on_off_label(diagnostics_enabled),
            self.auto_state.continue_mode.label()
        ))
    }

    fn settings_summary_validation(&self) -> Option<String> {
        let groups = &self.config.validation.groups;
        Some(format!(
            "Functional: {} · Stylistic: {}",
            Self::on_off_label(groups.functional),
            Self::on_off_label(groups.stylistic)
        ))
    }

    fn settings_summary_review(&self) -> Option<String> {
        let attempts = self.configured_auto_resolve_re_reviews();
        let auto_followups = self.config.auto_drive.auto_review_followup_attempts.get();

        let review_model_label = if self.config.review_use_chat_model {
            "Chat".to_string()
        } else {
            format!(
                "{} ({})",
                Self::format_model_label(&self.config.review_model),
                Self::format_reasoning_effort(self.config.review_model_reasoning_effort)
            )
        };

        let review_resolve_label = if self.config.review_resolve_use_chat_model {
            "Chat".to_string()
        } else {
            format!(
                "{} ({})",
                Self::format_model_label(&self.config.review_resolve_model),
                Self::format_reasoning_effort(self.config.review_resolve_model_reasoning_effort)
            )
        };

        let auto_review_model_label = if self.config.auto_review_use_chat_model {
            "Chat".to_string()
        } else {
            format!(
                "{} ({})",
                Self::format_model_label(&self.config.auto_review_model),
                Self::format_reasoning_effort(self.config.auto_review_model_reasoning_effort)
            )
        };

        let auto_review_resolve_label = if self.config.auto_review_resolve_use_chat_model {
            "Chat".to_string()
        } else {
            format!(
                "{} ({})",
                Self::format_model_label(&self.config.auto_review_resolve_model),
                Self::format_reasoning_effort(self.config.auto_review_resolve_model_reasoning_effort)
            )
        };

        Some(format!(
            "/review: {} · Resolve: {} · Follow-ups: {} · Auto Review: {} ({} · resolve {} · follow-ups {})",
            review_model_label,
            review_resolve_label,
            attempts,
            Self::on_off_label(self.config.tui.auto_review_enabled),
            auto_review_model_label,
            auto_review_resolve_label,
            auto_followups
        ))
    }

    fn settings_summary_limits(&self) -> Option<String> {
        if let Some(snapshot) = &self.rate_limit_snapshot {
            let primary = snapshot.primary_used_percent.clamp(0.0, 100.0).round() as i64;
            let secondary = snapshot.secondary_used_percent.clamp(0.0, 100.0).round() as i64;
            Some(format!("Primary: {}% · Secondary: {}%", primary, secondary))
        } else if self.rate_limit_fetch_inflight {
            Some("Refreshing usage...".to_string())
        } else {
            Some("Usage data not loaded".to_string())
        }
    }

    fn settings_summary_chrome(&self) -> Option<String> {
        if self.browser_is_external {
            Some("Browser: external".to_string())
        } else {
            Some("Browser: available".to_string())
        }
    }

    fn settings_summary_mcp(&self) -> Option<String> {
        Some(format!(
            "Servers configured: {}",
            self.config.mcp_servers.len()
        ))
    }

    fn settings_summary_notifications(&self) -> Option<String> {
        match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => {
                Some(format!("Desktop alerts: {}", Self::on_off_label(*enabled)))
            }
            Notifications::Custom(entries) => Some(format!("Custom rules: {}", entries.len())),
        }
    }

    fn settings_summary_prompts(&self) -> Option<String> {
        let count = self.bottom_pane.custom_prompts().len();
        Some(format!("Prompts enabled: {}", count))
    }

    fn settings_summary_skills(&self) -> Option<String> {
        let count = self.bottom_pane.skills().len();
        Some(format!("Skills loaded: {count}"))
    }

    fn refresh_settings_overview_rows(&mut self) {
        if self.settings.overlay.is_none() {
            return;
        }
        let rows = self.build_settings_overview_rows();
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_overview_rows(rows);
        }
        self.request_redraw();
    }

    fn format_reasoning_effort(effort: ReasoningEffort) -> &'static str {
        match effort {
            ReasoningEffort::Minimal | ReasoningEffort::None => "Minimal",
            ReasoningEffort::Low => "Low",
            ReasoningEffort::Medium => "Medium",
            ReasoningEffort::High => "High",
            ReasoningEffort::XHigh => "XHigh",
        }
    }

    fn format_model_label(model: &str) -> String {
        // Strip the internal "code-" prefix from agent models so user-facing labels
        // display the canonical model name (e.g., code-gpt-5.1-codex-mini -> GPT-5.1-Codex-Mini).
        let model = if model.to_ascii_lowercase().starts_with("code-") {
            &model[5..]
        } else {
            model
        };

        let mut parts = Vec::new();
        for (idx, part) in model.split('-').enumerate() {
            if idx == 0 {
                parts.push(part.to_ascii_uppercase());
                continue;
            }
            let mut chars = part.chars();
            let formatted = match chars.next() {
                Some(first) if first.is_ascii_alphabetic() => {
                    let mut s = String::new();
                    s.push(first.to_ascii_uppercase());
                    s.push_str(chars.as_str());
                    s
                }
                Some(first) => {
                    let mut s = String::new();
                    s.push(first);
                    s.push_str(chars.as_str());
                    s
                }
                None => String::new(),
            };
            parts.push(formatted);
        }
        parts.join("-")
    }

    fn on_off_label(value: bool) -> &'static str {
        if value { "On" } else { "Off" }
    }

    fn theme_display_name(theme: code_core::config_types::ThemeName) -> String {
        match theme {
            code_core::config_types::ThemeName::LightPhoton => "Light - Photon".to_string(),
            code_core::config_types::ThemeName::LightPhotonAnsi16 => {
                "Light - Photon (16-color)".to_string()
            }
            code_core::config_types::ThemeName::LightPrismRainbow => {
                "Light - Prism Rainbow".to_string()
            }
            code_core::config_types::ThemeName::LightVividTriad => {
                "Light - Vivid Triad".to_string()
            }
            code_core::config_types::ThemeName::LightPorcelain => "Light - Porcelain".to_string(),
            code_core::config_types::ThemeName::LightSandbar => "Light - Sandbar".to_string(),
            code_core::config_types::ThemeName::LightGlacier => "Light - Glacier".to_string(),
            code_core::config_types::ThemeName::DarkCarbonNight => {
                "Dark - Carbon Night".to_string()
            }
            code_core::config_types::ThemeName::DarkCarbonAnsi16 => {
                "Dark - Carbon (16-color)".to_string()
            }
            code_core::config_types::ThemeName::DarkShinobiDusk => {
                "Dark - Shinobi Dusk".to_string()
            }
            code_core::config_types::ThemeName::DarkOledBlackPro => {
                "Dark - OLED Black Pro".to_string()
            }
            code_core::config_types::ThemeName::DarkAmberTerminal => {
                "Dark - Amber Terminal".to_string()
            }
            code_core::config_types::ThemeName::DarkAuroraFlux => "Dark - Aurora Flux".to_string(),
            code_core::config_types::ThemeName::DarkCharcoalRainbow => {
                "Dark - Charcoal Rainbow".to_string()
            }
            code_core::config_types::ThemeName::DarkZenGarden => "Dark - Zen Garden".to_string(),
            code_core::config_types::ThemeName::DarkPaperLightPro => {
                "Dark - Paper Light Pro".to_string()
            }
            code_core::config_types::ThemeName::Custom => {
                let mut label =
                    crate::theme::custom_theme_label().unwrap_or_else(|| "Custom".to_string());
                for pref in ["Light - ", "Dark - ", "Light ", "Dark "] {
                    if label.starts_with(pref) {
                        label = label[pref.len()..].trim().to_string();
                        break;
                    }
                }
                if crate::theme::custom_theme_is_dark().unwrap_or(false) {
                    format!("Dark - {}", label)
                } else {
                    format!("Light - {}", label)
                }
            }
        }
    }

    pub(crate) fn close_settings_overlay(&mut self) {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.notify_close();
        }
        self.settings.overlay = None;
        self.request_redraw();
    }

    pub(crate) fn activate_current_settings_section(&mut self) -> bool {
        let section = match self
            .settings
            .overlay
            .as_ref()
            .map(|overlay| overlay.active_section())
        {
            Some(section) => section,
            None => return false,
        };

        let handled = match section {
            SettingsSection::Model
            | SettingsSection::Theme
            | SettingsSection::Planning
            | SettingsSection::Updates
            | SettingsSection::Review
            | SettingsSection::Validation
            | SettingsSection::AutoDrive
            | SettingsSection::Mcp
            | SettingsSection::Notifications
            | SettingsSection::Prompts
            | SettingsSection::Accounts
            | SettingsSection::Skills => false,
            SettingsSection::Agents => {
                self.show_agents_overview_ui();
                false
            }
            SettingsSection::Limits => {
                self.show_limits_settings_ui();
                false
            }
            SettingsSection::Chrome => {
                self.show_chrome_options(None);
                true
            }
        };

        if handled {
            self.close_settings_overlay();
        }

        handled
    }

    pub(crate) fn settings_section_from_hint(section: &str) -> Option<SettingsSection> {
        SettingsSection::from_hint(section)
    }

    // Ctrl+Y syntax cycling disabled intentionally.

    /// Show a brief debug notice in the footer.
    #[allow(dead_code)]
    pub(crate) fn debug_notice(&mut self, text: String) {
        self.bottom_pane.flash_footer_notice(text);
        self.request_redraw();
    }

    fn maybe_start_auto_upgrade_task(&mut self) {
        if !crate::updates::auto_upgrade_runtime_enabled() {
            return;
        }
        if !self.config.auto_upgrade_enabled {
            return;
        }

        let cfg = self.config.clone();
        let tx = self.app_event_tx.clone();
        let upgrade_ticket = self.make_background_tail_ticket();
        tokio::spawn(async move {
            match crate::updates::auto_upgrade_if_enabled(&cfg).await {
                Ok(outcome) => {
                    if let Some(version) = outcome.installed_version {
                        tx.send(AppEvent::AutoUpgradeCompleted { version });
                    }
                    if let Some(message) = outcome.user_notice {
                        tx.send_background_event_with_ticket(&upgrade_ticket, message);
                    }
                }
                Err(err) => {
                    tracing::warn!("auto-upgrade: background task failed: {err:?}");
                }
            }
        });
    }

    pub(crate) fn set_theme(&mut self, new_theme: code_core::config_types::ThemeName) {
        let custom_hint = if matches!(new_theme, code_core::config_types::ThemeName::Custom) {
            self.config
                .tui
                .theme
                .is_dark
                .or_else(|| crate::theme::custom_theme_is_dark())
        } else {
            None
        };
        let mapped_theme = crate::theme::map_theme_for_palette(new_theme, custom_hint);

        // Update the config
        self.config.tui.theme.name = mapped_theme;
        if matches!(new_theme, code_core::config_types::ThemeName::Custom) {
            self.config.tui.theme.is_dark = custom_hint;
        } else {
            self.config.tui.theme.is_dark = None;
        }

        // Save the theme to config file
        self.save_theme_to_config(mapped_theme);

        // Retint pre-rendered history cell lines to the new palette
        self.restyle_history_after_theme_change();

        // Add confirmation message to history (replaceable system notice)
        let theme_name = Self::theme_display_name(mapped_theme);
        let message = format!("Theme changed to {}", theme_name);
        let placement = self.ui_placement_for_now();
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:theme".to_string()),
            None,
            "background",
            Some(record),
        );
        self.refresh_settings_overview_rows();
    }

    pub(crate) fn set_spinner(&mut self, spinner_name: String) {
        // Update the config
        self.config.tui.spinner.name = spinner_name.clone();
        // Persist selection to config file
        if let Ok(home) = code_core::config::find_code_home() {
            if let Err(e) = code_core::config::set_tui_spinner_name(&home, &spinner_name) {
                tracing::warn!("Failed to persist spinner to config.toml: {}", e);
            } else {
                tracing::info!("Persisted TUI spinner selection to config.toml");
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist spinner selection");
        }

        // Confirmation message (replaceable system notice)
        let message = format!("Spinner changed to {}", spinner_name);
        let placement = self.ui_placement_for_now();
        let cell = history_cell::new_background_event(message);
        let record = HistoryDomainRecord::BackgroundEvent(cell.state().clone());
        self.push_system_cell(
            Box::new(cell),
            placement,
            Some("ui:spinner".to_string()),
            None,
            "background",
            Some(record),
        );

        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    fn apply_access_mode_indicator_from_config(&mut self) {
        use code_core::protocol::AskForApproval;
        use code_core::protocol::SandboxPolicy;
        let label = match (&self.config.sandbox_policy, self.config.approval_policy) {
            (SandboxPolicy::ReadOnly, _) => Some("Read Only".to_string()),
            (
                SandboxPolicy::WorkspaceWrite {
                    network_access: false,
                    ..
                },
                AskForApproval::UnlessTrusted,
            ) => Some("Write with Approval".to_string()),
            _ => None,
        };
        self.bottom_pane.set_access_mode_label(label);
    }

    /// Rotate the access preset: Read Only (Plan Mode) → Write with Approval → Full Access
    pub(crate) fn cycle_access_mode(&mut self) {
        use code_core::config::set_project_access_mode;
        use code_core::protocol::AskForApproval;
        use code_core::protocol::SandboxPolicy;

        // Determine current index
        let idx = match (&self.config.sandbox_policy, self.config.approval_policy) {
            (SandboxPolicy::ReadOnly, _) => 0,
            (
                SandboxPolicy::WorkspaceWrite {
                    network_access: false,
                    ..
                },
                AskForApproval::UnlessTrusted,
            ) => 1,
            (SandboxPolicy::DangerFullAccess, AskForApproval::Never) => 2,
            _ => 0,
        };
        let next = (idx + 1) % 3;

        // Apply mapping
        let (label, approval, sandbox) = match next {
            0 => (
                "Read Only (Plan Mode)",
                AskForApproval::OnRequest,
                SandboxPolicy::ReadOnly,
            ),
            1 => (
                "Write with Approval",
                AskForApproval::UnlessTrusted,
                SandboxPolicy::new_workspace_write_policy(),
            ),
            _ => (
                "Full Access",
                AskForApproval::Never,
                SandboxPolicy::DangerFullAccess,
            ),
        };

        // Apply planning model when entering plan mode; restore when leaving it.
        if next == 0 {
            self.apply_planning_session_model();
        } else if idx == 0 {
            self.restore_planning_session_model();
        }

        // Update local config
        self.config.approval_policy = approval;
        self.config.sandbox_policy = sandbox;

        // Send ConfigureSession op to backend
        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_explicit: self.config.model_explicit,
            model_reasoning_effort: self.config.model_reasoning_effort,
            preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
            demo_developer_message: self.config.demo_developer_message.clone(),
        };
        self.submit_op(op);

        // Persist selection into CODEX_HOME/config.toml for this project directory so it sticks.
        let _ = set_project_access_mode(
            &self.config.code_home,
            &self.config.cwd,
            self.config.approval_policy,
            match &self.config.sandbox_policy {
                SandboxPolicy::ReadOnly => code_protocol::config_types::SandboxMode::ReadOnly,
                SandboxPolicy::WorkspaceWrite { .. } => {
                    code_protocol::config_types::SandboxMode::WorkspaceWrite
                }
                SandboxPolicy::DangerFullAccess => {
                    code_protocol::config_types::SandboxMode::DangerFullAccess
                }
            },
        );

        // Footer indicator: persistent for RO/Approval; ephemeral for Full Access
        if next == 2 {
            self.bottom_pane.set_access_mode_label_ephemeral(
                "Full Access".to_string(),
                std::time::Duration::from_secs(4),
            );
        } else {
            let persistent = if next == 0 {
                "Read Only"
            } else {
                "Write with Approval"
            };
            self.bottom_pane
                .set_access_mode_label(Some(persistent.to_string()));
        }

        // Announce in history: replace the last access-mode status, inserting early
        // in the current request so it appears above upcoming commands.
        let msg = format!("Mode changed: {}", label);
        self.set_access_status_message(msg);
        // No footer notice: the indicator covers this; avoid duplicate texts.

        // Prepare a single consolidated note for the agent to see before the
        // next turn begins. Subsequent cycles will overwrite this note.
        let agent_note = match next {
            0 => {
                "System: access mode changed to Read Only. Do not attempt write operations or apply_patch."
            }
            1 => {
                "System: access mode changed to Write with Approval. Request approval before writes."
            }
            _ => "System: access mode changed to Full Access. Writes and network are allowed.",
        };
        self.queue_agent_note(agent_note);
    }

    pub(crate) fn cycle_auto_drive_variant(&mut self) {
        self.auto_drive_variant = self.auto_drive_variant.next();
        self
            .bottom_pane
            .set_auto_drive_variant(self.auto_drive_variant);
        let notice = format!(
            "Auto Drive style: {}",
            self.auto_drive_variant.name()
        );
        self.bottom_pane.flash_footer_notice(notice);
    }

    /// Insert or replace the access-mode status background event. Uses a near-time
    /// key so it appears above any imminent Exec/Tool cells in this request.
    fn set_access_status_message(&mut self, message: String) {
        let cell = crate::history_cell::new_background_event(message);
        if let Some(idx) = self.access_status_idx {
            if idx < self.history_cells.len()
                && matches!(
                    self.history_cells[idx].kind(),
                    crate::history_cell::HistoryCellType::BackgroundEvent
                )
            {
                self.history_replace_at(idx, Box::new(cell));
                self.request_redraw();
                return;
            }
        }
        // Insert new status near the top of this request window
        let key = self.near_time_key(None);
        let pos = self.history_insert_with_key_global_tagged(Box::new(cell), key, "background", None);
        self.access_status_idx = Some(pos);
    }

    fn restyle_history_after_theme_change(&mut self) {
        let old = self.last_theme.clone();
        let new = crate::theme::current_theme();
        if old == new {
            return;
        }

        for cell in &mut self.history_cells {
            if let Some(plain) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::PlainHistoryCell>()
            {
                plain.invalidate_layout_cache();
            } else if let Some(tool) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::ToolCallCell>()
            {
                tool.retint(&old, &new);
            } else if let Some(reason) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::CollapsibleReasoningCell>()
            {
                reason.retint(&old, &new);
            } else if let Some(stream) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::StreamingContentCell>()
            {
                stream.update_context(self.config.file_opener, &self.config.cwd);
            } else if let Some(wait) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::WaitStatusCell>()
            {
                wait.retint(&old, &new);
            } else if let Some(assist) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::AssistantMarkdownCell>()
            {
                // Fully rebuild from raw to apply new theme + syntax highlight
                let current = assist.state().clone();
                assist.update_state(current, &self.config);
            } else if let Some(merged) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::MergedExecCell>()
            {
                merged.rebuild_with_theme();
            } else if let Some(diff) = cell
                .as_any_mut()
                .downcast_mut::<history_cell::DiffCell>()
            {
                diff.rebuild_with_theme();
            }
        }

        // Update snapshot and redraw; height caching can remain (colors don't affect wrap)
        self.last_theme = new;
        self.render_theme_epoch = self.render_theme_epoch.saturating_add(1);
        self.history_render.invalidate_all();
        self.mark_render_requests_dirty();
        self.history_prefix_append_only.set(false);
        self.app_event_tx.send(AppEvent::RequestRedraw);
    }

    /// Public-facing hook for preview mode to retint existing history lines
    /// without persisting the theme or adding history events.
    pub(crate) fn retint_history_for_preview(&mut self) {
        self.restyle_history_after_theme_change();
    }

    fn save_theme_to_config(&self, new_theme: code_core::config_types::ThemeName) {
        // Persist the theme selection to CODE_HOME/CODEX_HOME config.toml
        match code_core::config::find_code_home() {
            Ok(home) => {
                if let Err(e) = code_core::config::set_tui_theme_name(&home, new_theme) {
                    tracing::warn!("Failed to persist theme to config.toml: {}", e);
                } else {
                    tracing::info!("Persisted TUI theme selection to config.toml");
                }
            }
            Err(e) => {
                tracing::warn!("Could not locate Codex home to persist theme: {}", e);
            }
        }
    }

    #[allow(dead_code)]
    pub(crate) fn on_esc(&mut self) -> bool {
        if self.bottom_pane.is_task_running() {
            self.interrupt_running_task();
            return true;
        }
        false
    }

    /// Handle Ctrl-C key press.
    /// Returns CancellationEvent::Handled if the event was consumed by the UI, or
    /// CancellationEvent::Ignored if the caller should handle it (e.g. exit).
    pub(crate) fn on_ctrl_c(&mut self) -> CancellationEvent {
        if let Some(id) = self.terminal_overlay_id() {
            if self.terminal_is_running() {
                self.request_terminal_cancel(id);
            } else {
                self.close_terminal_overlay();
            }
            return CancellationEvent::Handled;
        }
        match self.bottom_pane.on_ctrl_c() {
            CancellationEvent::Handled => return CancellationEvent::Handled,
            CancellationEvent::Ignored => {}
        }
        let exec_related_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty();
        if self.bottom_pane.is_task_running() || exec_related_running {
            self.interrupt_running_task();
            CancellationEvent::Ignored
        } else if self.bottom_pane.ctrl_c_quit_hint_visible() {
            self.submit_op(Op::Shutdown);
            CancellationEvent::Handled
        } else {
            self.bottom_pane.show_ctrl_c_quit_hint();
            CancellationEvent::Ignored
        }
    }

    #[allow(dead_code)]
    pub(crate) fn composer_is_empty(&self) -> bool {
        self.bottom_pane.composer_is_empty()
    }

    // --- Double‑Escape helpers ---
    fn schedule_auto_drive_card_celebration(
        &self,
        delay: Duration,
        message: Option<String>,
    ) {
        let event = AppEvent::StartAutoDriveCelebration { message };
        self.spawn_app_event_after(delay, event);
    }

    pub(crate) fn start_auto_drive_card_celebration(&mut self, message: Option<String>) {
        let mut started = auto_drive_cards::start_celebration(self, message.clone());
        if !started {
            if let Some(card) = self.latest_auto_drive_card_mut() {
                card.start_celebration(message.clone());
                started = true;
            }
        }
        if !started {
            return;
        }

        self.spawn_app_event_after(
            AUTO_COMPLETION_CELEBRATION_DURATION,
            AppEvent::StopAutoDriveCelebration,
        );

        if let Some(msg) = message.clone() {
            if !auto_drive_cards::update_completion_message(self, Some(msg.clone())) {
                if let Some(card) = self.latest_auto_drive_card_mut() {
                    card.set_completion_message(Some(msg));
                }
            }
        }

        self.mark_history_dirty();
        self.request_redraw();
    }

    pub(crate) fn stop_auto_drive_card_celebration(&mut self) {
        let mut stopped = auto_drive_cards::stop_celebration(self);
        if !stopped {
            if let Some(card) = self.latest_auto_drive_card_mut() {
                card.stop_celebration();
                stopped = true;
            }
        }
        if stopped {
            self.mark_history_dirty();
            self.request_redraw();
        }
    }

    fn spawn_app_event_after(&self, delay: Duration, event: AppEvent) {
        if delay.is_zero() {
            self.app_event_tx.send(event);
            return;
        }

        if let Ok(handle) = tokio::runtime::Handle::try_current() {
            let tx = self.app_event_tx.clone();
            handle.spawn(async move {
                tokio::time::sleep(delay).await;
                tx.send(event);
            });
        } else {
            #[cfg(test)]
            {
                let tx = self.app_event_tx.clone();
                if let Err(err) = std::thread::Builder::new()
                    .name("delayed-app-event".to_string())
                    .spawn(move || {
                        tx.send(event);
                    })
                {
                    tracing::warn!("failed to spawn delayed app event: {err}");
                }
            }
            #[cfg(not(test))]
            {
                let _ = event;
            }
        }
    }

    fn latest_auto_drive_card_mut(
        &mut self,
    ) -> Option<&mut history_cell::AutoDriveCardCell> {
        self.history_cells
            .iter_mut()
            .rev()
            .find_map(|cell| cell.as_any_mut().downcast_mut::<history_cell::AutoDriveCardCell>())
    }

    pub(crate) fn auto_manual_entry_active(&self) -> bool {
        self.auto_state.should_show_goal_entry()
            || (self.auto_state.is_active() && self.auto_state.awaiting_coordinator_submit())
    }

    fn has_running_commands_or_tools(&self) -> bool {
        let wait_running = self.wait_running();
        let wait_blocks = self.wait_blocking_enabled();

        self.terminal_is_running()
            || !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || (wait_running && wait_blocks)
    }

    pub(crate) fn is_task_running(&self) -> bool {
        let wait_running = self.wait_running();
        let wait_blocks = self.wait_blocking_enabled();

        self.bottom_pane.is_task_running()
            || self.terminal_is_running()
            || !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty()
            || !self.active_task_ids.is_empty()
            || self.stream.is_write_cycle_active()
            || (wait_running && wait_blocks)
    }

    #[inline]
    fn wait_running(&self) -> bool {
        !self.tools_state.running_wait_tools.is_empty()
            || !self.tools_state.running_kill_tools.is_empty()
    }

    #[inline]
    fn wait_blocking_enabled(&self) -> bool {
        self.queued_user_messages.is_empty()
    }

    /// True when the only ongoing activity is a wait/kill tool (no exec/stream/agents/tasks),
    /// meaning we can safely unlock the composer without cancelling the work.
    ///
    /// Historically this returned false whenever any exec was running, which caused user input
    /// submitted during a `wait` tool to be queued instead of interrupting the wait. That meant
    /// the core never received `Op::UserInput`, so waits could not be cancelled mid-flight.
    /// We treat execs that are only being observed by a wait tool as "wait-only" so input can
    /// flow through immediately and interrupt the wait.
    fn wait_only_activity(&self) -> bool {
        if !self.wait_running() {
            return false;
        }

        // Consider execs "wait-only" when every running command is being waited on and marked
        // as such. Any other exec activity keeps the composer blocked.
        let execs_wait_only = self.exec.running_commands.is_empty()
            || self
                .exec
                .running_commands
                .iter()
                .all(|(id, cmd)| {
                    cmd.wait_active
                        && self
                            .tools_state
                            .running_wait_tools
                            .values()
                            .any(|wait_id| wait_id == id)
                });

        execs_wait_only
            && self.tools_state.running_custom_tools.is_empty()
            && self.tools_state.web_search_sessions.is_empty()
            && !self.stream.is_write_cycle_active()
            && !self.agents_are_actively_running()
            && self.active_task_ids.is_empty()
    }

    /// If queued user messages have been blocked longer than the SLA while only a wait/kill
    /// tool is running, unlock the composer and dispatch the queue.
    fn maybe_enforce_queue_unblock(&mut self) {
        if self.queued_user_messages.is_empty() {
            self.queue_block_started_at = None;
            return;
        }

        let Some(started) = self.queue_block_started_at else {
            self.queue_block_started_at = Some(Instant::now());
            return;
        };

        if started.elapsed() < Duration::from_secs(10) {
            return;
        }

        if !self.wait_only_activity() {
            // Another activity is running; keep waiting.
            return;
        }

        let wait_ids: Vec<String> = self
            .tools_state
            .running_wait_tools
            .keys()
            .map(|k| k.0.clone())
            .collect();

        tracing::warn!(
            "queue watchdog fired; unblocking input (waits={:?}, queued={})",
            wait_ids,
            self.queued_user_messages.len()
        );

        self.bottom_pane.set_task_running(false);
        self.bottom_pane
            .update_status_text("Waiting in background".to_string());

        if !wait_ids.is_empty() {
            self.push_background_tail(format!(
                "Input unblocked after 10s; wait still running ({}).",
                wait_ids.join(", ")
            ));
        } else {
            self.push_background_tail("Input unblocked after 10s; wait still running.".to_string());
        }

        if let Some(front) = self.queued_user_messages.front().cloned() {
            self.dispatch_queued_user_message_now(front);
        }

        // Reset timer only if messages remain; otherwise leave it cleared so the next queue
        // submission can schedule a fresh watchdog.
        if self.queued_user_messages.is_empty() {
            self.queue_block_started_at = None;
        } else {
            self.queue_block_started_at = Some(Instant::now());
        }
        self.request_redraw();
    }

    /// Clear the composer text and any pending paste placeholders/history cursors.
    pub(crate) fn clear_composer(&mut self) {
        self.bottom_pane.clear_composer();
        if self.auto_state.should_show_goal_entry() {
            self.auto_goal_escape_state = AutoGoalEscState::Inactive;
        }
        // Mark a height change so layout adjusts immediately if the composer shrinks.
        self.height_manager
            .borrow_mut()
            .record_event(crate::height_manager::HeightEvent::ComposerModeChange);
        self.request_redraw();
    }

    /// Forward an `Op` directly to codex.
    pub(crate) fn submit_op(&self, op: Op) {
        if let Err(e) = self.code_op_tx.send(op) {
            tracing::error!("failed to submit op: {e}");
        }
    }

    /// Cancel the current running task from a non-keyboard context (e.g. approval modal).
    /// This bypasses modal key handling and invokes the same immediate UI cleanup path
    /// as pressing Ctrl-C/Esc while a task is running.
    pub(crate) fn cancel_running_task_from_approval(&mut self) {
        self.interrupt_running_task();
    }

    /// Stop any in-flight turn (Auto Drive, agents, streaming responses) before
    /// starting a brand new chat so that stale output cannot leak into the new
    /// conversation.
    pub(crate) fn abort_active_turn_for_new_chat(&mut self) {
        if self.has_cancelable_agents() {
            self.cancel_active_agents();
        }

        if self.auto_state.is_active() {
            self.auto_stop(None);
        }

        self.interrupt_running_task();
        self.finalize_active_stream();
        self.stream_state.drop_streaming = true;
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.clear_live_ring();
        self.maybe_hide_spinner();
    }

    pub(crate) fn register_approved_command(
        &self,
        command: Vec<String>,
        match_kind: ApprovedCommandMatchKind,
        semantic_prefix: Option<Vec<String>>,
    ) {
        if command.is_empty() {
            return;
        }
        let op = Op::RegisterApprovedCommand {
            command,
            match_kind,
            semantic_prefix,
        };
        self.submit_op(op);
    }

    /// Clear transient spinner/status after a denial without interrupting core
    /// execution. Only hide the spinner when there is no remaining activity so
    /// we avoid masking in-flight work (e.g. follow-up reasoning).
    pub(crate) fn mark_task_idle_after_denied(&mut self) {
        let any_tools_running = !self.exec.running_commands.is_empty()
            || !self.tools_state.running_custom_tools.is_empty()
            || !self.tools_state.web_search_sessions.is_empty();
        let any_streaming = self.stream.is_write_cycle_active();
        let any_agents_active = self.agents_are_actively_running();
        let any_tasks_active = !self.active_task_ids.is_empty();

        if !(any_tools_running || any_streaming || any_agents_active || any_tasks_active) {
            self.bottom_pane.set_task_running(false);
            self.bottom_pane.update_status_text(String::new());
            self.bottom_pane.clear_ctrl_c_quit_hint();
            self.mark_needs_redraw();
        }
    }

    pub(crate) fn insert_history_lines(&mut self, lines: Vec<ratatui::text::Line<'static>>) {
        let kind = self.stream_state.current_kind.unwrap_or(StreamKind::Answer);
        self.insert_history_lines_with_kind(kind, None, lines);
    }

    pub(crate) fn insert_history_lines_with_kind(
        &mut self,
        kind: StreamKind,
        id: Option<String>,
        lines: Vec<ratatui::text::Line<'static>>,
    ) {
        // No debug logging: we rely on preserving span modifiers end-to-end.
        // Insert all lines as a single streaming content cell to preserve spacing
        if lines.is_empty() {
            return;
        }

        if let Some(first_line) = lines.first() {
            let first_line_text: String = first_line
                .spans
                .iter()
                .map(|s| s.content.to_string())
                .collect();
            tracing::debug!("First line content: {:?}", first_line_text);
        }

        match kind {
            StreamKind::Reasoning => {
                // This reasoning block is the bottom-most; show progress indicator here only
                self.clear_reasoning_in_progress();
                // Ensure footer shows Ctrl+R hint when reasoning content is present
                self.bottom_pane.set_reasoning_hint(true);
                // Update footer label to reflect current visibility state
                self.bottom_pane
                    .set_reasoning_state(self.is_reasoning_shown());
                // Route by id when provided to avoid splitting reasoning across cells.
                // Be defensive: the cached index may be stale after inserts/removals; validate it.
                if let Some(ref rid) = id {
                    if let Some(&idx) = self.reasoning_index.get(rid) {
                        if idx < self.history_cells.len() {
                            if let Some(reasoning_cell) = self.history_cells[idx]
                                .as_any_mut()
                                .downcast_mut::<history_cell::CollapsibleReasoningCell>(
                            ) {
                                tracing::debug!(
                                    "Appending {} lines to Reasoning(id={})",
                                    lines.len(),
                                    rid
                                );
                                reasoning_cell.append_lines_dedup(lines);
                                reasoning_cell.set_in_progress(true);
                                self.invalidate_height_cache();
                                self.autoscroll_if_near_bottom();
                                self.request_redraw();
                                self.refresh_reasoning_collapsed_visibility();
                                return;
                            }
                        }
                        // Cached index was stale or wrong type — try to locate by scanning.
                        if let Some(found_idx) = self.history_cells.iter().rposition(|c| {
                            c.as_any()
                                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                                .map(|rc| rc.matches_id(rid))
                                .unwrap_or(false)
                        }) {
                            if let Some(reasoning_cell) = self.history_cells[found_idx]
                                .as_any_mut()
                                .downcast_mut::<history_cell::CollapsibleReasoningCell>()
                            {
                                // Refresh the cache with the corrected index
                                self.reasoning_index.insert(rid.clone(), found_idx);
                                tracing::debug!(
                                    "Recovered stale reasoning index; appending at {} for id={}",
                                    found_idx,
                                    rid
                                );
                                reasoning_cell.append_lines_dedup(lines);
                                reasoning_cell.set_in_progress(true);
                                self.invalidate_height_cache();
                                self.autoscroll_if_near_bottom();
                                self.request_redraw();
                                self.refresh_reasoning_collapsed_visibility();
                                return;
                            }
                        } else {
                            // No matching cell remains; drop the stale cache entry.
                            self.reasoning_index.remove(rid);
                        }
                    }
                }

                tracing::debug!("Creating new CollapsibleReasoningCell id={:?}", id);
                let cell = history_cell::CollapsibleReasoningCell::new_with_id(lines, id.clone());
                if self.config.tui.show_reasoning {
                    cell.set_collapsed(false);
                } else {
                    cell.set_collapsed(true);
                }
                cell.set_in_progress(true);

                // Use pre-seeded key for this stream id when present; otherwise synthesize.
                let key = match id.as_deref() {
                    Some(rid) => self.try_stream_order_key(kind, rid).unwrap_or_else(|| {
                        tracing::warn!(
                            "missing stream order key for Reasoning id={}; using synthetic key",
                            rid
                        );
                        self.next_internal_key()
                    }),
                    None => {
                        tracing::warn!("missing stream id for Reasoning; using synthetic key");
                        self.next_internal_key()
                    }
                };
                tracing::info!(
                    "[order] insert Reasoning new id={:?} {}",
                    id,
                    Self::debug_fmt_order_key(key)
                );
                let idx = self.history_insert_with_key_global(Box::new(cell), key);
                if let Some(rid) = id {
                    self.reasoning_index.insert(rid, idx);
                }
                // Auto Drive status updates are handled via coordinator decisions.
            }
            StreamKind::Answer => {
                tracing::debug!(
                    "history.insert Answer id={:?} incoming_lines={}",
                    id,
                    lines.len()
                );
                self.clear_reasoning_in_progress();

                let explicit_id = id.clone();
                let stream_identifier = explicit_id.clone().unwrap_or_else(|| {
                    self.stream
                        .current_stream_id()
                        .map(|s| s.to_string())
                        .unwrap_or_else(|| "stream-preview".to_string())
                });

                let fallback_preview = self
                    .synthesize_stream_state_from_lines(Some(&stream_identifier), &lines, true)
                    .preview_markdown;
                let preview_markdown = self
                    .stream
                    .preview_source_for_kind(StreamKind::Answer)
                    .unwrap_or(fallback_preview);

                let mutation = self.history_state.apply_domain_event(
                    HistoryDomainEvent::UpsertAssistantStream {
                        stream_id: stream_identifier.clone(),
                        preview_markdown,
                        delta: None,
                        metadata: None,
                    },
                );

                match mutation {
                    HistoryMutation::Inserted { id: history_id, record, .. } => {
                        let insert_key = match explicit_id.as_deref() {
                            Some(rid) => self.try_stream_order_key(kind, rid).unwrap_or_else(|| {
                                tracing::warn!(
                                    "missing stream order key for Answer id={}; using synthetic key",
                                    rid
                                );
                                self.next_internal_key()
                            }),
                            None => {
                                tracing::warn!(
                                    "missing stream id for Answer; using synthetic key"
                                );
                                self.next_internal_key()
                            }
                        };

                        let mut cell = self
                            .build_cell_from_record(&record)
                            .expect("assistant stream record should build cell");
                        self.assign_history_id(&mut cell, history_id);
                        let new_idx = self.history_insert_existing_record(
                            cell,
                            insert_key,
                            "stream-begin",
                            history_id,
                        );
                        tracing::debug!(
                            "history.new StreamingContentCell at idx={} id={:?}",
                            new_idx,
                            explicit_id
                        );
                    }
                    HistoryMutation::Replaced { id: history_id, record, .. } => {
                        self.update_cell_from_record(history_id, record);
                        self.mark_history_dirty();
                    }
                    HistoryMutation::Noop => {}
                    other => tracing::debug!(
                        "unexpected streaming mutation {:?} for id={:?}",
                        other,
                        explicit_id
                    ),
                }
            }
        }

        // Auto-follow if near bottom so new inserts are visible
        self.autoscroll_if_near_bottom();
        self.request_redraw();
        self.flush_history_snapshot_if_needed(false);
    }

    fn synthesize_stream_state_from_lines(
        &self,
        stream_id: Option<&String>,
        lines: &[ratatui::text::Line<'static>],
        in_progress: bool,
    ) -> AssistantStreamState {
        let mut preview = String::new();
        for (idx, line) in lines.iter().enumerate() {
            let flat: String = line
                .spans
                .iter()
                .map(|s| s.content.as_ref())
                .collect();
            if idx == 0 && flat.trim().eq_ignore_ascii_case("codex") {
                continue;
            }
            if !preview.is_empty() {
                preview.push('\n');
            }
            preview.push_str(&flat);
        }
        if !preview.is_empty() && !preview.ends_with('\n') {
            preview.push('\n');
        }
        let mut stream_id_string = stream_id
            .cloned()
            .unwrap_or_else(|| "stream-preview".to_string());
        if stream_id_string.is_empty() {
            stream_id_string = "stream-preview".to_string();
        }
        AssistantStreamState {
            id: HistoryId::ZERO,
            stream_id: stream_id_string,
            preview_markdown: preview,
            deltas: Vec::new(),
            citations: Vec::new(),
            metadata: None,
            in_progress,
            last_updated_at: SystemTime::now(),
            truncated_prefix_bytes: 0,
        }
    }

    fn refresh_streaming_cell_for_stream_id(
        &mut self,
        stream_id: &str,
        state: AssistantStreamState,
    ) {
        if state.id != HistoryId::ZERO {
            self.update_cell_from_record(
                state.id,
                HistoryRecord::AssistantStream(state.clone()),
            );
            self.autoscroll_if_near_bottom();
            return;
        }

        if let Some(existing) = self
            .history_state
            .assistant_stream_state(stream_id)
            .cloned()
        {
            if existing.id != HistoryId::ZERO {
                self.update_cell_from_record(
                    existing.id,
                    HistoryRecord::AssistantStream(existing),
                );
                self.autoscroll_if_near_bottom();
            }
        }
    }

    fn update_stream_token_usage_metadata(&mut self) {
        let Some(stream_id) = self.stream.current_stream_id().cloned() else {
            return;
        };
        let Some(preview) = self
            .stream
            .preview_source_for_kind(StreamKind::Answer)
        else {
            return;
        };
        let metadata = MessageMetadata {
            citations: Vec::new(),
            token_usage: Some(self.last_token_usage.clone()),
        };
        self
            .history_state
            .upsert_assistant_stream_state(&stream_id, preview, None, Some(&metadata));
        if let Some(state) = self
            .history_state
            .assistant_stream_state(&stream_id)
            .cloned()
        {
            self.refresh_streaming_cell_for_stream_id(&stream_id, state);
        }
    }

    fn track_answer_stream_delta(&mut self, stream_id: &str, delta: &str, seq: Option<u64>) {
        let preview = self
            .stream
            .preview_source_for_kind(StreamKind::Answer)
            .unwrap_or_default();
        let delta = if delta.is_empty() {
            None
        } else {
            Some(AssistantStreamDelta {
                delta: delta.to_string(),
                sequence: seq,
                received_at: SystemTime::now(),
            })
        };
        let mutation = self.history_state.apply_domain_event(
            HistoryDomainEvent::UpsertAssistantStream {
                stream_id: stream_id.to_string(),
                preview_markdown: preview,
                delta,
                metadata: None,
            },
        );

        match mutation {
            HistoryMutation::Inserted { record, .. } => {
                if let HistoryRecord::AssistantStream(state) = record {
                    self.refresh_streaming_cell_for_stream_id(stream_id, state);
                    self.mark_history_dirty();
                }
            }
            HistoryMutation::Replaced { id, record, .. } => {
                if matches!(record, HistoryRecord::AssistantStream(_)) {
                    self.update_cell_from_record(id, record);
                    self.mark_history_dirty();
                }
            }
            _ => {}
        }
    }

    fn note_answer_stream_seen(&mut self, new_stream_id: &str) {
        let prev = self.last_seen_answer_stream_id_in_turn.clone();
        if let Some(prev) = prev {
            if prev != new_stream_id {
                self.mid_turn_answer_ids_in_turn.insert(prev.clone());
                self.maybe_mark_finalized_answer_mid_turn(&prev);
            }
        }
        self.last_seen_answer_stream_id_in_turn = Some(new_stream_id.to_string());
    }

    fn maybe_mark_finalized_answer_mid_turn(&mut self, prev_stream_id: &str) {
        let Some(last_final_id) = self.last_answer_stream_id_in_turn.as_deref() else {
            return;
        };
        if last_final_id != prev_stream_id {
            return;
        }
        let Some(prev_history_id) = self.last_answer_history_id_in_turn else {
            return;
        };

        let mut changed = false;
        if let Some(idx) = self
            .history_cell_ids
            .iter()
            .rposition(|hid| *hid == Some(prev_history_id))
        {
            if let Some(cell) = self.history_cells[idx]
                .as_any_mut()
                .downcast_mut::<history_cell::AssistantMarkdownCell>()
            {
                if !cell.state().mid_turn {
                    cell.set_mid_turn(true);
                    changed = true;
                }
            }
        }

        if let Some(record) = self.history_state.record_mut(prev_history_id) {
            if let HistoryRecord::AssistantMessage(state) = record {
                if !state.mid_turn {
                    state.mid_turn = true;
                    changed = true;
                }
            }
        }

        if changed {
            self.mark_history_dirty();
            self.request_redraw();
        }
    }

    fn apply_mid_turn_flag(&self, stream_id: Option<&str>, state: &mut AssistantMessageState) {
        if let Some(sid) = stream_id {
            if self.mid_turn_answer_ids_in_turn.contains(sid) {
                state.mid_turn = true;
            }
        }
    }

    fn maybe_clear_mid_turn_for_last_answer(&mut self, stream_id: &str) {
        let Some(last_history_id) = self.last_answer_history_id_in_turn else {
            return;
        };

        let mut changed = false;

        if let Some(record) = self.history_state.record_mut(last_history_id) {
            if let HistoryRecord::AssistantMessage(state) = record {
                if state.stream_id.as_deref() == Some(stream_id) && state.mid_turn {
                    state.mid_turn = false;
                    changed = true;
                }
            }
        }

        if let Some(idx) = self
            .history_cell_ids
            .iter()
            .rposition(|hid| *hid == Some(last_history_id))
        {
            if let Some(cell) = self.history_cells[idx]
                .as_any_mut()
                .downcast_mut::<history_cell::AssistantMarkdownCell>()
            {
                if cell.stream_id() == Some(stream_id) && cell.state().mid_turn {
                    cell.set_mid_turn(false);
                    changed = true;
                }
            }
        }

        if changed {
            self.mark_history_dirty();
            self.request_redraw();
        }
    }

    fn finalize_answer_stream_state(
        &mut self,
        stream_id: Option<&str>,
        source: &str,
    ) -> AssistantMessageState {
        let mut metadata = stream_id.and_then(|sid| {
            self.history_state
                .assistant_stream_state(sid)
                .and_then(|state| state.metadata.clone())
        });

        let should_attach_token_usage = self.last_token_usage.total_tokens > 0;
        if should_attach_token_usage {
            if let Some(meta) = metadata.as_mut() {
                if meta.token_usage.is_none() {
                    meta.token_usage = Some(self.last_token_usage.clone());
                }
            } else {
                metadata = Some(MessageMetadata {
                    citations: Vec::new(),
                    token_usage: Some(self.last_token_usage.clone()),
                });
            }
        }

        let token_usage = if should_attach_token_usage {
            Some(self.last_token_usage.clone())
        } else {
            None
        };

        let state = self.history_state.finalize_assistant_stream_state(
            stream_id,
            source.to_string(),
            metadata.as_ref(),
            token_usage.as_ref(),
        );
        state
    }

    /// Replace the in-progress streaming assistant cell with a final markdown cell that
    /// stores raw markdown for future re-rendering.
    pub(crate) fn insert_final_answer_with_id(
        &mut self,
        id: Option<String>,
        lines: Vec<ratatui::text::Line<'static>>,
        source: String,
    ) {
        tracing::debug!(
            "insert_final_answer_with_id id={:?} source_len={} lines={}",
            id,
            source.len(),
            lines.len()
        );
        tracing::info!("[order] final Answer id={:?}", id);
        let final_source = source.clone();

        if self.auto_state.pending_stop_message.is_some() {
            match serde_json::from_str::<code_auto_drive_diagnostics::CompletionCheck>(&final_source)
            {
                Ok(check) => {
                    if check.complete {
                        let explanation = check.explanation.trim();
                        if explanation.is_empty() {
                            self.auto_state.last_completion_explanation = None;
                        } else {
                            self.auto_state.last_completion_explanation =
                                Some(explanation.to_string());
                        }
                        let pending = self.auto_state.pending_stop_message.take();
                        if let Some(idx) = self.history_cells.iter().rposition(|c| {
                            c.as_any()
                                .downcast_ref::<history_cell::StreamingContentCell>()
                                .and_then(|sc| sc.id.as_ref())
                                .map(|existing| Some(existing.as_str()) == id.as_deref())
                                .unwrap_or(false)
                        }) {
                            self.history_remove_at(idx);
                        }
                        if let Some(ref stream_id) = id {
                            let _ = self.history_state.finalize_assistant_stream_state(
                                Some(stream_id.as_str()),
                                String::new(),
                                None,
                                None,
                            );
                            self.stream_state
                                .closed_answer_ids
                                .insert(StreamId(stream_id.clone()));
                        }
                        self.auto_stop(pending);
                        self.stop_spinner();
                        return;
                    } else {
                        self.auto_state.last_completion_explanation = None;
                        let goal = self
                            .auto_state
                            .goal
                            .as_deref()
                            .unwrap_or("(goal unavailable)");
                    let follow_up = format!(
                        "The primary goal has not been met. Please continue working on this.\nPrimary Goal: {goal}\nExplanation: {explanation}",
                        explanation = check.explanation
                    );
                    let mut conversation = self.rebuild_auto_history();
                    if let Some(user_item) = Self::auto_drive_make_user_message(follow_up.clone()) {
                        conversation.push(user_item.clone());
                        self.auto_history.append_raw(std::slice::from_ref(&user_item));
                    }
                    self.auto_state.pending_stop_message = None;
                    // Re-run the conversation through the normal decision pipeline so the
                    // coordinator produces a full finish_status/progress/cli turn rather than
                    // falling back to the user-response schema.
                    self.auto_state.set_phase(AutoRunPhase::Active);
                    self.auto_send_conversation_force();
                    self.stop_spinner();
                    return;
                }
                }
                Err(err) => {
                    tracing::warn!(
                        "failed to parse diagnostics completion check: {}",
                        err
                    );
                    self.auto_state.last_completion_explanation = None;
                    let pending = self.auto_state.pending_stop_message.take();
                    self.auto_stop(pending);
                }
            }
        }
            if self.is_review_flow_active() {
            if let Some(ref want) = id {
                if !self
                    .stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()))
                {
                    tracing::debug!(
                        "InsertFinalAnswer(review): dropping duplicate final for id={}",
                        want
                    );
                    self.last_assistant_message = Some(final_source.clone());
                    self.maybe_hide_spinner();
                    return;
                }
                if let Some(idx) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::StreamingContentCell>()
                        .and_then(|sc| sc.id.as_ref())
                        .map(|existing| existing == want)
                        .unwrap_or(false)
                }) {
                    self.history_remove_at(idx);
                }
            } else if let Some(idx) = self.history_cells.iter().rposition(|c| {
                c.as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                    .is_some()
            }) {
                self.history_remove_at(idx);
            }
            self.last_assistant_message = Some(final_source.clone());
            let mut state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
            self.apply_mid_turn_flag(id.as_deref(), &mut state);
            let history_id = state.id;
            let mut key = match id.as_deref() {
                Some(rid) => self.try_stream_order_key(StreamKind::Answer, rid).unwrap_or_else(|| {
                    tracing::warn!(
                        "missing stream order key for final Answer id={}; using synthetic key",
                        rid
                    );
                    self.next_internal_key()
                }),
                None => {
                    tracing::warn!("missing stream id for final Answer; using synthetic key");
                    self.next_internal_key()
                }
            };

            if let Some(last) = self.last_assigned_order {
                if key <= last {
                    key = Self::order_key_successor(last);
                    if let Some(ref want) = id {
                        self.stream_order_seq
                            .insert((StreamKind::Answer, want.clone()), key);
                    }
                }
            }

            let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
            self.history_insert_existing_record(Box::new(cell), key, "answer-review", history_id);
            self.last_answer_stream_id_in_turn = id.clone();
            self.last_answer_history_id_in_turn = Some(history_id);
            // Advance Auto Drive after the assistant message has been finalized.
            self.auto_on_assistant_final();
            self.maybe_hide_spinner();
            return;
        }
        // Debug: list last few history cell kinds so we can see what's present
        let tail_kinds: String = self
            .history_cells
            .iter()
            .rev()
            .take(5)
            .map(|c| {
                if c.as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                    .is_some()
                {
                    "Streaming".to_string()
                } else if c
                    .as_any()
                    .downcast_ref::<history_cell::AssistantMarkdownCell>()
                    .is_some()
                {
                    "AssistantFinal".to_string()
                } else if c
                    .as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
                    .is_some()
                {
                    "Reasoning".to_string()
                } else {
                    format!("{:?}", c.kind())
                }
            })
            .collect::<Vec<_>>()
            .join(", ");
        tracing::debug!("history.tail kinds(last5) = [{}]", tail_kinds);

        // When we have an id but could not find a streaming cell by id, dump ids
        if id.is_some() {
            let ids: Vec<String> = self
                .history_cells
                .iter()
                .enumerate()
                .filter_map(|(i, c)| {
                    c.as_any()
                        .downcast_ref::<history_cell::StreamingContentCell>()
                        .and_then(|sc| sc.id.as_ref().map(|s| format!("{}:{}", i, s)))
                })
                .collect();
            tracing::debug!("history.streaming ids={}", ids.join(" | "));
        }
        // If we already finalized this id in the current turn with identical content,
        // drop this event to avoid duplicates (belt-and-suspenders against upstream repeats).
        if let Some(ref want) = id {
            if self
                .stream_state
                .closed_answer_ids
                .contains(&StreamId(want.clone()))
            {
                if let Some(existing_idx) = self.history_cells.iter().rposition(|c| {
                    c.as_any()
                        .downcast_ref::<history_cell::AssistantMarkdownCell>()
                        .map(|amc| amc.stream_id() == Some(want.as_str()))
                        .unwrap_or(false)
                }) {
                    if let Some(amc) = self.history_cells[existing_idx]
                        .as_any()
                        .downcast_ref::<history_cell::AssistantMarkdownCell>()
                    {
                        let prev = Self::normalize_text(amc.markdown());
                        let newn = Self::normalize_text(&source);
                        if prev == newn {
                            tracing::debug!(
                                "InsertFinalAnswer: dropping duplicate final for id={}",
                                want
                            );
                            self.maybe_hide_spinner();
                            return;
                        }
                    }
                }
            }
        }
        // Ensure a hidden 'codex' header is present
        let has_header = lines
            .first()
            .map(|l| {
                l.spans
                    .iter()
                    .map(|s| s.content.as_ref())
                    .collect::<String>()
                    .trim()
                    .eq_ignore_ascii_case("codex")
            })
            .unwrap_or(false);
        if !has_header {
            // No need to mutate `lines` further since we rebuild from `source` below.
        }

        // Replace the matching StreamingContentCell if one exists for this id; else fallback to most recent.
        // NOTE (dup‑guard): This relies on `StreamingContentCell::as_any()` returning `self`.
        // If that impl is removed, downcast_ref will fail and we won't find the streaming cell,
        // causing the final to append a new Assistant cell (duplicate).
        let streaming_idx = if let Some(ref want) = id {
            // Only replace a streaming cell if its id matches this final.
            self.history_cells.iter().rposition(|c| {
                if let Some(sc) = c
                    .as_any()
                    .downcast_ref::<history_cell::StreamingContentCell>()
                {
                    sc.id.as_ref() == Some(want)
                } else {
                    false
                }
            })
        } else {
            None
        };
        if let Some(idx) = streaming_idx {
            tracing::debug!(
                "final-answer: replacing StreamingContentCell at idx={} by id match",
                idx
            );
            let mut state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
            self.apply_mid_turn_flag(id.as_deref(), &mut state);
            let history_id = state.id;
            let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
            self.history_replace_at(idx, Box::new(cell));
            if let Some(ref want) = id {
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()));
            }
            self.autoscroll_if_near_bottom();
            self.last_answer_stream_id_in_turn = id.clone();
            self.last_answer_history_id_in_turn = Some(history_id);
            // Final cell committed via replacement; now advance Auto Drive.
            self.auto_on_assistant_final();
            self.maybe_hide_spinner();
            return;
        }

        // No streaming cell found. First, try to replace a finalized assistant cell
        // that was created for the same stream id (e.g., we already finalized due to
        // a lifecycle event and this InsertFinalAnswer arrived slightly later).
        if let Some(ref want) = id {
            if let Some(idx) = self.history_cells.iter().rposition(|c| {
                if let Some(amc) = c
                    .as_any()
                    .downcast_ref::<history_cell::AssistantMarkdownCell>()
                {
                    amc.stream_id() == Some(want.as_str())
                } else {
                    false
                }
            }) {
                tracing::debug!(
                    "final-answer: replacing existing AssistantMarkdownCell at idx={} by id match",
                    idx
                );
                let mut state =
                    self.finalize_answer_stream_state(id.as_deref(), &final_source);
                self.apply_mid_turn_flag(id.as_deref(), &mut state);
                let history_id = state.id;
                let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
                self.history_replace_at(idx, Box::new(cell));
                self.stream_state
                    .closed_answer_ids
                    .insert(StreamId(want.clone()));
                self.autoscroll_if_near_bottom();
                self.last_answer_stream_id_in_turn = id.clone();
                self.last_answer_history_id_in_turn = Some(history_id);
                // Final cell replaced in-place; advance Auto Drive now.
                self.auto_on_assistant_final();
                self.maybe_hide_spinner();
                return;
            }
        }

        // Otherwise, if a finalized assistant cell exists at the tail,
        // replace it in place to avoid duplicate assistant messages when a second
        // InsertFinalAnswer (e.g., from an AgentMessage event) arrives after we already
        // finalized due to a side event.
        if let Some(idx) = self.history_cells.iter().rposition(|c| {
            c.as_any()
                .downcast_ref::<history_cell::AssistantMarkdownCell>()
                .is_some()
        }) {
            // Replace the tail finalized assistant cell if the new content is identical OR
            // a small revision that merely adds leading/trailing context. Otherwise append a
            // new assistant message so distinct replies remain separate.
            let should_replace = self.history_cells[idx]
                .as_any()
                .downcast_ref::<history_cell::AssistantMarkdownCell>()
                .map(|amc| {
                    let prev = Self::normalize_text(amc.markdown());
                    let newn = Self::normalize_text(&source);
                    let identical = prev == newn;
                    if identical || prev.is_empty() {
                        return identical;
                    }
                    let is_prefix_expansion = newn.starts_with(&prev);
                    let is_suffix_expansion = newn.ends_with(&prev);
                    let is_large_superset = prev.len() >= 80 && newn.contains(&prev);
                    identical || is_prefix_expansion || is_suffix_expansion || is_large_superset
                })
                .unwrap_or(false);
            if should_replace {
                tracing::debug!(
                    "final-answer: replacing tail AssistantMarkdownCell via heuristic identical/expansion"
                );
                let mut state =
                    self.finalize_answer_stream_state(id.as_deref(), &final_source);
                self.apply_mid_turn_flag(id.as_deref(), &mut state);
                let history_id = state.id;
                let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
                self.history_replace_at(idx, Box::new(cell));
                self.autoscroll_if_near_bottom();
                self.last_answer_stream_id_in_turn = id.clone();
                self.last_answer_history_id_in_turn = Some(history_id);
                // Final assistant content revised; advance Auto Drive now.
                self.auto_on_assistant_final();
                self.maybe_hide_spinner();
                return;
            }
        }

        // Fallback: no prior assistant cell found; insert at stable sequence position.
        tracing::debug!(
            "final-answer: ordered insert new AssistantMarkdownCell id={:?}",
            id
        );
        let mut key = match id.as_deref() {
            Some(rid) => self
                .try_stream_order_key(StreamKind::Answer, rid)
                .unwrap_or_else(|| {
                    tracing::warn!(
                        "missing stream order key for final Answer id={}; using synthetic key",
                        rid
                    );
                    self.next_internal_key()
                }),
            None => {
                tracing::warn!("missing stream id for final Answer; using synthetic key");
                self.next_internal_key()
            }
        };
        if let Some(last) = self.last_assigned_order {
            if key <= last {
                // Background notices anchor themselves at out = i32::MAX. If a final answer arrives
                // after those notices we still want it to appear at the bottom, so bump the key
                // just past the most-recently assigned slot.
                key = Self::order_key_successor(last);
                if let Some(ref want) = id {
                    self.stream_order_seq
                        .insert((StreamKind::Answer, want.clone()), key);
                }
            }
        }
        tracing::info!(
            "[order] final Answer ordered insert id={:?} {}",
            id,
            Self::debug_fmt_order_key(key)
        );
        let mut state = self.finalize_answer_stream_state(id.as_deref(), &final_source);
        self.apply_mid_turn_flag(id.as_deref(), &mut state);
        let history_id = state.id;
        let cell = history_cell::AssistantMarkdownCell::from_state(state, &self.config);
        self.history_insert_existing_record(
            Box::new(cell),
            key,
            "answer-final",
            history_id,
        );
        if let Some(ref want) = id {
            self.stream_state
                .closed_answer_ids
                .insert(StreamId(want.clone()));
        }
        self.last_answer_stream_id_in_turn = id.clone();
        self.last_answer_history_id_in_turn = Some(history_id);
        // Ordered insert completed; advance Auto Drive now that the assistant
        // message is present in history.
        self.auto_on_assistant_final();
        self.maybe_hide_spinner();
    }

    // Assign or fetch a stable sequence for a stream kind+id within its originating turn
    // removed legacy ensure_stream_order_key; strict variant is used instead

    /// Normalize text for duplicate detection (trim trailing whitespace and normalize newlines)
    fn normalize_text(s: &str) -> String {
        // 1) Normalize newlines
        let s = s.replace("\r\n", "\n");
        // 2) Trim trailing whitespace per line; collapse repeated blank lines
        let mut out: Vec<String> = Vec::new();
        let mut saw_blank = false;
        for line in s.lines() {
            // Replace common Unicode bullets with ASCII to stabilize equality checks
            let line = line
                .replace('\u{2022}', "-") // •
                .replace('\u{25E6}', "-") // ◦
                .replace('\u{2219}', "-"); // ∙
            let trimmed = line.trim_end();
            if trimmed.chars().all(|c| c.is_whitespace()) {
                if !saw_blank {
                    out.push(String::new());
                }
                saw_blank = true;
            } else {
                out.push(trimmed.to_string());
                saw_blank = false;
            }
        }
        // 3) Remove trailing blank lines
        while out.last().is_some_and(|l| l.is_empty()) {
            out.pop();
        }
        out.join("\n")
    }

    pub(crate) fn toggle_reasoning_visibility(&mut self) {
        // Track whether any reasoning cells are found and their new state
        let mut has_reasoning_cells = false;
        let mut new_collapsed_state = false;

        // Toggle all CollapsibleReasoningCell instances in history
        for cell in &self.history_cells {
            // Try to downcast to CollapsibleReasoningCell
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                reasoning_cell.toggle_collapsed();
                has_reasoning_cells = true;
                new_collapsed_state = reasoning_cell.is_collapsed();
            }
        }

        // Update the config to reflect the current state (inverted because collapsed means hidden)
        if has_reasoning_cells {
            self.config.tui.show_reasoning = !new_collapsed_state;
            // Brief status to confirm the toggle to the user
            let status = if self.config.tui.show_reasoning {
                "Reasoning shown"
            } else {
                "Reasoning hidden"
            };
            self.bottom_pane.update_status_text(status.to_string());
            // Update footer label to reflect current state
            self.bottom_pane
                .set_reasoning_state(self.config.tui.show_reasoning);
        } else {
            // No reasoning cells exist; inform the user
            self.bottom_pane
                .update_status_text("No reasoning to toggle".to_string());
        }
        self.refresh_reasoning_collapsed_visibility();
        // Collapsed state changes affect heights; clear cache
        self.invalidate_height_cache();
        self.request_redraw();
        // In standard terminal mode, re-mirror the transcript so scrollback reflects
        // the new collapsed/expanded state. We cannot edit prior lines in scrollback,
        // so append a fresh view.
        if self.standard_terminal_mode {
            let mut lines = Vec::new();
            lines.push(ratatui::text::Line::from(""));
            lines.extend(self.export_transcript_lines_for_buffer());
            self.app_event_tx
                .send(crate::app_event::AppEvent::InsertHistory(lines));
        }
    }

    fn refresh_standard_terminal_hint(&mut self) {
        if self.standard_terminal_mode {
            let message = "Standard terminal mode active. Press Ctrl+T to return to full UI.";
            self.bottom_pane
                .set_standard_terminal_hint(Some(message.to_string()));
        } else {
            self.bottom_pane.set_standard_terminal_hint(None);
        }
    }

    pub(crate) fn set_standard_terminal_mode(&mut self, enabled: bool) {
        self.standard_terminal_mode = enabled;
        self.refresh_standard_terminal_hint();
    }

    pub(crate) fn is_reasoning_shown(&self) -> bool {
        // Check if any reasoning cell exists and if it's expanded
        for cell in &self.history_cells {
            if let Some(reasoning_cell) = cell
                .as_any()
                .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            {
                return !reasoning_cell.is_collapsed();
            }
        }
        // If no reasoning cells exist, return the config default
        self.config.tui.show_reasoning
    }

    pub(crate) fn show_chrome_options(&mut self, port: Option<u16>) {
        self.ensure_settings_overlay_section(SettingsSection::Chrome);
        let content = self.build_chrome_settings_content(port);
        if let Some(overlay) = self.settings.overlay.as_mut() {
            overlay.set_chrome_content(content);
        }
        self.request_redraw();
    }

    pub(crate) fn handle_chrome_launch_option(
        &mut self,
        option: ChromeLaunchOption,
        port: Option<u16>,
    ) {
        let launch_port = port.unwrap_or(9222);
        let ticket = self.make_background_tail_ticket();

        match option {
            ChromeLaunchOption::CloseAndUseProfile => {
                // Kill existing Chrome and launch with user profile
                #[cfg(target_os = "macos")]
                {
                    let _ = std::process::Command::new("pkill")
                        .arg("-f")
                        .arg("Google Chrome")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                #[cfg(target_os = "linux")]
                {
                    let _ = std::process::Command::new("pkill")
                        .arg("-f")
                        .arg("chrome")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                #[cfg(target_os = "windows")]
                {
                    let _ = std::process::Command::new("taskkill")
                        .arg("/F")
                        .arg("/IM")
                        .arg("chrome.exe")
                        .output();
                    std::thread::sleep(std::time::Duration::from_millis(500));
                }
                self.launch_chrome_with_profile(launch_port);
                // Connect to Chrome after launching
                self.connect_to_chrome_after_launch(launch_port, ticket.clone());
            }
            ChromeLaunchOption::UseTempProfile => {
                // Launch with temporary profile
                self.launch_chrome_with_temp_profile(launch_port);
                // Connect to Chrome after launching
                self.connect_to_chrome_after_launch(launch_port, ticket.clone());
            }
            ChromeLaunchOption::UseInternalBrowser => {
                // Redirect to internal browser command
                self.handle_browser_command(String::new());
            }
            ChromeLaunchOption::Cancel => {
                // Do nothing, just close the dialog
            }
        }
    }

    fn launch_chrome_with_profile(&mut self, port: u16) {
        use std::process::Stdio;
        let log_path = self.chrome_log_path();

        #[cfg(target_os = "macos")]
        {
            let mut cmd = std::process::Command::new(
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            );
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            self.apply_chrome_logging(&mut cmd, log_path.as_deref());
            if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                tracing::warn!("failed to launch Chrome with profile: {err}");
            }
        }

        #[cfg(target_os = "linux")]
        {
            let mut cmd = std::process::Command::new("google-chrome");
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            self.apply_chrome_logging(&mut cmd, log_path.as_deref());
            if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                tracing::warn!("failed to launch Chrome with profile: {err}");
            }
        }

        #[cfg(target_os = "windows")]
        {
            let chrome_paths = vec![
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                format!(
                    "{}\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe",
                    std::env::var("USERPROFILE").unwrap_or_default()
                ),
            ];

            for chrome_path in chrome_paths {
                if std::path::Path::new(&chrome_path).exists() {
                    let mut cmd = std::process::Command::new(&chrome_path);
                    cmd.arg(format!("--remote-debugging-port={}", port))
                        .arg("--no-first-run")
                        .arg("--no-default-browser-check")
                        .arg("--disable-component-extensions-with-background-pages")
                        .arg("--disable-background-networking")
                        .arg("--silent-debugger-extension-api")
                        .arg("--remote-allow-origins=*")
                        .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                        .arg("--disable-hang-monitor")
                        .arg("--disable-background-timer-throttling")
                        .stdout(Stdio::null())
                        .stderr(Stdio::null())
                        .stdin(Stdio::null());
                    self.apply_chrome_logging(&mut cmd, log_path.as_deref());
                    if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                        tracing::warn!("failed to launch Chrome with profile: {err}");
                    }
                    break;
                }
            }
        }

        // Add status message
        self.push_background_tail("✅ Chrome launched with user profile".to_string());
        // Show browsing state in input border after launch
        self.bottom_pane
            .update_status_text("using browser".to_string());
    }

    fn chrome_log_path(&self) -> Option<String> {
        if !self.config.debug {
            return None;
        }
        let log_dir = code_core::config::log_dir(&self.config).ok()?;
        Some(log_dir.join("code-chrome.log").display().to_string())
    }

    fn apply_chrome_logging(&self, cmd: &mut std::process::Command, log_path: Option<&str>) {
        if let Some(path) = log_path {
            cmd.arg("--enable-logging")
                .arg("--log-level=1")
                .arg(format!("--log-file={path}"));
        }
    }

    fn connect_to_chrome_after_launch(
        &mut self,
        port: u16,
        ticket: BackgroundOrderTicket,
    ) {
        // Wait a moment for Chrome to start, then reuse the existing connection logic
        let app_event_tx = self.app_event_tx.clone();
        let latest_screenshot = self.latest_browser_screenshot.clone();

        tokio::spawn(async move {
            // Wait for Chrome to fully start
            tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

            // Now try to connect using the shared CDP connection logic
            ChatWidget::connect_to_cdp_chrome(
                None,
                Some(port),
                latest_screenshot,
                app_event_tx,
                ticket,
            )
            .await;
        });
    }

    /// Shared CDP connection logic used by both /chrome command and Chrome launch options
    async fn connect_to_cdp_chrome(
        host: Option<String>,
        port: Option<u16>,
        latest_screenshot: Arc<Mutex<Option<(PathBuf, String)>>>,
        app_event_tx: AppEventSender,
        ticket: BackgroundOrderTicket,
    ) {
        tracing::info!(
            "[cdp] connect_to_cdp_chrome() begin, host={:?}, port={:?}",
            host,
            port
        );
        let browser_manager = ChatWidget::get_browser_manager().await;
        browser_manager.set_enabled_sync(true);

        // Configure for CDP connection (prefer cached ws/port on auto-detect)
        // Track whether we're attempting via cached WS and retain a cached port for fallback.
        let mut attempted_via_cached_ws = false;
        let mut cached_port_for_fallback: Option<u16> = None;
        {
            let mut config = browser_manager.config.write().await;
            config.headless = false;
            config.persist_profile = true;
            config.enabled = true;

            if let Some(p) = port {
                config.connect_ws = None;
                config.connect_host = host.clone();
                config.connect_port = Some(p);
            } else {
                // Load persisted cache from disk (if any), then fall back to in-memory
                let (cached_port, cached_ws) = match read_cached_connection().await {
                    Some(v) => v,
                    None => code_browser::global::get_last_connection().await,
                };
                cached_port_for_fallback = cached_port;
                if let Some(ws) = cached_ws {
                    tracing::info!("[cdp] using cached Chrome WS endpoint");
                    attempted_via_cached_ws = true;
                    config.connect_ws = Some(ws);
                    config.connect_port = None;
                } else if let Some(p) = cached_port_for_fallback {
                    tracing::info!("[cdp] using cached Chrome debug port: {}", p);
                    config.connect_ws = None;
                    config.connect_host = host.clone();
                    config.connect_port = Some(p);
                } else {
                    config.connect_ws = None;
                    config.connect_host = host.clone();
                    config.connect_port = Some(0); // auto-detect
                }
            }
        }

        // Try to connect to existing Chrome (no fallback to internal browser) with timeout
        tracing::info!("[cdp] calling BrowserManager::connect_to_chrome_only()…");
        // Allow 15s for WS discovery + 5s for connect
        let connect_deadline = tokio::time::Duration::from_secs(20);
        let connect_result =
            tokio::time::timeout(connect_deadline, browser_manager.connect_to_chrome_only()).await;
        match connect_result {
            Err(_) => {
                tracing::error!(
                    "[cdp] connect_to_chrome_only timed out after {:?}",
                    connect_deadline
                );
                app_event_tx.send_background_event_with_ticket(
                    &ticket,
                    format!(
                        "❌ CDP connect timed out after {}s. Ensure Chrome is running with --remote-debugging-port={} and http://127.0.0.1:{}/json/version is reachable",
                        connect_deadline.as_secs(),
                        port.unwrap_or(0),
                        port.unwrap_or(0)
                    ),
                );
                // Offer launch options popup to help recover quickly
                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                return;
            }
            Ok(result) => match result {
                Ok(_) => {
                    tracing::info!("[cdp] Connected to Chrome via CDP");

                    // Build a detailed success message including CDP port and current URL when available
                    let (detected_port, detected_ws) =
                        code_browser::global::get_last_connection().await;
                    // Prefer explicit port; otherwise try to parse from ws URL
                    let mut port_num: Option<u16> = detected_port;
                    if port_num.is_none() {
                        if let Some(ws) = &detected_ws {
                            // crude parse: ws://host:port/...
                            if let Some(after_scheme) = ws.split("//").nth(1) {
                                if let Some(hostport) = after_scheme.split('/').next() {
                                    if let Some(pstr) = hostport.split(':').nth(1) {
                                        if let Ok(p) = pstr.parse::<u16>() {
                                            port_num = Some(p);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Try to capture current page URL (best-effort)
                    let current_url = browser_manager.get_current_url().await;

                    let success_msg = match (port_num, current_url) {
                        (Some(p), Some(url)) if !url.is_empty() => {
                            format!("✅ Connected to Chrome via CDP (port {}) to {}", p, url)
                        }
                        (Some(p), _) => format!("✅ Connected to Chrome via CDP (port {})", p),
                        (None, Some(url)) if !url.is_empty() => {
                            format!("✅ Connected to Chrome via CDP to {}", url)
                        }
                        _ => "✅ Connected to Chrome via CDP".to_string(),
                    };

                    // Immediately notify success (do not block on screenshots)
                    app_event_tx
                        .send_background_event_with_ticket(&ticket, success_msg.clone());

                    // Persist last connection cache to disk (best-effort)
                    tokio::spawn(async move {
                        let (p, ws) = code_browser::global::get_last_connection().await;
                        let _ = write_cached_connection(p, ws).await;
                    });

                    // Set up navigation callback
                    let latest_screenshot_callback = latest_screenshot.clone();
                    let app_event_tx_callback = app_event_tx.clone();

                    browser_manager
                        .set_navigation_callback(move |url| {
                            tracing::info!("CDP Navigation callback triggered for URL: {}", url);
                            let latest_screenshot_inner = latest_screenshot_callback.clone();
                            let app_event_tx_inner = app_event_tx_callback.clone();
                            let url_inner = url.clone();

                            tokio::spawn(async move {
                                tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                let browser_manager_inner = ChatWidget::get_browser_manager().await;
                                let mut attempt = 0;
                                let max_attempts = 2;
                                loop {
                                    attempt += 1;
                                    match browser_manager_inner.capture_screenshot_with_url().await
                                    {
                                        Ok((paths, _)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!(
                                                    "[cdp] auto-captured screenshot: {}",
                                                    first_path.display()
                                                );

                                                if let Ok(mut latest) =
                                                    latest_screenshot_inner.lock()
                                                {
                                                    *latest = Some((
                                                        first_path.clone(),
                                                        url_inner.clone(),
                                                    ));
                                                }

                                                use code_core::protocol::{
                                                    BrowserScreenshotUpdateEvent, Event, EventMsg,
                                                };
                                                let _ = app_event_tx_inner.send(
                                                    AppEvent::CodexEvent(Event {
                                                        id: uuid::Uuid::new_v4().to_string(),
                                                        event_seq: 0,
                                                        msg: EventMsg::BrowserScreenshotUpdate(
                                                            BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url_inner,
                                                            },
                                                        ),
                                                        order: None,
                                                    }),
                                                );
                                                break;
                                            }
                                        }
                                        Err(e) => {
                                            tracing::warn!(
                                                "[cdp] auto-capture failed (attempt {}): {}",
                                                attempt,
                                                e
                                            );
                                            if attempt >= max_attempts {
                                                break;
                                            }
                                            tokio::time::sleep(tokio::time::Duration::from_millis(
                                                250,
                                            ))
                                            .await;
                                            continue;
                                        }
                                    }
                                    // end match
                                }
                                // end loop
                            });
                        })
                        .await;

                    // Set as global manager
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Capture initial screenshot in background (don't block connect feedback)
                    {
                        let latest_screenshot_bg = latest_screenshot.clone();
                        let app_event_tx_bg = app_event_tx.clone();
                        tokio::spawn(async move {
                            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            let mut attempt = 0;
                            let max_attempts = 2;
                            loop {
                                attempt += 1;
                                match browser_manager.capture_screenshot_with_url().await {
                                    Ok((paths, url)) => {
                                        if let Some(first_path) = paths.first() {
                                            tracing::info!(
                                                "Initial CDP screenshot captured: {}",
                                                first_path.display()
                                            );
                                            if let Ok(mut latest) = latest_screenshot_bg.lock() {
                                                *latest = Some((
                                                    first_path.clone(),
                                                    url.clone()
                                                        .unwrap_or_else(|| "Chrome".to_string()),
                                                ));
                                            }
                                            use code_core::protocol::BrowserScreenshotUpdateEvent;
                                            use code_core::protocol::Event;
                                            use code_core::protocol::EventMsg;
                                            let _ =
                                                app_event_tx_bg.send(AppEvent::CodexEvent(Event {
                                                    id: uuid::Uuid::new_v4().to_string(),
                                                    event_seq: 0,
                                                    msg: EventMsg::BrowserScreenshotUpdate(
                                                        BrowserScreenshotUpdateEvent {
                                                            screenshot_path: first_path.clone(),
                                                            url: url.unwrap_or_else(|| {
                                                                "Chrome".to_string()
                                                            }),
                                                        },
                                                    ),
                                                    order: None,
                                                }));
                                            break;
                                        }
                                    }
                                    Err(e) => {
                                        tracing::warn!(
                                            "Failed to capture initial CDP screenshot (attempt {}): {}",
                                            attempt,
                                            e
                                        );
                                        if attempt >= max_attempts {
                                            break;
                                        }
                                        tokio::time::sleep(tokio::time::Duration::from_millis(250))
                                            .await;
                                    }
                                }
                            }
                        });
                    }
                }
                Err(e) => {
                    let err_msg = format!("{}", e);
                    // If we attempted via a cached WS, clear it and fallback to port-based discovery once.
                    if attempted_via_cached_ws {
                        tracing::warn!(
                            "[cdp] cached WS connect failed: {} — clearing WS cache and retrying via port discovery",
                            err_msg
                        );
                        let port_to_keep = cached_port_for_fallback;
                        // Clear WS in-memory and on-disk
                        code_browser::global::set_last_connection(port_to_keep, None).await;
                        let _ = write_cached_connection(port_to_keep, None).await;

                        // Reconfigure to use port (prefer cached port, else auto-detect)
                        {
                            let mut cfg = browser_manager.config.write().await;
                            cfg.connect_ws = None;
                            cfg.connect_port = Some(port_to_keep.unwrap_or(0));
                        }

                        tracing::info!(
                            "[cdp] retrying connect via port discovery after WS failure…"
                        );
                        let retry_deadline = tokio::time::Duration::from_secs(20);
                        let retry = tokio::time::timeout(
                            retry_deadline,
                            browser_manager.connect_to_chrome_only(),
                        )
                        .await;
                        match retry {
                            Ok(Ok(_)) => {
                                tracing::info!(
                                    "[cdp] Fallback connect succeeded after clearing cached WS"
                                );
                                // Emit success event and set up callbacks, mirroring the success path above
                                let (detected_port, detected_ws) =
                                    code_browser::global::get_last_connection().await;
                                let mut port_num: Option<u16> = detected_port;
                                if port_num.is_none() {
                                    if let Some(ws) = &detected_ws {
                                        if let Some(after_scheme) = ws.split("//").nth(1) {
                                            if let Some(hostport) = after_scheme.split('/').next() {
                                                if let Some(pstr) = hostport.split(':').nth(1) {
                                                    if let Ok(p) = pstr.parse::<u16>() {
                                                        port_num = Some(p);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                let current_url = browser_manager.get_current_url().await;
                                let success_msg = match (port_num, current_url) {
                                    (Some(p), Some(url)) if !url.is_empty() => {
                                        format!(
                                            "✅ Connected to Chrome via CDP (port {}) to {}",
                                            p, url
                                        )
                                    }
                                    (Some(p), _) => {
                                        format!("✅ Connected to Chrome via CDP (port {})", p)
                                    }
                                    (None, Some(url)) if !url.is_empty() => {
                                        format!("✅ Connected to Chrome via CDP to {}", url)
                                    }
                                    _ => "✅ Connected to Chrome via CDP".to_string(),
                                };
                                app_event_tx
                                    .send_background_event_with_ticket(&ticket, success_msg);

                                // Persist last connection cache
                                tokio::spawn(async move {
                                    let (p, ws) =
                                        code_browser::global::get_last_connection().await;
                                    let _ = write_cached_connection(p, ws).await;
                                });

                                // Navigation callback
                                let latest_screenshot_callback = latest_screenshot.clone();
                                let app_event_tx_callback = app_event_tx.clone();
                                browser_manager
                                    .set_navigation_callback(move |url| {
                                        tracing::info!("CDP Navigation callback triggered for URL: {}", url);
                                        let latest_screenshot_inner = latest_screenshot_callback.clone();
                                        let app_event_tx_inner = app_event_tx_callback.clone();
                                        let url_inner = url.clone();
                                        tokio::spawn(async move {
                                            tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                            let browser_manager_inner = ChatWidget::get_browser_manager().await;
                                            let mut attempt = 0;
                                            let max_attempts = 2;
                                            loop {
                                                attempt += 1;
                                                match browser_manager_inner.capture_screenshot_with_url().await {
                                                    Ok((paths, _)) => {
                                                        if let Some(first_path) = paths.first() {
                                                            tracing::info!("[cdp] auto-captured screenshot: {}", first_path.display());
                                                            if let Ok(mut latest) = latest_screenshot_inner.lock() {
                                                                *latest = Some((first_path.clone(), url_inner.clone()));
                                                            }
                                                            use code_core::protocol::{BrowserScreenshotUpdateEvent, Event, EventMsg};
                                                            let _ = app_event_tx_inner.send(AppEvent::CodexEvent(Event {
                                                                id: uuid::Uuid::new_v4().to_string(),
                                                                event_seq: 0,
                                                                msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                                    screenshot_path: first_path.clone(),
                                                                    url: url_inner,
                                                                }),
                                                                order: None,
                                                            }));
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        tracing::warn!("[cdp] auto-capture failed (attempt {}): {}", attempt, e);
                                                        if attempt >= max_attempts { break; }
                                                        tokio::time::sleep(tokio::time::Duration::from_millis(250)).await;
                                                    }
                                                }
                                            }
                                        });
                                    })
                                    .await;
                                // Set as global manager like success path
                                code_browser::global::set_global_browser_manager(
                                    browser_manager.clone(),
                                )
                                .await;

                                // Initial screenshot in background (best-effort)
                                {
                                    let latest_screenshot_bg = latest_screenshot.clone();
                                    let app_event_tx_bg = app_event_tx.clone();
                                    tokio::spawn(async move {
                                        tokio::time::sleep(tokio::time::Duration::from_millis(250))
                                            .await;
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        let mut attempt = 0;
                                        let max_attempts = 2;
                                        loop {
                                            attempt += 1;
                                            match browser_manager
                                                .capture_screenshot_with_url()
                                                .await
                                            {
                                                Ok((paths, url)) => {
                                                    if let Some(first_path) = paths.first() {
                                                        tracing::info!(
                                                            "Initial CDP screenshot captured: {}",
                                                            first_path.display()
                                                        );
                                                        if let Ok(mut latest) =
                                                            latest_screenshot_bg.lock()
                                                        {
                                                            *latest = Some((
                                                                first_path.clone(),
                                                                url.clone().unwrap_or_else(|| {
                                                                    "Chrome".to_string()
                                                                }),
                                                            ));
                                                        }
                                                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                                                        use code_core::protocol::Event;
                                                        use code_core::protocol::EventMsg;
                                                        let _ = app_event_tx_bg.send(AppEvent::CodexEvent(Event {
                                                            id: uuid::Uuid::new_v4().to_string(),
                                                            event_seq: 0,
                                                            msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url.unwrap_or_else(|| "Chrome".to_string()),
                                                            }),
                                                            order: None,
                                                        }));
                                                        break;
                                                    }
                                                }
                                                Err(e) => {
                                                    tracing::warn!(
                                                        "Failed to capture initial CDP screenshot (attempt {}): {}",
                                                        attempt,
                                                        e
                                                    );
                                                    if attempt >= max_attempts {
                                                        break;
                                                    }
                                                    tokio::time::sleep(
                                                        tokio::time::Duration::from_millis(250),
                                                    )
                                                    .await;
                                                }
                                            }
                                        }
                                    });
                                }
                                return;
                            }
                            Ok(Err(e2)) => {
                                tracing::error!("[cdp] Fallback connect failed: {}", e2);
                                app_event_tx.send_background_event_with_ticket(
                                    &ticket,
                                    format!(
                                        "❌ Failed to connect to Chrome after WS fallback: {} (original: {})",
                                        e2, err_msg
                                    ),
                                );
                                // Also surface the Chrome launch options UI to assist the user
                                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                                return;
                            }
                            Err(_) => {
                                tracing::error!(
                                    "[cdp] Fallback connect timed out after {:?}",
                                    retry_deadline
                                );
                                app_event_tx.send_background_event_with_ticket(
                                    &ticket,
                                    format!(
                                        "❌ CDP connect timed out after {}s during fallback. Ensure Chrome is running with --remote-debugging-port and /json/version is reachable",
                                        retry_deadline.as_secs()
                                    ),
                                );
                                // Also surface the Chrome launch options UI to assist the user
                                app_event_tx.send(AppEvent::ShowChromeOptions(port));
                                return;
                            }
                        }
                    } else {
                        tracing::error!(
                            "[cdp] connect_to_chrome_only failed immediately: {}",
                            err_msg
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to connect to Chrome: {}", err_msg),
                        );
                        // Offer launch options popup to help recover quickly
                        app_event_tx.send(AppEvent::ShowChromeOptions(port));
                        return;
                    }
                }
            },
        }
    }

    fn launch_chrome_with_temp_profile(&mut self, port: u16) {
        use std::process::Stdio;

        let temp_dir = std::env::temp_dir();
        let profile_dir = temp_dir.join(format!("code-chrome-temp-{}", port));
        let log_path = self.chrome_log_path();

        #[cfg(target_os = "macos")]
        {
            let mut cmd = std::process::Command::new(
                "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
            );
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg(format!("--user-data-dir={}", profile_dir.display()))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            self.apply_chrome_logging(&mut cmd, log_path.as_deref());
            if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                tracing::warn!("failed to launch Chrome with temp profile: {err}");
            }
        }

        #[cfg(target_os = "linux")]
        {
            let mut cmd = std::process::Command::new("google-chrome");
            cmd.arg(format!("--remote-debugging-port={}", port))
                .arg(format!("--user-data-dir={}", profile_dir.display()))
                .arg("--no-first-run")
                .arg("--no-default-browser-check")
                .arg("--disable-component-extensions-with-background-pages")
                .arg("--disable-background-networking")
                .arg("--silent-debugger-extension-api")
                .arg("--remote-allow-origins=*")
                .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                .arg("--disable-hang-monitor")
                .arg("--disable-background-timer-throttling")
                .stdout(Stdio::null())
                .stderr(Stdio::null())
                .stdin(Stdio::null());
            self.apply_chrome_logging(&mut cmd, log_path.as_deref());
            if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                tracing::warn!("failed to launch Chrome with temp profile: {err}");
            }
        }

        #[cfg(target_os = "windows")]
        {
            let chrome_paths = vec![
                "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                "C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe".to_string(),
                format!(
                    "{}\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe",
                    std::env::var("USERPROFILE").unwrap_or_default()
                ),
            ];

            for chrome_path in chrome_paths {
                if std::path::Path::new(&chrome_path).exists() {
                    let mut cmd = std::process::Command::new(&chrome_path);
                    cmd.arg(format!("--remote-debugging-port={}", port))
                        .arg(format!("--user-data-dir={}", profile_dir.display()))
                        .arg("--no-first-run")
                        .arg("--no-default-browser-check")
                        .arg("--disable-component-extensions-with-background-pages")
                        .arg("--disable-background-networking")
                        .arg("--silent-debugger-extension-api")
                        .arg("--remote-allow-origins=*")
                        .arg("--disable-features=ChromeWhatsNewUI,TriggerFirstRunUI")
                        .arg("--disable-hang-monitor")
                        .arg("--disable-background-timer-throttling")
                        .stdout(Stdio::null())
                        .stderr(Stdio::null())
                        .stdin(Stdio::null());
                    self.apply_chrome_logging(&mut cmd, log_path.as_deref());
                    if let Err(err) = spawn_std_command_with_retry(&mut cmd) {
                        tracing::warn!("failed to launch Chrome with temp profile: {err}");
                    }
                    break;
                }
            }
        }

        // Add status message
        self.push_background_tail(format!(
            "✅ Chrome launched with temporary profile at {}",
            profile_dir.display()
        ));
    }

    fn schedule_browser_autofix(
        app_event_tx: AppEventSender,
        ticket: BackgroundOrderTicket,
        autofix_state: Arc<AtomicBool>,
        failure_context: &str,
        raw_error: String,
    ) {
        if autofix_state
            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
            .is_err()
        {
            tracing::info!(
                "[/browser] auto-handoff already requested; skipping duplicate dispatch"
            );
            return;
        }

        let sanitized = raw_error.replace('\n', " ").replace('\r', " ");
        let trimmed = sanitized.trim();
        let truncated = if trimmed.len() > 220 {
            let mut shortened = trimmed.chars().take(220).collect::<String>();
            shortened.push('…');
            shortened
        } else {
            trimmed.to_string()
        };

        tracing::info!(
            "[/browser] scheduling Code autofix for context='{}', error='{}'",
            failure_context,
            truncated
        );

        let visible_message = format!(
            "🤖 Handing /browser failure ({}) to Code. Error: {}",
            failure_context,
            truncated
        );
        app_event_tx.send_background_event_with_ticket(&ticket, visible_message);

        let command_text = format!(
            "/code The /browser command failed to {context}. Recent error: {error}. Please diagnose and fix the environment (for example, install or configure Chrome) so /browser works in this workspace.",
            context = failure_context,
            error = truncated
        );
        app_event_tx.send(AppEvent::DispatchCommand(
            SlashCommand::Code,
            command_text,
        ));
    }

    pub(crate) fn handle_browser_command(&mut self, command_text: String) {
        // Parse the browser subcommand
        let trimmed = command_text.trim();
        let browser_ticket = self.make_background_tail_ticket();
        self.consume_pending_prompt_for_ui_only_turn();

        // Handle the case where just "/browser" was typed
        if trimmed.is_empty() {
            tracing::info!("[/browser] toggling internal browser on/off");

            // Optimistically reflect browsing activity in the input border if we end up enabling
            // (safe even if we later disable; UI will update on event messages)
            self.bottom_pane
                .update_status_text("using browser".to_string());

            // Toggle asynchronously: if internal browser is active, disable it; otherwise enable and open about:blank
            let app_event_tx = self.app_event_tx.clone();
            let browser_autofix_flag = self.browser_autofix_requested.clone();
            let ticket = browser_ticket.clone();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                // Determine if internal browser is currently active
                let (is_external, status) = {
                    let cfg = browser_manager.config.read().await;
                    let is_external = cfg.connect_port.is_some() || cfg.connect_ws.is_some();
                    drop(cfg);
                    (is_external, browser_manager.get_status().await)
                };

                if !is_external && status.browser_active {
                    // Internal browser active → disable it
                    if let Err(e) = browser_manager.set_enabled(false).await {
                        tracing::warn!("[/browser] failed to disable internal browser: {}", e);
                    }
                    app_event_tx
                        .send_background_event_with_ticket(&ticket, "🔌 Browser disabled".to_string());
                } else {
                    // Not in internal mode → enable internal and open about:blank
                    // Reuse existing helper (ensures config + start + global manager + screenshot)
                    // Then explicitly navigate to about:blank
                    // We fire-and-forget errors to avoid blocking UI
                    {
                        // Configure cleanly for internal mode
                        let mut cfg = browser_manager.config.write().await;
                        cfg.connect_port = None;
                        cfg.connect_ws = None;
                        cfg.enabled = true;
                        cfg.persist_profile = false;
                        cfg.headless = true;
                    }

                    if let Err(e) = browser_manager.start().await {
                        let error_text = e.to_string();
                        tracing::error!(
                            "[/browser] failed to start internal browser: {}",
                            error_text
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to start internal browser: {}", error_text),
                        );
                        ChatWidget::schedule_browser_autofix(
                            app_event_tx.clone(),
                            ticket.clone(),
                            browser_autofix_flag.clone(),
                            "start the internal browser",
                            error_text,
                        );
                        return;
                    }

                    browser_autofix_flag.store(false, Ordering::SeqCst);

                    // Set as global manager so core/session share the same instance
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Navigate to about:blank explicitly
                    if let Err(e) = browser_manager.goto("about:blank").await {
                        tracing::warn!("[/browser] failed to open about:blank: {}", e);
                    }

                    // Emit confirmation
                    app_event_tx
                        .send_background_event_with_ticket(
                            &ticket,
                            "✅ Browser enabled (about:blank)".to_string(),
                        );
                }
            });
            return;
        }

        let parts: Vec<&str> = trimmed.split_whitespace().collect();
        let response = if !parts.is_empty() {
            let first_arg = parts[0];

            // Check if the first argument looks like a URL (has a dot or protocol)
            let is_url = first_arg.contains("://") || first_arg.contains(".");

            if is_url {
                // It's a URL - enable browser mode and navigate to it
                let url = parts.join(" ");

                // Ensure URL has protocol
                let full_url = if !url.contains("://") {
                    format!("https://{}", url)
                } else {
                    url.clone()
                };

                // We are navigating with the internal browser
                self.browser_is_external = false;

                // Navigate to URL and wait for it to load
                let latest_screenshot = self.latest_browser_screenshot.clone();
                let app_event_tx = self.app_event_tx.clone();
                let browser_autofix_flag = self.browser_autofix_requested.clone();
                let url_for_goto = full_url.clone();
                let ticket = browser_ticket.clone();

                // Add status message
                let status_msg = format!("🌐 Opening internal browser: {}", full_url);
                self.push_background_tail(status_msg);
                // Also reflect browsing activity in the input border
                self.bottom_pane
                    .update_status_text("using browser".to_string());

                // Connect immediately, don't wait for message send
                tokio::spawn(async move {
                    // Get the global browser manager
                    let browser_manager = ChatWidget::get_browser_manager().await;

                    // Enable browser mode and ensure it's using internal browser (not CDP)
                    browser_manager.set_enabled_sync(true);
                    {
                        let mut config = browser_manager.config.write().await;
                        config.headless = false; // Ensure browser is visible when navigating to URL
                        config.connect_port = None; // Ensure we're not trying to connect to CDP
                        config.connect_ws = None; // Ensure we're not trying to connect via WebSocket
                    }

                    // IMPORTANT: Start the browser manager first before navigating
                    if let Err(e) = browser_manager.start().await {
                        let error_text = e.to_string();
                        tracing::error!(
                            "Failed to start TUI browser manager: {}",
                            error_text
                        );
                        app_event_tx.send_background_event_with_ticket(
                            &ticket,
                            format!("❌ Failed to start internal browser: {}", error_text),
                        );
                        ChatWidget::schedule_browser_autofix(
                            app_event_tx.clone(),
                            ticket.clone(),
                            browser_autofix_flag.clone(),
                            "launch the internal browser",
                            error_text,
                        );
                        return;
                    }

                    browser_autofix_flag.store(false, Ordering::SeqCst);

                    // Set up navigation callback to auto-capture screenshots
                    {
                        let latest_screenshot_callback = latest_screenshot.clone();
                        let app_event_tx_callback = app_event_tx.clone();

                        browser_manager
                            .set_navigation_callback(move |url| {
                                tracing::info!("Navigation callback triggered for URL: {}", url);
                                let latest_screenshot_inner = latest_screenshot_callback.clone();
                                let app_event_tx_inner = app_event_tx_callback.clone();
                                let url_inner = url.clone();

                                tokio::spawn(async move {
                                    // Get browser manager in the inner async block
                                    let browser_manager_inner =
                                        ChatWidget::get_browser_manager().await;
                                    // Capture screenshot after navigation
                                    match browser_manager_inner.capture_screenshot_with_url().await
                                    {
                                        Ok((paths, _)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!(
                                                    "Auto-captured screenshot after navigation: {}",
                                                    first_path.display()
                                                );

                                                // Update the latest screenshot
                                                if let Ok(mut latest) =
                                                    latest_screenshot_inner.lock()
                                                {
                                                    *latest = Some((
                                                        first_path.clone(),
                                                        url_inner.clone(),
                                                    ));
                                                }

                                                // Send update event
                                                use code_core::protocol::{
                                                    BrowserScreenshotUpdateEvent, EventMsg,
                                                };
                                                let _ = app_event_tx_inner.send(
                                                    AppEvent::CodexEvent(Event {
                                                        id: uuid::Uuid::new_v4().to_string(),
                                                        event_seq: 0,
                                                        msg: EventMsg::BrowserScreenshotUpdate(
                                                            BrowserScreenshotUpdateEvent {
                                                                screenshot_path: first_path.clone(),
                                                                url: url_inner,
                                                            },
                                                        ),
                                                        order: None,
                                                    }),
                                                );
                                            }
                                        }
                                        Err(e) => {
                                            tracing::error!(
                                                "Failed to auto-capture screenshot: {}",
                                                e
                                            );
                                        }
                                    }
                                });
                            })
                            .await;
                    }

                    // Set the browser manager as the global manager so both TUI and Session use the same instance
                    code_browser::global::set_global_browser_manager(browser_manager.clone())
                        .await;

                    // Ensure the navigation callback is also set on the global manager
                    let global_manager = code_browser::global::get_browser_manager().await;
                    if let Some(global_manager) = global_manager {
                        let latest_screenshot_global = latest_screenshot.clone();
                        let app_event_tx_global = app_event_tx.clone();

                        global_manager.set_navigation_callback(move |url| {
                            tracing::info!("Global manager navigation callback triggered for URL: {}", url);
                            let latest_screenshot_inner = latest_screenshot_global.clone();
                            let app_event_tx_inner = app_event_tx_global.clone();
                            let url_inner = url.clone();

                            tokio::spawn(async move {
                                // Wait a moment for the navigation to complete
                                tokio::time::sleep(tokio::time::Duration::from_millis(1000)).await;

                                // Capture screenshot after navigation
                                let browser_manager = code_browser::global::get_browser_manager().await;
                                if let Some(browser_manager) = browser_manager {
                                    match browser_manager.capture_screenshot_with_url().await {
                                        Ok((paths, _url)) => {
                                            if let Some(first_path) = paths.first() {
                                                tracing::info!("Auto-captured screenshot after global navigation: {}", first_path.display());

                                                // Update the latest screenshot
                                                if let Ok(mut latest) = latest_screenshot_inner.lock() {
                                                    *latest = Some((first_path.clone(), url_inner.clone()));
                                                }

                                                // Send update event
                                                use code_core::protocol::{BrowserScreenshotUpdateEvent, EventMsg};
                                                let _ = app_event_tx_inner.send(AppEvent::CodexEvent(Event { id: uuid::Uuid::new_v4().to_string(), event_seq: 0, msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                                        screenshot_path: first_path.clone(),
                                                        url: url_inner,
                                                    }), order: None }));
                                            }
                                        }
                                        Err(e) => {
                                            tracing::error!("Failed to auto-capture screenshot after global navigation: {}", e);
                                        }
                                    }
                                }
                            });
                        }).await;
                    }

                    // Navigate using global manager
                    match browser_manager.goto(&url_for_goto).await {
                        Ok(result) => {
                            tracing::info!(
                                "Browser opened to: {} (title: {:?})",
                                result.url,
                                result.title
                            );

                            // Send success message to chat
                            app_event_tx.send_background_event_with_ticket(
                                &ticket,
                                format!("✅ Internal browser opened: {}", result.url),
                            );

                            // Capture initial screenshot
                            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
                            match browser_manager.capture_screenshot_with_url().await {
                                Ok((paths, url)) => {
                                    if let Some(first_path) = paths.first() {
                                        tracing::info!(
                                            "Initial screenshot captured: {}",
                                            first_path.display()
                                        );

                                        // Update the latest screenshot
                                        if let Ok(mut latest) = latest_screenshot.lock() {
                                            *latest = Some((
                                                first_path.clone(),
                                                url.clone().unwrap_or_else(|| result.url.clone()),
                                            ));
                                        }

                                        // Send update event
                                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                                        use code_core::protocol::EventMsg;
                                        let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                                            id: uuid::Uuid::new_v4().to_string(),
                                            event_seq: 0,
                                            msg: EventMsg::BrowserScreenshotUpdate(
                                                BrowserScreenshotUpdateEvent {
                                                    screenshot_path: first_path.clone(),
                                                    url: url.unwrap_or_else(|| result.url.clone()),
                                                },
                                            ),
                                            order: None,
                                        }));
                                    }
                                }
                                Err(e) => {
                                    tracing::error!("Failed to capture initial screenshot: {}", e);
                                }
                            }
                        }
                        Err(e) => {
                            tracing::error!("Failed to open browser: {}", e);
                        }
                    }
                });

                format!("Browser mode enabled: {}\n", full_url)
            } else {
                // It's a subcommand
                match first_arg {
                    "off" => {
                        // Disable browser mode
                        // Clear the screenshot popup
                        if let Ok(mut screenshot_lock) = self.latest_browser_screenshot.lock() {
                            *screenshot_lock = None;
                        }
                        // Close any open browser
                        tokio::spawn(async move {
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            browser_manager.set_enabled_sync(false);
                            if let Err(e) = browser_manager.close().await {
                                tracing::error!("Failed to close browser: {}", e);
                            }
                        });
                        self.app_event_tx.send(AppEvent::RequestRedraw);
                        "Browser mode disabled.".to_string()
                    }
                    "status" => {
                        // Get status from BrowserManager
                        // Use a channel to get status from async context
                        let (status_tx, status_rx) = std::sync::mpsc::channel();
                        tokio::spawn(async move {
                            let browser_manager = ChatWidget::get_browser_manager().await;
                            let status = browser_manager.get_status_sync();
                            let _ = status_tx.send(status);
                        });
                        status_rx
                            .recv()
                            .unwrap_or_else(|_| "Failed to get browser status.".to_string())
                    }
                    "fullpage" => {
                        if parts.len() > 2 {
                            match parts[2] {
                                "on" => {
                                    // Enable full-page mode
                                    tokio::spawn(async move {
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        browser_manager.set_fullpage_sync(true);
                                    });
                                    "Full-page screenshot mode enabled (max 8 segments)."
                                        .to_string()
                                }
                                "off" => {
                                    // Disable full-page mode
                                    tokio::spawn(async move {
                                        let browser_manager =
                                            ChatWidget::get_browser_manager().await;
                                        browser_manager.set_fullpage_sync(false);
                                    });
                                    "Full-page screenshot mode disabled.".to_string()
                                }
                                _ => "Usage: /browser fullpage [on|off]".to_string(),
                            }
                        } else {
                            "Usage: /browser fullpage [on|off]".to_string()
                        }
                    }
                    "config" => {
                        if parts.len() > 3 {
                            let key = parts[2];
                            let value = parts[3..].join(" ");
                            // Update browser config
                            match key {
                                "viewport" => {
                                    // Parse viewport dimensions like "1920x1080"
                                    if let Some((width_str, height_str)) = value.split_once('x') {
                                        if let (Ok(width), Ok(height)) =
                                            (width_str.parse::<u32>(), height_str.parse::<u32>())
                                        {
                                            tokio::spawn(async move {
                                                let browser_manager =
                                                    ChatWidget::get_browser_manager().await;
                                                browser_manager.set_viewport_sync(width, height);
                                            });
                                            format!(
                                                "Browser viewport updated: {}x{}",
                                                width, height
                                            )
                                        } else {
                                            "Invalid viewport format. Use: /browser config viewport 1920x1080".to_string()
                                        }
                                    } else {
                                        "Invalid viewport format. Use: /browser config viewport 1920x1080".to_string()
                                    }
                                }
                                "segments_max" => {
                                    if let Ok(max) = value.parse::<usize>() {
                                        tokio::spawn(async move {
                                            let browser_manager =
                                                ChatWidget::get_browser_manager().await;
                                            browser_manager.set_segments_max_sync(max);
                                        });
                                        format!("Browser segments_max updated: {}", max)
                                    } else {
                                        "Invalid segments_max value. Use a number.".to_string()
                                    }
                                }
                                _ => format!(
                                    "Unknown config key: {}. Available: viewport, segments_max",
                                    key
                                ),
                            }
                        } else {
                            "Usage: /browser config <key> <value>\nAvailable keys: viewport, segments_max".to_string()
                        }
                    }
                    _ => {
                        format!(
                            "Unknown browser command: '{}'\nUsage: /browser <url> | off | status | fullpage | config",
                            first_arg
                        )
                    }
                }
            }
        } else {
            "Browser commands:\n• /browser <url> - Open URL in internal browser\n• /browser off - Disable browser mode\n• /browser status - Show current status\n• /browser fullpage [on|off] - Toggle full-page mode\n• /browser config <key> <value> - Update configuration\n\nUse /chrome [port] to connect to external Chrome browser".to_string()
        };

        // Add the response to the UI as a ticketed background event so it stays with
        // the originating slash command turn.
        self.app_event_tx
            .send_background_event_with_ticket(&browser_ticket, response);
    }

    fn validation_tool_flag_mut(
        &mut self,
        name: &str,
    ) -> Option<&mut Option<bool>> {
        let tools = &mut self.config.validation.tools;
        match name {
            "shellcheck" => Some(&mut tools.shellcheck),
            "markdownlint" => Some(&mut tools.markdownlint),
            "hadolint" => Some(&mut tools.hadolint),
            "yamllint" => Some(&mut tools.yamllint),
            "cargo-check" => Some(&mut tools.cargo_check),
            "shfmt" => Some(&mut tools.shfmt),
            "prettier" => Some(&mut tools.prettier),
            "tsc" => Some(&mut tools.tsc),
            "eslint" => Some(&mut tools.eslint),
            "phpstan" => Some(&mut tools.phpstan),
            "psalm" => Some(&mut tools.psalm),
            "mypy" => Some(&mut tools.mypy),
            "pyright" => Some(&mut tools.pyright),
            "golangci-lint" => Some(&mut tools.golangci_lint),
            _ => None,
        }
    }

    fn validation_group_label(group: ValidationGroup) -> &'static str {
        match group {
            ValidationGroup::Functional => "Functional checks",
            ValidationGroup::Stylistic => "Stylistic checks",
        }
    }

    fn validation_group_enabled(&self, group: ValidationGroup) -> bool {
        match group {
            ValidationGroup::Functional => self.config.validation.groups.functional,
            ValidationGroup::Stylistic => self.config.validation.groups.stylistic,
        }
    }

    fn validation_tool_requested(&self, name: &str) -> bool {
        let tools = &self.config.validation.tools;
        match name {
            "actionlint" => self.config.github.actionlint_on_patch,
            "shellcheck" => tools.shellcheck.unwrap_or(true),
            "markdownlint" => tools.markdownlint.unwrap_or(true),
            "hadolint" => tools.hadolint.unwrap_or(true),
            "yamllint" => tools.yamllint.unwrap_or(true),
            "cargo-check" => tools.cargo_check.unwrap_or(true),
            "shfmt" => tools.shfmt.unwrap_or(true),
            "prettier" => tools.prettier.unwrap_or(true),
            "tsc" => tools.tsc.unwrap_or(true),
            "eslint" => tools.eslint.unwrap_or(true),
            "phpstan" => tools.phpstan.unwrap_or(true),
            "psalm" => tools.psalm.unwrap_or(true),
            "mypy" => tools.mypy.unwrap_or(true),
            "pyright" => tools.pyright.unwrap_or(true),
            "golangci-lint" => tools.golangci_lint.unwrap_or(true),
            _ => true,
        }
    }

    fn validation_tool_enabled(&self, name: &str) -> bool {
        let requested = self.validation_tool_requested(name);
        let category = validation_tool_category(name);
        let group_enabled = match category {
            ValidationCategory::Functional => self.config.validation.groups.functional,
            ValidationCategory::Stylistic => self.config.validation.groups.stylistic,
        };
        requested && group_enabled
    }

    fn apply_validation_group_toggle(&mut self, group: ValidationGroup, enable: bool) {
        if self.validation_group_enabled(group) == enable {
            return;
        }

        match group {
            ValidationGroup::Functional => self.config.validation.groups.functional = enable,
            ValidationGroup::Stylistic => self.config.validation.groups.stylistic = enable,
        }

        if let Err(err) = self
            .code_op_tx
            .send(Op::UpdateValidationGroup { group, enable })
        {
            tracing::warn!("failed to send validation group update: {err}");
        }

        let result = match find_code_home() {
            Ok(home) => {
                let key = match group {
                    ValidationGroup::Functional => "functional",
                    ValidationGroup::Stylistic => "stylistic",
                };
                set_validation_group_enabled(&home, key, enable).map_err(|e| e.to_string())
            }
            Err(err) => Err(err.to_string()),
        };

        let label = Self::validation_group_label(group);
        if let Err(err) = result {
            self.push_background_tail(format!(
                "⚠️ {} {} (persist failed: {err})",
                label,
                if enable { "enabled" } else { "disabled" }
            ));
        }

        self.refresh_settings_overview_rows();
    }

    fn apply_validation_tool_toggle(&mut self, name: &str, enable: bool) {
        if name == "actionlint" {
            if self.config.github.actionlint_on_patch == enable {
                return;
            }
            self.config.github.actionlint_on_patch = enable;
            if let Err(err) = self
                .code_op_tx
                .send(Op::UpdateValidationTool { name: name.to_string(), enable })
            {
                tracing::warn!("failed to send validation tool update: {err}");
            }
            let persist_result = match find_code_home() {
                Ok(home) => set_github_actionlint_on_patch(&home, enable)
                    .map_err(|e| e.to_string()),
                Err(err) => Err(err.to_string()),
            };
            if let Err(err) = persist_result {
                self.push_background_tail(format!(
                    "⚠️ {}: {} (persist failed: {err})",
                    name,
                    if enable { "enabled" } else { "disabled" }
                ));
            }
            return;
        }

        let Some(flag) = self.validation_tool_flag_mut(name) else {
            self.push_background_tail(format!(
                "⚠️ Unknown validation tool '{name}'"
            ));
            return;
        };

        if flag.unwrap_or(true) == enable {
            return;
        }

        *flag = Some(enable);
        if let Err(err) = self
            .code_op_tx
            .send(Op::UpdateValidationTool { name: name.to_string(), enable })
        {
            tracing::warn!("failed to send validation tool update: {err}");
        }
        let persist_result = match find_code_home() {
            Ok(home) => set_validation_tool_enabled(&home, name, enable)
                .map_err(|e| e.to_string()),
            Err(err) => Err(err.to_string()),
        };
        if let Err(err) = persist_result {
            self.push_background_tail(format!(
                "⚠️ {}: {} (persist failed: {err})",
                name,
                if enable { "enabled" } else { "disabled" }
            ));
        }

        self.refresh_settings_overview_rows();
    }

    fn build_validation_status_message(&self) -> String {
        let mut lines = Vec::new();
        lines.push("Validation groups:".to_string());
        for group in [ValidationGroup::Functional, ValidationGroup::Stylistic] {
            let enabled = self.validation_group_enabled(group);
            lines.push(format!(
                "• {} — {}",
                Self::validation_group_label(group),
                if enabled { "enabled" } else { "disabled" }
            ));
        }
        lines.push("".to_string());
        lines.push("Tools:".to_string());
        for status in validation_settings_view::detect_tools() {
            let requested = self.validation_tool_requested(status.name);
            let effective = self.validation_tool_enabled(status.name);
            let mut state = if requested {
                if effective { "enabled".to_string() } else { "disabled (group off)".to_string() }
            } else {
                "disabled".to_string()
            };
            if !status.installed {
                state.push_str(" (not installed)");
            }
            lines.push(format!("• {} — {}", status.name, state));
        }
        lines.join("\n")
    }

    pub(crate) fn toggle_validation_tool(&mut self, name: &str, enable: bool) {
        self.apply_validation_tool_toggle(name, enable);
    }

    pub(crate) fn toggle_validation_group(&mut self, group: ValidationGroup, enable: bool) {
        self.apply_validation_group_toggle(group, enable);
    }

    pub(crate) fn handle_validation_command(&mut self, command_text: String) {
        let trimmed = command_text.trim();
        if trimmed.is_empty() {
            self.ensure_validation_settings_overlay();
            return;
        }

        let mut parts = trimmed.split_whitespace();
        match parts.next().unwrap_or("") {
            "status" => {
                let message = self.build_validation_status_message();
                self.push_background_tail(message);
            }
            "on" => {
                if !self.validation_group_enabled(ValidationGroup::Functional) {
                    self.apply_validation_group_toggle(ValidationGroup::Functional, true);
                }
            }
            "off" => {
                if self.validation_group_enabled(ValidationGroup::Functional) {
                    self.apply_validation_group_toggle(ValidationGroup::Functional, false);
                }
                if self.validation_group_enabled(ValidationGroup::Stylistic) {
                    self.apply_validation_group_toggle(ValidationGroup::Stylistic, false);
                }
            }
            group @ ("functional" | "stylistic") => {
                let Some(state) = parts.next() else {
                    self.push_background_tail("Usage: /validation <tool|group> on|off".to_string());
                    return;
                };
                let group = if group == "functional" {
                    ValidationGroup::Functional
                } else {
                    ValidationGroup::Stylistic
                };
                match state {
                    "on" | "enable" => self.apply_validation_group_toggle(group, true),
                    "off" | "disable" => self.apply_validation_group_toggle(group, false),
                    _ => self.push_background_tail(format!(
                        "⚠️ Unknown validation command '{}'. Use on|off.",
                        state
                    )),
                }
            }
            tool => {
                let Some(state) = parts.next() else {
                    self.push_background_tail("Usage: /validation <tool|group> on|off".to_string());
                    return;
                };
                match state {
                    "on" | "enable" => self.apply_validation_tool_toggle(tool, true),
                    "off" | "disable" => self.apply_validation_tool_toggle(tool, false),
                    _ => self.push_background_tail(format!(
                        "⚠️ Unknown validation command '{}'. Use on|off.",
                        state
                    )),
                }
            }
        }

        self.ensure_validation_settings_overlay();
    }

    fn format_mcp_summary(cfg: &code_core::config_types::McpServerConfig) -> String {
        use code_core::config_types::McpServerTransportConfig;

        match &cfg.transport {
            McpServerTransportConfig::Stdio { command, args, .. } => {
                if args.is_empty() {
                    command.clone()
                } else {
                    format!("{} {}", command, args.join(" "))
                }
            }
            McpServerTransportConfig::StreamableHttp { url, .. } => format!("HTTP {}", url),
        }
    }

    /// Handle `/mcp` command: manage MCP servers (status/on/off/add).
    pub(crate) fn handle_mcp_command(&mut self, command_text: String) {
        let trimmed = command_text.trim();
        if trimmed.is_empty() {
            self.show_settings_overlay(Some(SettingsSection::Mcp));
            return;
        }

        let mut parts = trimmed.split_whitespace();
        let sub = parts.next().unwrap_or("");

        match sub {
            "status" => match find_code_home() {
                Ok(home) => match code_core::config::list_mcp_servers(&home) {
                    Ok((enabled, disabled)) => {
                        let mut lines = String::new();
                        if enabled.is_empty() && disabled.is_empty() {
                            lines.push_str("No MCP servers configured. Use /mcp add … to add one.");
                        } else {
                            lines.push_str(&format!("Enabled ({}):\n", enabled.len()));
                            for (name, cfg) in enabled {
                                lines.push_str(&format!(
                                    "• {} — {}\n",
                                    name,
                                    Self::format_mcp_summary(&cfg)
                                ));
                            }
                            lines.push_str(&format!("\nDisabled ({}):\n", disabled.len()));
                            for (name, cfg) in disabled {
                                lines.push_str(&format!(
                                    "• {} — {}\n",
                                    name,
                                    Self::format_mcp_summary(&cfg)
                                ));
                            }
                        }
                        self.push_background_tail(lines);
                    }
                    Err(e) => {
                        let msg = format!("Failed to read MCP config: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                },
                Err(e) => {
                    let msg = format!("Failed to locate CODEX_HOME: {}", e);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                }
            },
            "on" | "off" => {
                let name = parts.next().unwrap_or("");
                if name.is_empty() {
                    let msg = format!("Usage: /mcp {} <name>", sub);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }
                match find_code_home() {
                    Ok(home) => {
                        match code_core::config::set_mcp_server_enabled(&home, name, sub == "on") {
                            Ok(changed) => {
                                if changed {
                                    // Keep ChatWidget's in-memory config roughly in sync for new sessions.
                                    if sub == "off" {
                                        self.config.mcp_servers.remove(name);
                                    }
                                    if sub == "on" {
                                        // If enabling, try to load its config from disk and add to in-memory map.
                                        if let Ok((enabled, _)) =
                                            code_core::config::list_mcp_servers(&home)
                                        {
                                            if let Some((_, cfg)) =
                                                enabled.into_iter().find(|(n, _)| n == name)
                                            {
                                                self.config
                                                    .mcp_servers
                                                    .insert(name.to_string(), cfg);
                                            }
                                        }
                                    }
                                    let msg = format!(
                                        "{} MCP server '{}'",
                                        if sub == "on" { "Enabled" } else { "Disabled" },
                                        name
                                    );
                                    self.push_background_tail(msg);
                                } else {
                                    let msg = format!(
                                        "No change: server '{}' was already {}",
                                        name,
                                        if sub == "on" { "enabled" } else { "disabled" }
                                    );
                                    self.push_background_tail(msg);
                                }
                            }
                            Err(e) => {
                                let msg = format!("Failed to update MCP server '{}': {}", name, e);
                                self.history_push_plain_state(history_cell::new_error_event(msg));
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("Failed to locate CODEX_HOME: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            "add" => {
                // Support two forms:
                //   1) /mcp add <name> <command> [args…] [ENV=VAL…]
                //   2) /mcp add <command> [args…] [ENV=VAL…]   (name derived)
                let tail_tokens: Vec<String> = parts.map(|s| s.to_string()).collect();
                if tail_tokens.is_empty() {
                    let msg = "Usage: /mcp add <name> <command> [args…] [ENV=VAL…]\n       or: /mcp add <command> [args…] [ENV=VAL…]".to_string();
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }

                // Helper: derive a reasonable server name from command/args.
                fn derive_server_name(command: &str, tokens: &[String]) -> String {
                    // Prefer an npm-style package token if present.
                    let candidate = tokens
                        .iter()
                        .find(|t| {
                            !t.starts_with('-')
                                && !t.contains('=')
                                && (t.contains('/') || t.starts_with('@'))
                        })
                        .cloned();

                    let mut raw = match candidate {
                        Some(pkg) => {
                            // Strip scope, take the last path segment
                            let after_slash = pkg.rsplit('/').next().unwrap_or(pkg.as_str());
                            // Common convention: server-<name>
                            after_slash
                                .strip_prefix("server-")
                                .unwrap_or(after_slash)
                                .to_string()
                        }
                        None => command.to_string(),
                    };

                    // Sanitize: keep [a-zA-Z0-9_-], map others to '-'
                    raw = raw
                        .chars()
                        .map(|c| {
                            if c.is_ascii_alphanumeric() || c == '_' || c == '-' {
                                c
                            } else {
                                '-'
                            }
                        })
                        .collect();
                    // Collapse multiple '-'
                    let mut out = String::with_capacity(raw.len());
                    let mut prev_dash = false;
                    for ch in raw.chars() {
                        if ch == '-' && prev_dash {
                            continue;
                        }
                        prev_dash = ch == '-';
                        out.push(ch);
                    }
                    // Ensure non-empty; fall back to "server"
                    if out.trim_matches('-').is_empty() {
                        "server".to_string()
                    } else {
                        out.trim_matches('-').to_string()
                    }
                }

                // Parse the two accepted forms
                let (name, command, rest_tokens) = if tail_tokens.len() >= 2 {
                    let first = &tail_tokens[0];
                    let second = &tail_tokens[1];
                    // If the presumed command looks like a flag, assume name was omitted.
                    if second.starts_with('-') {
                        let cmd = first.clone();
                        let name = derive_server_name(&cmd, &tail_tokens[1..].to_vec());
                        (name, cmd, tail_tokens[1..].to_vec())
                    } else {
                        (first.clone(), second.clone(), tail_tokens[2..].to_vec())
                    }
                } else {
                    // Only one token provided — treat it as a command and derive a name.
                    let cmd = tail_tokens[0].clone();
                    let name = derive_server_name(&cmd, &[]);
                    (name, cmd, Vec::new())
                };

                if command.is_empty() {
                    let msg = "Usage: /mcp add <name> <command> [args…] [ENV=VAL…]".to_string();
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                    return;
                }

                // Separate args from ENV=VAL pairs
                let mut args: Vec<String> = Vec::new();
                let mut env: std::collections::HashMap<String, String> =
                    std::collections::HashMap::new();
                for tok in rest_tokens.into_iter() {
                    if let Some((k, v)) = tok.split_once('=') {
                        if !k.is_empty() {
                            env.insert(k.to_string(), v.to_string());
                        }
                    } else {
                        args.push(tok);
                    }
                }
                match find_code_home() {
                    Ok(home) => {
                        let transport = code_core::config_types::McpServerTransportConfig::Stdio {
                            command: command.to_string(),
                            args: args.clone(),
                            env: if env.is_empty() { None } else { Some(env.clone()) },
                        };
                        let cfg = code_core::config_types::McpServerConfig {
                            transport,
                            startup_timeout_sec: None,
                            tool_timeout_sec: None,
                        };
                        match code_core::config::add_mcp_server(&home, &name, cfg.clone()) {
                            Ok(()) => {
                                let summary = Self::format_mcp_summary(&cfg);
                                // Update in-memory config for future sessions
                                self.config.mcp_servers.insert(name.clone(), cfg);
                                let msg = format!("Added MCP server '{}': {}", name, summary);
                                self.push_background_tail(msg);
                            }
                            Err(e) => {
                                let msg = format!("Failed to add MCP server '{}': {}", name, e);
                                self.history_push_plain_state(history_cell::new_error_event(msg));
                            }
                        }
                    }
                    Err(e) => {
                        let msg = format!("Failed to locate CODEX_HOME: {}", e);
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            _ => {
                let msg = format!(
                    "Unknown MCP command: '{}'\nUsage:\n  /mcp status\n  /mcp on <name>\n  /mcp off <name>\n  /mcp add <name> <command> [args…] [ENV=VAL…]",
                    sub
                );
                self.history_push_plain_state(history_cell::new_error_event(msg));
            }
        }
    }

    #[allow(dead_code)]
    fn switch_to_internal_browser(&mut self) {
        // Switch to internal browser mode
        self.browser_is_external = false;
        let latest_screenshot = self.latest_browser_screenshot.clone();
        let app_event_tx = self.app_event_tx.clone();
        let ticket = self.make_background_tail_ticket();

        tokio::spawn(async move {
            let ticket = ticket;
            let browser_manager = ChatWidget::get_browser_manager().await;

            // First, close any existing Chrome connection
            if browser_manager.is_enabled().await {
                let _ = browser_manager.close().await;
            }

            // Configure for internal browser
            {
                let mut config = browser_manager.config.write().await;
                config.connect_port = None;
                config.connect_ws = None;
                config.headless = true;
                config.persist_profile = false;
                config.enabled = true;
            }

            // Enable internal browser
            browser_manager.set_enabled_sync(true);

            // Explicitly (re)start the internal browser session now
            if let Err(e) = browser_manager.start().await {
                tracing::error!("Failed to start internal browser: {}", e);
                app_event_tx
                    .send_background_event_with_ticket(
                        &ticket,
                        format!("❌ Failed to start internal browser: {}", e),
                    );
                return;
            }

            // Set as global manager so core/session share the same instance
            code_browser::global::set_global_browser_manager(browser_manager.clone()).await;

            // Notify about successful switch/reconnect
            app_event_tx.send_background_event_with_ticket(
                &ticket,
                "✅ Switched to internal browser mode (reconnected)".to_string(),
            );

            // Clear any existing screenshot
            if let Ok(mut screenshot) = latest_screenshot.lock() {
                *screenshot = None;
            }

            // Proactively navigate to about:blank, then capture a first screenshot to populate HUD
            let _ = browser_manager.goto("about:blank").await;
            // Capture an initial screenshot to populate HUD
            tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
            match browser_manager.capture_screenshot_with_url().await {
                Ok((paths, url)) => {
                    if let Some(first_path) = paths.first() {
                        if let Ok(mut latest) = latest_screenshot.lock() {
                            *latest = Some((
                                first_path.clone(),
                                url.clone().unwrap_or_else(|| "Browser".to_string()),
                            ));
                        }
                        use code_core::protocol::BrowserScreenshotUpdateEvent;
                        use code_core::protocol::EventMsg;
                        let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                            id: uuid::Uuid::new_v4().to_string(),
                            event_seq: 0,
                            msg: EventMsg::BrowserScreenshotUpdate(BrowserScreenshotUpdateEvent {
                                screenshot_path: first_path.clone(),
                                url: url.unwrap_or_else(|| "Browser".to_string()),
                            }),
                            order: None,
                        }));
                    }
                }
                Err(e) => {
                    tracing::warn!(
                        "Failed to capture initial internal browser screenshot: {}",
                        e
                    );
                }
            }
        });
    }

    fn handle_chrome_connection(
        &mut self,
        host: Option<String>,
        port: Option<u16>,
        ticket: BackgroundOrderTicket,
    ) {
        tracing::info!(
            "[cdp] handle_chrome_connection begin, host={:?}, port={:?}",
            host,
            port
        );
        self.browser_is_external = true;
        let latest_screenshot = self.latest_browser_screenshot.clone();
        let app_event_tx = self.app_event_tx.clone();
        let port_display = port.map_or("auto-detect".to_string(), |p| p.to_string());
        let host_display = host.clone().unwrap_or_else(|| "127.0.0.1".to_string());

        // Add status message to chat (use BackgroundEvent with header so it renders reliably)
        let status_msg = format!(
            "🔗 Connecting to Chrome DevTools Protocol ({}:{})...",
            host_display, port_display
        );
        self.push_background_before_next_output(status_msg);

        // Connect in background with a single, unified flow (no double-connect)
        tokio::spawn(async move {
            tracing::info!(
                "[cdp] connect task spawned, host={:?}, port={:?}",
                host,
                port
            );
            // Unified connect flow; emits success/failure messages internally
            ChatWidget::connect_to_cdp_chrome(
                host,
                port,
                latest_screenshot.clone(),
                app_event_tx.clone(),
                ticket,
            )
            .await;
        });
    }

    pub(crate) fn handle_chrome_command(&mut self, command_text: String) {
        tracing::info!("[cdp] handle_chrome_command start: '{}'", command_text);
        // Parse the chrome command arguments
        let parts: Vec<&str> = command_text.trim().split_whitespace().collect();
        let chrome_ticket = self.make_background_tail_ticket();
        self.consume_pending_prompt_for_ui_only_turn();

        // Handle empty command - just "/chrome"
        if parts.is_empty() || command_text.trim().is_empty() {
            tracing::info!("[cdp] no args provided; toggle connect/disconnect");

            // Toggle behavior: if an external Chrome connection is active, disconnect it.
            // Otherwise, start a connection (auto-detect).
            let (tx, rx) = std::sync::mpsc::channel();
            let app_event_tx = self.app_event_tx.clone();
            let ticket = chrome_ticket.clone();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                // Check if we're currently connected to an external Chrome
                let (is_external, browser_active) = {
                    let cfg = browser_manager.config.read().await;
                    let is_external = cfg.connect_port.is_some() || cfg.connect_ws.is_some();
                    drop(cfg);
                    let status = browser_manager.get_status().await;
                    (is_external, status.browser_active)
                };

                if is_external && browser_active {
                    // Disconnect from external Chrome (do not close Chrome itself)
                    if let Err(e) = browser_manager.stop().await {
                        tracing::warn!("[cdp] failed to stop external Chrome connection: {}", e);
                    }
                    // Notify UI
                    app_event_tx.send_background_event_with_ticket(
                        &ticket,
                        "🔌 Disconnected from Chrome".to_string(),
                    );
                    let _ = tx.send(true);
                } else {
                    // Not connected externally; proceed to connect
                    let _ = tx.send(false);
                }
            });

            // If the async task handled a disconnect, stop here; otherwise connect.
            let handled_disconnect = rx.recv().unwrap_or(false);
            if !handled_disconnect {
                // Switch to external Chrome mode with default/auto-detected port
                self.handle_chrome_connection(None, None, chrome_ticket.clone());
            } else {
                // We just disconnected; reflect in title immediately
                self.browser_is_external = false;
                self.request_redraw();
            }
            return;
        }

        // Check if it's a status command
        if parts[0] == "status" {
            // Get status from BrowserManager - same as /browser status
            let (status_tx, status_rx) = std::sync::mpsc::channel();
            tokio::spawn(async move {
                let browser_manager = ChatWidget::get_browser_manager().await;
                let status = browser_manager.get_status_sync();
                let _ = status_tx.send(status);
            });
            let status = status_rx
                .recv()
                .unwrap_or_else(|_| "Failed to get browser status.".to_string());

            // Add the response to the UI
            let lines: Vec<String> = status.lines().map(|line| line.to_string()).collect();
            self.push_background_tail(lines.join("\n"));
            return;
        }

        // Accept several forms:
        //   /chrome 9222
        //   /chrome host:9222
        //   /chrome host 9222
        //   /chrome ws://host:9222/devtools/browser/<id>
        let mut host: Option<String> = None;
        let mut port: Option<u16> = None;
        let first = parts[0];

        if let Some(ws) = first
            .strip_prefix("ws://")
            .or_else(|| first.strip_prefix("wss://"))
        {
            // Full WS URL provided: set directly via config and return
            let ws_url = if first.starts_with("ws") {
                first.to_string()
            } else {
                format!("wss://{}", ws)
            };
            tracing::info!("[cdp] /chrome provided WS endpoint: {}", ws_url);
            // Configure and connect using WS
            self.browser_is_external = true;
            let latest_screenshot = self.latest_browser_screenshot.clone();
            let app_event_tx = self.app_event_tx.clone();
            tokio::spawn(async move {
                let bm = ChatWidget::get_browser_manager().await;
                {
                    let mut cfg = bm.config.write().await;
                    cfg.enabled = true;
                    cfg.headless = false;
                    cfg.persist_profile = true;
                    cfg.connect_ws = Some(ws_url);
                    cfg.connect_port = None;
                    cfg.connect_host = None;
                }
                let _ = bm.connect_to_chrome_only().await;
                // Capture a first screenshot if possible
                tokio::time::sleep(tokio::time::Duration::from_millis(300)).await;
                match bm.capture_screenshot_with_url().await {
                    Ok((paths, url)) => {
                        if let Some(first_path) = paths.first() {
                            if let Ok(mut latest) = latest_screenshot.lock() {
                                *latest = Some((
                                    first_path.clone(),
                                    url.clone().unwrap_or_else(|| "Browser".to_string()),
                                ));
                            }
                            use code_core::protocol::BrowserScreenshotUpdateEvent;
                            use code_core::protocol::EventMsg;
                            let _ = app_event_tx.send(AppEvent::CodexEvent(Event {
                                id: uuid::Uuid::new_v4().to_string(),
                                event_seq: 0,
                                msg: EventMsg::BrowserScreenshotUpdate(
                                    BrowserScreenshotUpdateEvent {
                                        screenshot_path: first_path.clone(),
                                        url: url.unwrap_or_else(|| "Browser".to_string()),
                                    },
                                ),
                                order: None,
                            }));
                        }
                    }
                    Err(e) => {
                        tracing::warn!(
                            "Failed to capture initial external Chrome screenshot: {}",
                            e
                        );
                    }
                }
            });
            return;
        }

        if let Some((h, p)) = first.rsplit_once(':') {
            if let Ok(pn) = p.parse::<u16>() {
                host = Some(h.to_string());
                port = Some(pn);
            }
        }
        if host.is_none() && port.is_none() {
            if let Ok(pn) = first.parse::<u16>() {
                port = Some(pn);
            } else if parts.len() >= 2 {
                if let Ok(pn) = parts[1].parse::<u16>() {
                    host = Some(first.to_string());
                    port = Some(pn);
                }
            }
        }
        tracing::info!("[cdp] parsed host={:?}, port={:?}", host, port);
        self.handle_chrome_connection(host, port, chrome_ticket);
    }

    /// Programmatically submit a user text message as if typed in the
    /// composer. The text will be added to conversation history and sent to
    /// the agent. This also handles slash command expansion.
    pub(crate) fn submit_text_message(&mut self, text: String) {
        if text.is_empty() {
            return;
        }
        self.submit_user_message(text.into());
    }

    /// Submit a message where the user sees `display` in history, but the
    /// model receives only `prompt`. This is used for prompt-expanding
    /// slash commands selected via the popup where expansion happens before
    /// reaching the normal composer pipeline.
    pub(crate) fn submit_prompt_with_display(&mut self, display: String, prompt: String) {
        if display.is_empty() && prompt.is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;
        let mut ordered = Vec::new();
        if !prompt.trim().is_empty() {
            ordered.push(InputItem::Text { text: prompt });
        }
        let msg = UserMessage {
            display_text: display,
            ordered_items: ordered,
            suppress_persistence: false,
        };
        self.submit_user_message(msg);
    }

    /// Submit a visible text message, but prepend a hidden instruction that is
    /// sent to the agent in the same turn. The hidden text is not added to the
    /// chat history; only `visible` appears to the user.
    pub(crate) fn submit_text_message_with_preface(&mut self, visible: String, preface: String) {
        if visible.is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;
        let mut ordered = Vec::new();
        if !preface.trim().is_empty() {
            ordered.push(InputItem::Text { text: preface });
        }
        ordered.push(InputItem::Text {
            text: visible.clone(),
        });
        let msg = UserMessage {
            display_text: visible,
            ordered_items: ordered,
            suppress_persistence: false,
        };
        self.submit_user_message(msg);
    }

    pub(crate) fn submit_hidden_text_message_with_preface(
        &mut self,
        agent_text: String,
        preface: String,
    ) {
        self.submit_hidden_text_message_with_preface_and_notice(agent_text, preface, false);
    }

    /// Submit a hidden message with optional notice surfacing.
    /// When `surface_notice` is true, the injected text is also shown in history
    /// as a developer-style notice; when false, the injection is silent.
    pub(crate) fn submit_hidden_text_message_with_preface_and_notice(
        &mut self,
        agent_text: String,
        preface: String,
        surface_notice: bool,
    ) {
        if agent_text.trim().is_empty() && preface.trim().is_empty() {
            return;
        }
        use crate::chatwidget::message::UserMessage;
        use code_core::protocol::InputItem;

        let mut ordered = Vec::new();
        let preface_cache = preface.clone();
        let agent_cache = agent_text.clone();
        if !preface.trim().is_empty() {
            ordered.push(InputItem::Text { text: preface });
        }
        if !agent_text.trim().is_empty() {
            ordered.push(InputItem::Text { text: agent_text });
        }

        if ordered.is_empty() {
            return;
        }

        if surface_notice {
            // Surface immediately in the TUI as a notice (developer-style message).
            let mut notice_lines = Vec::new();
            if !preface_cache.trim().is_empty() {
                notice_lines.push(preface_cache.trim().to_string());
            }
            if !agent_cache.trim().is_empty() {
                notice_lines.push(agent_cache.trim().to_string());
            }
            if !notice_lines.is_empty() {
                self.history_push_plain_paragraphs(PlainMessageKind::Notice, notice_lines);
            }
        }

        let msg = UserMessage {
            display_text: String::new(),
            ordered_items: ordered,
            suppress_persistence: false,
        };
        let mut cache = String::new();
        if !preface_cache.trim().is_empty() {
            cache.push_str(preface_cache.trim());
        }
        if !agent_cache.trim().is_empty() {
            if !cache.is_empty() {
                cache.push('\n');
            }
            cache.push_str(agent_cache.trim());
        }
        let cleaned = Self::strip_context_sections(&cache);
        self.last_developer_message = (!cleaned.trim().is_empty()).then_some(cleaned);
        self.pending_turn_origin = Some(TurnOrigin::Developer);
        self.submit_user_message_immediate(msg);
    }

    /// Dispatch a user message immediately, bypassing the queued/turn-active
    /// path. Used for developer/system injections that must not be lost if the
    /// current turn ends abruptly.
    fn submit_user_message_immediate(&mut self, message: UserMessage) {
        if message.ordered_items.is_empty() {
            return;
        }

        let items = message.ordered_items.clone();
        if let Err(e) = self.code_op_tx.send(Op::UserInput {
            items,
            final_output_json_schema: None,
        }) {
            tracing::error!("failed to send immediate UserInput: {e}");
        }

        self.finalize_sent_user_message(message);
    }

    /// Queue a note that will be delivered to the agent as a hidden system
    /// message immediately before the next user input is sent. Notes are
    /// drained in FIFO order so multiple updates retain their sequencing.
    pub(crate) fn queue_agent_note<S: Into<String>>(&mut self, note: S) {
        let note = note.into();
        if note.trim().is_empty() {
            return;
        }
        self.pending_agent_notes.push(note);
    }

    pub(crate) fn token_usage(&self) -> &TokenUsage {
        &self.total_token_usage
    }

    pub(crate) fn session_id(&self) -> Option<uuid::Uuid> {
        self.session_id
    }

    fn insert_resume_placeholder(&mut self) {
        if self.resume_placeholder_visible {
            return;
        }
        let key = self.next_req_key_top();
        let cell = history_cell::new_background_event(RESUME_PLACEHOLDER_MESSAGE.to_string());
        let _ = self.history_insert_with_key_global_tagged(Box::new(cell), key, "background", None);
        self.resume_placeholder_visible = true;
    }

    fn clear_resume_placeholder(&mut self) {
        if !self.resume_placeholder_visible {
            return;
        }
        if let Some(idx) = self.history_cells.iter().position(|cell| {
            cell.as_any()
                .downcast_ref::<crate::history_cell::BackgroundEventCell>()
                .map(|c| c.state().description.trim() == RESUME_PLACEHOLDER_MESSAGE)
                .unwrap_or(false)
        }) {
            self.history_remove_at(idx);
        }
        self.resume_placeholder_visible = false;
    }

    fn replace_resume_placeholder_with_notice(&mut self, message: &str) {
        if !self.resume_placeholder_visible {
            return;
        }
        self.clear_resume_placeholder();
        self.push_background_tail(message.to_string());
    }

    pub(crate) fn clear_token_usage(&mut self) {
        self.total_token_usage = TokenUsage::default();
        self.rate_limit_snapshot = None;
        self.rate_limit_warnings.reset();
        self.rate_limit_last_fetch_at = None;
        self.bottom_pane.set_token_usage(
            self.total_token_usage.clone(),
            self.last_token_usage.clone(),
            self.config.model_context_window,
        );
    }

    fn log_and_should_display_warning(&self, warning: &RateLimitWarning) -> bool {
        let reset_at = match warning.scope {
            RateLimitWarningScope::Primary => self.rate_limit_primary_next_reset_at,
            RateLimitWarningScope::Secondary => self.rate_limit_secondary_next_reset_at,
        };

        let account_id = auth_accounts::get_active_account_id(&self.config.code_home)
            .ok()
            .flatten()
            .unwrap_or_else(|| "_default".to_string());

        let plan = if account_id == "_default" {
            None
        } else {
            match account_usage::list_rate_limit_snapshots(&self.config.code_home) {
                Ok(records) => records
                    .into_iter()
                    .find(|record| record.account_id == account_id)
                    .and_then(|record| record.plan.clone()),
                Err(err) => {
                    tracing::warn!(?err, "failed to load rate limit snapshots while logging warning");
                    None
                }
            }
        };

        match account_usage::record_rate_limit_warning(
            &self.config.code_home,
            &account_id,
            plan.as_deref(),
            warning.scope,
            warning.threshold,
            reset_at,
            Utc::now(),
            &warning.message,
        ) {
            Ok(result) => result,
            Err(err) => {
                tracing::warn!(?err, "failed to persist rate limit warning log");
                true
            }
        }
    }

    /// Export transcript for buffer-mode mirroring: omit internal sentinels
    /// and include gutter icons and a blank line between items for readability.
    pub(crate) fn export_transcript_lines_for_buffer(&self) -> Vec<ratatui::text::Line<'static>> {
        let mut out: Vec<ratatui::text::Line<'static>> = Vec::new();
        for (idx, cell) in self.history_cells.iter().enumerate() {
            out.extend(self.render_lines_for_terminal(idx, cell.as_ref()));
        }
        // Include streaming preview if present (treat like assistant output)
        let mut streaming_lines = self
            .live_builder
            .display_rows()
            .into_iter()
            .map(|r| ratatui::text::Line::from(r.text))
            .collect::<Vec<_>>();
        if !streaming_lines.is_empty() {
            // Apply gutter to streaming preview (first line gets " • ", continuations get 3 spaces)
            if let Some(first) = streaming_lines.first_mut() {
                first.spans.insert(0, ratatui::text::Span::raw(" • "));
            }
            for line in streaming_lines.iter_mut().skip(1) {
                line.spans.insert(0, ratatui::text::Span::raw("   "));
            }
            out.extend(streaming_lines);
            out.push(ratatui::text::Line::from(""));
        }
        out
    }

    /// Render a single history cell into terminal-friendly lines:
    /// - Prepend a gutter icon (symbol + space) to the first line when defined.
    /// - Add a single blank line after the cell as a separator.
    fn render_lines_for_terminal(
        &self,
        idx: usize,
        cell: &dyn crate::history_cell::HistoryCell,
    ) -> Vec<ratatui::text::Line<'static>> {
        let mut lines = self.cell_lines_for_terminal_index(idx, cell);
        let _has_icon = cell.gutter_symbol().is_some();
        let first_prefix = if let Some(sym) = cell.gutter_symbol() {
            format!(" {} ", sym) // one space, icon, one space
        } else {
            "   ".to_string() // three spaces when no icon
        };
        if let Some(first) = lines.first_mut() {
            first
                .spans
                .insert(0, ratatui::text::Span::raw(first_prefix));
        }
        // For wrapped/subsequent lines, use a 3-space gutter to maintain alignment
        if lines.len() > 1 {
            for (_idx, line) in lines.iter_mut().enumerate().skip(1) {
                // Always 3 spaces for continuation lines
                line.spans.insert(0, ratatui::text::Span::raw("   "));
            }
        }
        lines.push(ratatui::text::Line::from(""));
        lines
    }

    /// Desired bottom pane height (in rows) for a given terminal width.
    pub(crate) fn desired_bottom_height(&self, width: u16) -> u16 {
        self.bottom_pane.desired_height(width)
    }

    /// The last bottom pane height (rows) that the layout actually used.
    /// If not yet set, fall back to a conservative estimate from BottomPane.

    // (Removed) Legacy in-place reset method. The /new command now creates a fresh
    // ChatWidget (new core session) to ensure the agent context is fully reset.

    pub fn cursor_pos(&self, area: Rect) -> Option<(u16, u16)> {
        // Hide the terminal cursor whenever a top‑level overlay is active so the
        // caret does not show inside the input while a modal (help/diff) is open.
        if self.diffs.overlay.is_some()
            || self.help.overlay.is_some()
            || self.settings.overlay.is_some()
            || self.terminal.overlay().is_some()
            || self.browser_overlay_visible
            || self.agents_terminal.active
        {
            return None;
        }
        let layout_areas = self.layout_areas(area);
        let bottom_pane_area = if layout_areas.len() == 4 {
            layout_areas[3]
        } else {
            layout_areas[2]
        };
        self.bottom_pane.cursor_pos(bottom_pane_area)
    }

    fn measured_font_size(&self) -> (u16, u16) {
        *self.cached_cell_size.get_or_init(|| {
            let size = self.terminal_info.font_size;

            // HACK: On macOS Retina displays, terminals often report physical pixels
            // but ratatui-image expects logical pixels. If we detect suspiciously
            // large cell sizes (likely 2x scaled), divide by 2.
            #[cfg(target_os = "macos")]
            {
                if size.0 >= 14 && size.1 >= 28 {
                    // Likely Retina display reporting physical pixels
                    tracing::info!(
                        "Detected likely Retina display, adjusting cell size from {:?} to {:?}",
                        size,
                        (size.0 / 2, size.1 / 2)
                    );
                    return (size.0 / 2, size.1 / 2);
                }
            }

            size
        })
    }

    fn get_git_branch(&self) -> Option<String> {
        use std::fs;
        use std::path::Path;

        let head_path = self.config.cwd.join(".git/HEAD");
        let mut cache = self.git_branch_cache.borrow_mut();
        let now = Instant::now();

        let needs_refresh = match cache.last_refresh {
            Some(last) => now.duration_since(last) >= Duration::from_millis(500),
            None => true,
        };

        if needs_refresh {
            let modified = fs::metadata(&head_path)
                .and_then(|meta| meta.modified())
                .ok();

            let metadata_changed = cache.last_head_mtime != modified || cache.last_refresh.is_none();

            if metadata_changed {
                cache.value = fs::read_to_string(&head_path)
                    .ok()
                    .and_then(|head_contents| {
                        let head = head_contents.trim();

                        if let Some(rest) = head.strip_prefix("ref: ") {
                            return Path::new(rest)
                                .file_name()
                                .and_then(|s| s.to_str())
                                .filter(|s| !s.is_empty())
                                .map(|name| name.to_string());
                        }

                        if head.len() >= 7
                            && head.as_bytes().iter().all(|byte| byte.is_ascii_hexdigit())
                        {
                            return Some(format!("detached: {}", &head[..7]));
                        }

                        None
                    });
                cache.last_head_mtime = modified;
            }

            cache.last_refresh = Some(now);
        }

        cache.value.clone()
    }

    fn render_status_bar(&self, area: Rect, buf: &mut Buffer) {
        use crate::exec_command::relativize_to_home;
        use ratatui::layout::Margin;
        use ratatui::style::Modifier;
        use ratatui::style::Style;
        use ratatui::text::Line;
        use ratatui::text::Span;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;

        // Add same horizontal padding as the Message input (2 chars on each side)
        let horizontal_padding = 1u16;
        let padded_area = Rect {
            x: area.x + horizontal_padding,
            y: area.y,
            width: area.width.saturating_sub(horizontal_padding * 2),
            height: area.height,
        };

        // Get current working directory string
        let cwd_str = match relativize_to_home(&self.config.cwd) {
            Some(rel) if !rel.as_os_str().is_empty() => format!("~/{}", rel.display()),
            Some(_) => "~".to_string(),
            None => self.config.cwd.display().to_string(),
        };

        let cwd_short_str = cwd_str
            .rsplit(|c| c == '/' || c == '\\')
            .find(|segment| !segment.is_empty())
            .unwrap_or(cwd_str.as_str())
            .to_string();

        // Build status line spans with dynamic elision based on width.
        // Removal priority when space is tight:
        //   1) Reasoning level
        //   2) Model
        //   3) Branch
        //   4) Directory
        let branch_opt = self.get_git_branch();

        // Helper to assemble spans based on include flags
        let build_spans = |include_reasoning: bool,
                           include_model: bool,
                           include_branch: bool,
                           include_dir: bool,
                           dir_display: &str| {
            let mut spans: Vec<Span> = Vec::new();
            // Title follows theme text color
            spans.push(Span::styled(
                "Every Code",
                Style::default()
                    .fg(crate::colors::text())
                    .add_modifier(Modifier::BOLD),
            ));

            if include_model {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Model: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    self.format_model_name(&self.config.model),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_reasoning {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Reasoning: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    Self::format_reasoning_effort(self.config.model_reasoning_effort),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_dir {
                spans.push(Span::styled(
                    "  •  ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    "Directory: ",
                    Style::default().fg(crate::colors::text_dim()),
                ));
                spans.push(Span::styled(
                    dir_display.to_string(),
                    Style::default().fg(crate::colors::info()),
                ));
            }

            if include_branch {
                if let Some(branch) = &branch_opt {
                    spans.push(Span::styled(
                        "  •  ",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                    spans.push(Span::styled(
                        "Branch: ",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                    spans.push(Span::styled(
                        branch.clone(),
                        Style::default().fg(crate::colors::success_green()),
                    ));
                }
            }

            // Footer already shows the Ctrl+R hint; avoid duplicating it here.

            spans
        };

        // Start with all items in production; tests can opt-in to a minimal header via env flag.
        let minimal_header = std::env::var_os("CODEX_TUI_FORCE_MINIMAL_HEADER").is_some();
        let demo_mode = self.config.demo_developer_message.is_some();
        let mut include_reasoning = !minimal_header;
        let mut include_model = !minimal_header;
        let mut include_branch = !minimal_header && branch_opt.is_some();
        let mut include_dir = !minimal_header && !demo_mode;
        let mut use_short_dir = false;
        let mut status_spans = build_spans(
            include_reasoning,
            include_model,
            include_branch,
            include_dir,
            &cwd_str,
        );

        // Now recompute exact available width inside the border + padding before measuring
        // Render a bordered status block and explicitly fill its background.
        // Without a background fill, some terminals blend with prior frame
        // contents, which is especially noticeable on dark themes as dark
        // "caps" at the edges. Match the app background for consistency.
        let status_block = Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(crate::colors::border()))
            .style(Style::default().bg(crate::colors::background()));
        let inner_area = status_block.inner(padded_area);
        let padded_inner = inner_area.inner(Margin::new(1, 0));
        let inner_width = padded_inner.width as usize;

        // Helper to measure current spans width
        let measure =
            |spans: &Vec<Span>| -> usize { spans.iter().map(|s| s.content.chars().count()).sum() };

        if include_dir && !use_short_dir && measure(&status_spans) > inner_width {
            use_short_dir = true;
            status_spans = build_spans(
                include_reasoning,
                include_model,
                include_branch,
                include_dir,
                &cwd_short_str,
            );
        }

        // Elide items in priority order until content fits
        while measure(&status_spans) > inner_width {
            if include_reasoning {
                include_reasoning = false;
            } else if include_model {
                include_model = false;
            } else if include_branch {
                include_branch = false;
            } else if include_dir {
                include_dir = false;
            } else {
                break;
            }
            status_spans = build_spans(
                include_reasoning,
                include_model,
                include_branch,
                include_dir,
                if use_short_dir { &cwd_short_str } else { &cwd_str },
            );
        }

        // Note: The reasoning visibility hint is appended inside `build_spans`
        // so it participates in width measurement and elision. Do not append
        // it again here to avoid overflow that caused corrupted glyph boxes on
        // some terminals.

        let status_line = Line::from(status_spans);

        let now = Instant::now();
        let mut frame_needed = false;
        if ENABLE_WARP_STRIPES && self.header_wave.schedule_if_needed(now) {
            frame_needed = true;
        }
        if frame_needed {
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(HeaderWaveEffect::FRAME_INTERVAL));
        }

        // Render the block first
        status_block.render(padded_area, buf);
        let wave_enabled = self.header_wave.is_enabled();
        if wave_enabled {
            self.header_wave.render(padded_area, buf, now);
        }

        // Then render the text inside with padding, centered
        let effect_enabled = wave_enabled;
        let status_style = if effect_enabled {
            Style::default().fg(crate::colors::text())
        } else {
            Style::default()
                .bg(crate::colors::background())
                .fg(crate::colors::text())
        };

        let status_widget = Paragraph::new(vec![status_line])
            .alignment(ratatui::layout::Alignment::Center)
            .style(status_style);
        ratatui::widgets::Widget::render(status_widget, padded_inner, buf);
    }

    fn render_screenshot_highlevel(&self, path: &PathBuf, area: Rect, buf: &mut Buffer) {
        use ratatui::widgets::Widget;
        use ratatui_image::Image;
        use ratatui_image::Resize;
        use ratatui_image::picker::Picker;
        use ratatui_image::picker::ProtocolType;

        // First, cheaply read image dimensions without decoding the full image
        let (img_w, img_h) = match image::image_dimensions(path) {
            Ok(dim) => dim,
            Err(_) => {
                self.render_screenshot_placeholder(path, area, buf);
                return;
            }
        };

        // picker (Retina 2x workaround preserved)
        let mut cached_picker = self.cached_picker.borrow_mut();
        if cached_picker.is_none() {
            // If we didn't get a picker from terminal query at startup, create one from font size
            let (fw, fh) = self.measured_font_size();
            let p = Picker::from_fontsize((fw, fh));

            *cached_picker = Some(p);
        }
        let picker = cached_picker.as_ref().unwrap();

        // quantize step by protocol to avoid rounding bias
        let (_qx, _qy): (u16, u16) = match picker.protocol_type() {
            ProtocolType::Halfblocks => (1, 2), // half-block cell = 1 col x 2 half-rows
            _ => (1, 1),                        // pixel protocols (Kitty/iTerm2/Sixel)
        };

        // terminal cell aspect
        let (cw, ch) = self.measured_font_size();
        let cols = area.width as u32;
        let rows = area.height as u32;
        let cw = cw as u32;
        let ch = ch as u32;

        // fit (floor), then choose limiting dimension
        let mut rows_by_w = (cols * cw * img_h) / (img_w * ch);
        if rows_by_w == 0 {
            rows_by_w = 1;
        }
        let mut cols_by_h = (rows * ch * img_w) / (img_h * cw);
        if cols_by_h == 0 {
            cols_by_h = 1;
        }

        let (_used_cols, _used_rows) = if rows_by_w <= rows {
            (cols, rows_by_w)
        } else {
            (cols_by_h, rows)
        };

        // Compute a centered target rect based on image aspect and font cell size
        let (cell_w, cell_h) = self.measured_font_size();
        let area_px_w = (area.width as u32) * (cell_w as u32);
        let area_px_h = (area.height as u32) * (cell_h as u32);
        // If either dimension is zero, bail to placeholder
        if area.width == 0 || area.height == 0 || area_px_w == 0 || area_px_h == 0 {
            self.render_screenshot_placeholder(path, area, buf);
            return;
        }
        let (img_w, img_h) = match image::image_dimensions(path) {
            Ok(dim) => dim,
            Err(_) => {
                self.render_screenshot_placeholder(path, area, buf);
                return;
            }
        };
        let scale_num_w = area_px_w;
        let scale_num_h = area_px_h;
        let scale_w = scale_num_w as f64 / img_w as f64;
        let scale_h = scale_num_h as f64 / img_h as f64;
        let scale = scale_w.min(scale_h).max(0.0);
        // Compute target size in cells
        let target_w_cells = ((img_w as f64 * scale) / (cell_w as f64)).floor() as u16;
        let target_h_cells = ((img_h as f64 * scale) / (cell_h as f64)).floor() as u16;
        let target_w = target_w_cells.clamp(1, area.width);
        let target_h = target_h_cells.clamp(1, area.height);
        let target_x = area.x + (area.width.saturating_sub(target_w)) / 2;
        let target_y = area.y + (area.height.saturating_sub(target_h)) / 2;
        let target = Rect {
            x: target_x,
            y: target_y,
            width: target_w,
            height: target_h,
        };

        // cache by (path, target)
        let needs_recreate = {
            let cached = self.cached_image_protocol.borrow();
            match cached.as_ref() {
                Some((cached_path, cached_rect, _)) => {
                    cached_path != path || *cached_rect != target
                }
                None => true,
            }
        };
        if needs_recreate {
            // Only decode when we actually need to (path/target changed)
            let dyn_img = match image::ImageReader::open(path) {
                Ok(r) => match r.decode() {
                    Ok(img) => img,
                    Err(_) => {
                        self.render_screenshot_placeholder(path, area, buf);
                        return;
                    }
                },
                Err(_) => {
                    self.render_screenshot_placeholder(path, area, buf);
                    return;
                }
            };
            match picker.new_protocol(dyn_img, target, Resize::Fit(Some(FilterType::Lanczos3))) {
                Ok(protocol) => {
                    *self.cached_image_protocol.borrow_mut() =
                        Some((path.clone(), target, protocol))
                }
                Err(_) => {
                    self.render_screenshot_placeholder(path, area, buf);
                    return;
                }
            }
        }

        if let Some((_, rect, protocol)) = &*self.cached_image_protocol.borrow() {
            let image = Image::new(protocol);
            Widget::render(image, *rect, buf);
        } else {
            self.render_screenshot_placeholder(path, area, buf);
        }
    }

    fn render_screenshot_placeholder(&self, path: &PathBuf, area: Rect, buf: &mut Buffer) {
        use ratatui::style::Modifier;
        use ratatui::style::Style;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;

        // Show a placeholder box with screenshot info
        let filename = path
            .file_name()
            .and_then(|n| n.to_str())
            .unwrap_or("screenshot");

        let placeholder_text = format!("[Screenshot]\n{}", filename);
        let placeholder_widget = Paragraph::new(placeholder_text)
            .block(
                Block::default()
                    .borders(Borders::ALL)
                    .border_style(Style::default().fg(crate::colors::info()))
                    .title("Browser"),
            )
            .style(
                Style::default()
                    .fg(crate::colors::text_dim())
                    .add_modifier(Modifier::ITALIC),
            )
            .wrap(ratatui::widgets::Wrap { trim: true });

        placeholder_widget.render(area, buf);
    }
}

async fn run_background_review(
    config: Config,
    app_event_tx: AppEventSender,
    base_snapshot: Option<GhostCommit>,
    turn_context: Option<String>,
    prefer_fallback: bool,
) {
    // Best-effort: clean up any stale lock left by a cancelled review process.
    let _ = code_core::review_coord::clear_stale_lock_if_dead(Some(&config.cwd));

    // Prevent duplicate auto-reviews within this process: if any AutoReview agent
    // is already pending/running, bail early with a benign notice.
    {
        let mgr = code_core::AGENT_MANAGER.read().await;
        let busy = mgr
            .list_agents(None, Some("auto-review".to_string()), false)
            .into_iter()
            .any(|agent| {
                let status = format!("{:?}", agent.status).to_ascii_lowercase();
                status == "running" || status == "pending"
            });
        if busy {
            app_event_tx.send(AppEvent::BackgroundReviewFinished {
                worktree_path: std::path::PathBuf::new(),
                branch: String::new(),
                has_findings: false,
                findings: 0,
                summary: Some("Auto review skipped: another auto review is already running.".to_string()),
                error: None,
                agent_id: None,
                snapshot: None,
            });
            return;
        }
    }

    let app_event_tx_clone = app_event_tx.clone();
    let outcome = async move {
        let git_root = code_core::git_worktree::get_git_root_from(&config.cwd)
            .await
            .map_err(|e| format!("failed to detect git root: {e}"))?;

        let snapshot = task::spawn_blocking({
            let repo_path = config.cwd.clone();
            let base_snapshot = base_snapshot.clone();
            move || {
                let mut options = CreateGhostCommitOptions::new(repo_path.as_path())
                    .message("auto review snapshot");
                if let Some(base) = base_snapshot.as_ref() {
                    options = options.parent(base.id());
                }
                let hook_repo = repo_path.clone();
                let hook = move || bump_snapshot_epoch_for(&hook_repo);
                create_ghost_commit(&options.post_commit_hook(&hook))
            }
        })
        .await
        .map_err(|e| format!("failed to spawn snapshot task: {e}"))
        .and_then(|res| res.map_err(|e| format!("failed to capture snapshot: {e}")))?;

        let snapshot_id = snapshot.id().to_string();
        bump_snapshot_epoch_for(&config.cwd);

        // Attempt to hold the shared review lock; if busy or a previous review
        // with findings is still surfaced, fall back to a per-request
        // auto-review worktree to avoid clobbering pending fixes.
        let (worktree_path, branch, worktree_guard) = if prefer_fallback {
            let (path, name, guard) =
                allocate_fallback_auto_review_worktree(&git_root, &snapshot_id).await?;
            (path, name, guard)
        } else {
            match try_acquire_lock("review", &config.cwd) {
                Ok(Some(g)) => {
                    let path = code_core::git_worktree::prepare_reusable_worktree(
                        &git_root,
                        AUTO_REVIEW_SHARED_WORKTREE,
                        snapshot_id.as_str(),
                        true,
                    )
                    .await
                    .map_err(|e| format!("failed to prepare worktree: {e}"))?;
                    (path, AUTO_REVIEW_SHARED_WORKTREE.to_string(), g)
                }
                Ok(None) => {
                    let (path, name, guard) =
                        allocate_fallback_auto_review_worktree(&git_root, &snapshot_id).await?;
                    (path, name, guard)
                }
                Err(err) => {
                    return Err(format!("could not acquire review lock: {err}"));
                }
            }
        };

        // Ensure Codex models are invoked via the `code-` CLI shim so they exist on PATH.
        fn ensure_code_prefix(model: &str) -> String {
            let lower = model.to_ascii_lowercase();
            if lower.starts_with("code-") {
                model.to_string()
            } else {
                format!("code-{}", model)
            }
        }

        let review_model = ensure_code_prefix(&config.auto_review_model);

        // Allow the spawned agent to reuse the parent's review lock without blocking.
        let mut env: std::collections::HashMap<String, String> = std::collections::HashMap::new();
        env.insert("CODE_REVIEW_LOCK_LEASE".to_string(), "1".to_string());
        let agent_config = code_core::config_types::AgentConfig {
            name: review_model.clone(),
            command: String::new(),
            args: Vec::new(),
            read_only: false,
            enabled: true,
            description: None,
            env: Some(env),
            args_read_only: None,
            args_write: None,
            instructions: None,
        };

        // Use the /review entrypoint so upstream wiring (model defaults, review formatting) stays intact.
        let mut review_prompt = format!(
            "/review Analyze only changes made in commit {snapshot_id}. Identify critical bugs, regressions, security/performance/concurrency risks or incorrect assumptions. Provide actionable feedback and references to the changed code; ignore minor style or formatting nits."
        );

        if let Some(context) = turn_context {
            review_prompt.push_str("\n\n");
            review_prompt.push_str(&context);
        }

        let mut manager = code_core::AGENT_MANAGER.write().await;
        let agent_id = manager
            .create_agent_with_options(
                review_model,
                Some("Auto Review".to_string()),
                review_prompt,
                None,
                None,
                Vec::new(),
                false,
                Some(branch.clone()),
                Some(agent_config.clone()),
                Some(branch.clone()),
                Some(snapshot_id.clone()),
                Some(code_core::protocol::AgentSourceKind::AutoReview),
                config.auto_review_model_reasoning_effort.into(),
            )
            .await;
        insert_background_lock(&agent_id, worktree_guard);
        drop(manager);

        app_event_tx_clone.send(AppEvent::BackgroundReviewStarted {
            worktree_path: worktree_path.clone(),
            branch: branch.clone(),
            agent_id: Some(agent_id.clone()),
            snapshot: Some(snapshot_id.clone()),
        });
        Ok::<(PathBuf, String, String, String), String>((worktree_path, branch, agent_id, snapshot_id))
    }
    .await;

    if let Err(err) = outcome {
        app_event_tx.send(AppEvent::BackgroundReviewFinished {
            worktree_path: std::path::PathBuf::new(),
            branch: String::new(),
            has_findings: false,
            findings: 0,
            summary: None,
            error: Some(err),
            agent_id: None,
            snapshot: None,
        });
    }
}

#[allow(dead_code)]
fn insert_background_lock(agent_id: &str, guard: code_core::review_coord::ReviewGuard) {
    if let Ok(mut map) = BACKGROUND_REVIEW_LOCKS.lock() {
        map.insert(agent_id.to_string(), guard);
    }
}

fn release_background_lock(agent_id: &Option<String>) {
    if let Some(id) = agent_id {
        if let Ok(mut map) = BACKGROUND_REVIEW_LOCKS.lock() {
            map.remove(id);
        }
    }
}

#[cfg(test)]
static AUTO_REVIEW_STUB: once_cell::sync::Lazy<std::sync::Mutex<Option<Box<dyn FnMut() + Send>>>> =
    once_cell::sync::Lazy::new(|| std::sync::Mutex::new(None));

#[cfg(test)]
struct AutoReviewStubGuard;

#[cfg(test)]
impl AutoReviewStubGuard {
    fn install<F: FnMut() + Send + 'static>(f: F) -> Self {
        let mut guard = AUTO_REVIEW_STUB.lock().unwrap();
        *guard = Some(Box::new(f));
        AutoReviewStubGuard
    }
}

#[cfg(test)]
impl Drop for AutoReviewStubGuard {
    fn drop(&mut self) {
        if let Ok(mut guard) = AUTO_REVIEW_STUB.lock() {
            *guard = None;
        }
    }
}

#[cfg(test)]
    mod tests {
        use super::*;
        use super::{
            CAPTURE_AUTO_TURN_COMMIT_STUB,
            GIT_DIFF_NAME_ONLY_BETWEEN_STUB,
        };
        use crate::bottom_pane::AutoCoordinatorViewModel;
    use crate::chatwidget::message::UserMessage;
    use crate::chatwidget::smoke_helpers::{enter_test_runtime_guard, ChatWidgetHarness};
    use crate::history_cell::{self, ExploreAggregationCell, HistoryCellType};
    use code_auto_drive_core::{
        AutoContinueMode,
        AutoRunPhase,
        AutoRunSummary,
        TurnComplexity,
        TurnMode,
        AUTO_RESOLVE_MAX_REVIEW_ATTEMPTS,
    };
    use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
    use code_core::config_types::AutoResolveAttemptLimit;
    use code_core::history::state::{
        AssistantStreamDelta,
        AssistantStreamState,
        HistoryId,
        HistoryRecord,
        HistorySnapshot,
        HistoryState,
        InlineSpan,
        MessageLine,
        MessageLineKind,
        OrderKeySnapshot,
        PlainMessageKind,
        PlainMessageRole,
        PlainMessageState,
        TextEmphasis,
        TextTone,
    };
use code_core::parse_command::ParsedCommand;
use code_core::protocol::OrderMeta;
    use code_core::protocol::{
        AskForApproval,
        AgentMessageEvent,
        AgentStatusUpdateEvent,
        ErrorEvent,
        Event,
        EventMsg,
        ExecCommandBeginEvent,
        TaskCompleteEvent,
    };
    use code_core::protocol::AgentInfo as CoreAgentInfo;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::process::Command;
    use tempfile::tempdir;
    use std::sync::Arc;
    use std::path::PathBuf;

    #[test]
    fn parse_agent_review_result_json_clean() {
        let json = r#"{
            "findings": [],
            "overall_correctness": "ok",
            "overall_explanation": "looks clean",
            "overall_confidence_score": 0.9
        }"#;

        let (has_findings, findings, summary) = ChatWidget::parse_agent_review_result(Some(json));
        assert!(!has_findings);
        assert_eq!(findings, 0);
        assert_eq!(summary.as_deref(), Some("looks clean"));
    }

    #[test]
    fn parse_agent_review_result_json_with_findings() {
        let json = r#"{
            "findings": [
                {"title": "bug", "body": "fix", "confidence_score": 0.5, "priority": 1, "code_location": {"absolute_file_path": "foo", "line_range": {"start":1,"end":1}}}
            ],
            "overall_correctness": "incorrect",
            "overall_explanation": "needs work",
            "overall_confidence_score": 0.6
        }"#;

        let (has_findings, findings, summary) = ChatWidget::parse_agent_review_result(Some(json));
        assert!(has_findings);
        assert_eq!(findings, 1);
        let summary_text = summary.unwrap();
        assert!(summary_text.contains("needs work"));
        assert!(summary_text.contains("bug"));
    }

    #[test]
    fn parse_agent_review_result_json_multi_run() {
        let json = r#"{
            "findings": [],
            "overall_correctness": "correct",
            "overall_explanation": "clean",
            "overall_confidence_score": 0.9,
            "runs": [
                {
                    "findings": [
                        {"title": "bug", "body": "fix", "confidence_score": 0.5, "priority": 1, "code_location": {"absolute_file_path": "foo", "line_range": {"start":1,"end":1}}}
                    ],
                    "overall_correctness": "incorrect",
                    "overall_explanation": "needs work",
                    "overall_confidence_score": 0.6
                },
                {
                    "findings": [],
                    "overall_correctness": "correct",
                    "overall_explanation": "clean",
                    "overall_confidence_score": 0.9
                }
            ]
        }"#;

        let (has_findings, findings, summary) = ChatWidget::parse_agent_review_result(Some(json));
        assert!(has_findings);
        assert_eq!(findings, 1);
        let summary_text = summary.unwrap();
        assert!(summary_text.contains("needs work"));
        assert!(summary_text.contains("Final pass reported no issues"));
    }

    #[test]
    fn parse_agent_review_result_skip_lock() {
        let text = "Another review is already running; skipping this /review.";
        let (has_findings, findings, summary) = ChatWidget::parse_agent_review_result(Some(text));

        assert!(!has_findings);
        assert_eq!(findings, 0);
        assert_eq!(summary.as_deref(), Some(text));
    }

    #[test]
    fn format_model_name_capitalizes_codex_mini() {
        let mut harness = ChatWidgetHarness::new();
        let formatted = harness.chat().format_model_name("gpt-5.1-codex-mini");
        assert_eq!(formatted, "GPT-5.1-Codex-Mini");
    }

    #[test]
    fn auto_review_triggers_when_enabled_and_diff_seen() {
        let _guard = AutoReviewStubGuard::install(|| {});
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        chat.config.tui.auto_review_enabled = true;
        chat.turn_had_code_edits = true;
        chat.background_review = None;

        chat.maybe_trigger_auto_review();

        assert!(chat.background_review.is_some(), "background review should start");
    }

    #[test]
    fn auto_review_does_not_duplicate_while_running() {
        let calls = Arc::new(AtomicUsize::new(0));
        let calls_clone = calls.clone();
        let _guard = AutoReviewStubGuard::install(move || {
            calls_clone.fetch_add(1, Ordering::SeqCst);
        });

        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        chat.config.tui.auto_review_enabled = true;
        chat.turn_had_code_edits = true;
        chat.background_review = None;

        chat.maybe_trigger_auto_review();
        // Already running; second trigger should no-op
        chat.turn_had_code_edits = true;
        chat.maybe_trigger_auto_review();

        assert_eq!(calls.load(Ordering::SeqCst), 1);
    }

    #[test]
    fn auto_review_skips_when_no_changes_since_reviewed_snapshot() {
        let _rt = enter_test_runtime_guard();
        let calls = Arc::new(AtomicUsize::new(0));
        let calls_clone = calls.clone();
        let _guard = AutoReviewStubGuard::install(move || {
            calls_clone.fetch_add(1, Ordering::SeqCst);
        });

        let repo = tempdir().expect("temp repo");
        let repo_path = repo.path();
        let git = |args: &[&str]| {
            let status = Command::new("git")
                .current_dir(repo_path)
                .args(args)
                .status()
                .expect("git command");
            assert!(status.success(), "git command failed: {args:?}");
        };

        git(&["init"]);
        git(&["config", "user.email", "auto@review.test"]);
        git(&["config", "user.name", "Auto Review"]);
        std::fs::write(repo_path.join("README.md"), "hello")
            .expect("write README");
        git(&["add", "."]);
        git(&["commit", "-m", "init"]);

        let snapshot = create_ghost_commit(
            &CreateGhostCommitOptions::new(repo_path).message("auto review snapshot"),
        )
        .expect("ghost snapshot");

        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        chat.config.cwd = repo_path.to_path_buf();
        chat.config.tui.auto_review_enabled = true;
        chat.turn_had_code_edits = true;
        chat.auto_review_reviewed_marker = Some(snapshot);

        chat.maybe_trigger_auto_review();

        assert_eq!(calls.load(Ordering::SeqCst), 0, "auto review should skip");
        assert!(chat.background_review.is_none());
    }

    #[test]
    fn task_started_defers_auto_review_baseline_capture() {
        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();
        let _rt = enter_test_runtime_guard();
        let _capture_guard = CaptureCommitStubGuard::install(|_, _| {
            Ok(GhostCommit::new("baseline".to_string(), None))
        });
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        chat.config.tui.auto_review_enabled = true;

        chat.handle_code_event(Event {
            id: "turn-1".to_string(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        assert!(
            chat.auto_review_baseline.is_none(),
            "baseline capture should not block TaskStarted"
        );
    }

    #[test]
    fn background_review_completion_resumes_auto_and_posts_summary() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.insert_final_answer_with_id(
            None,
            vec![ratatui::text::Line::from("Assistant reply")],
            "Assistant reply".to_string(),
        );

        chat.config.tui.auto_review_enabled = true;
        chat.auto_state.on_begin_review(false);

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-branch".to_string(),
            agent_id: Some("agent-123".to_string()),
            snapshot: Some("ghost123".to_string()),
            base: None,
            last_seen: std::time::Instant::now(),
        });

        chat.on_background_review_finished(
            PathBuf::from("/tmp/wt"),
            "auto-review-branch".to_string(),
            true,
            2,
            Some("Short summary".to_string()),
            None,
            Some("agent-123".to_string()),
            Some("ghost123".to_string()),
        );

        assert!(
            !chat.auto_state.awaiting_review(),
            "auto drive should resume after background review completes"
        );

        let footer_status = chat
            .bottom_pane
            .auto_review_status()
            .expect("footer should show auto review status");
        assert_eq!(footer_status.status, AutoReviewIndicatorStatus::Fixed);
        assert_eq!(footer_status.findings, Some(2));
        let notice_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains("issue(s) found"))
            })
        });
        assert!(notice_present, "actionable auto review notice should be visible");
        assert!(chat.pending_agent_notes.is_empty(), "idle path should inject via hidden message, not queue notes");
        let developer_seen = chat
            .pending_dispatched_user_messages
            .iter()
            .any(|msg| msg.contains("[developer]"));
        assert!(developer_seen, "developer note should be sent in hidden message");
    }

    #[test]
    fn background_review_busy_path_enqueues_developer_note_with_merge_hint() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.auto_review_enabled = true;
        chat.bottom_pane.set_task_running(true); // simulate busy state so note is queued

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-branch".to_string(),
            agent_id: Some("agent-123".to_string()),
            snapshot: Some("ghost123".to_string()),
            base: None,
            last_seen: std::time::Instant::now(),
        });

        // Agent.result will be parsed; provide structured JSON with findings
        let review_json = r#"{
            "findings": [
                {"title": "bug", "body": "fix", "confidence_score": 0.5, "priority": 1, "code_location": {"absolute_file_path": "foo", "line_range": {"start":1,"end":1}}}
            ],
            "overall_correctness": "incorrect",
            "overall_explanation": "needs work",
            "overall_confidence_score": 0.6
        }"#;

        // Simulate agent status observation completion path
        chat.on_background_review_finished(
            PathBuf::from("/tmp/wt"),
            "auto-review-branch".to_string(),
            true,
            1,
            Some(review_json.to_string()),
            None,
            Some("agent-123".to_string()),
            Some("ghost123".to_string()),
        );

        // Busy path still injects a developer note immediately so the user sees it in the transcript.
        assert!(chat.pending_agent_notes.is_empty());
        let developer_sent = chat
            .pending_dispatched_user_messages
            .iter()
            .any(|msg| msg.contains("[developer]") && msg.contains("Merge the worktree") && msg.contains("auto-review-branch"));
        assert!(developer_sent, "developer merge-hint note should be injected even while busy");
    }

    #[test]
    fn background_review_observe_idle_injects_note_from_agent_result() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.auto_review_enabled = true;
        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-branch".to_string(),
            agent_id: None,
            snapshot: Some("ghost123".to_string()),
            base: None,
            last_seen: std::time::Instant::now(),
        });

        let agent = code_core::protocol::AgentInfo {
            id: "agent-1".to_string(),
            name: "Auto Review".to_string(),
            status: "completed".to_string(),
            batch_id: Some("auto-review-branch".to_string()),
            model: Some("code-review".to_string()),
            last_progress: None,
            result: Some(
                r#"{
                    "findings":[{"title":"bug","body":"details","confidence_score":0.5,"priority":1,"code_location":{"absolute_file_path":"src/lib.rs","line_range":{"start":1,"end":1}}}],
                    "overall_correctness":"incorrect",
                    "overall_explanation":"needs work",
                    "overall_confidence_score":0.6
                }"#
                .to_string(),
            ),
            error: None,
            elapsed_ms: None,
            token_count: None,
            last_activity_at: None,
            seconds_since_last_activity: None,
            source_kind: Some(AgentSourceKind::AutoReview),
        };

        chat.observe_auto_review_status(&[agent]);

        // Idle path: should send hidden developer note immediately (not queued)
        assert!(chat.pending_agent_notes.is_empty());
        let developer_sent = chat
            .pending_dispatched_user_messages
            .iter()
            .any(|msg| msg.contains("[developer]") && msg.contains("Merge the worktree") && msg.contains("auto-review-branch"));
        assert!(developer_sent, "developer merge-hint note should be injected when idle");
    }

    #[test]
    fn background_review_observe_busy_queues_note_from_agent_result() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.auto_review_enabled = true;
        chat.bottom_pane.set_task_running(true);
        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-branch".to_string(),
            agent_id: None,
            snapshot: Some("ghost123".to_string()),
            base: None,
            last_seen: std::time::Instant::now(),
        });

        let agent = code_core::protocol::AgentInfo {
            id: "agent-1".to_string(),
            name: "Auto Review".to_string(),
            status: "completed".to_string(),
            batch_id: Some("auto-review-branch".to_string()),
            model: Some("code-review".to_string()),
            last_progress: None,
            result: Some(
                r#"{
                    "findings":[{"title":"bug","body":"details","confidence_score":0.5,"priority":1,"code_location":{"absolute_file_path":"src/lib.rs","line_range":{"start":1,"end":1}}}],
                    "overall_correctness":"incorrect",
                    "overall_explanation":"needs work",
                    "overall_confidence_score":0.6
                }"#
                .to_string(),
            ),
            error: None,
            elapsed_ms: None,
            token_count: None,
            last_activity_at: None,
            seconds_since_last_activity: None,
            source_kind: Some(AgentSourceKind::AutoReview),
        };

        chat.observe_auto_review_status(&[agent]);

        assert!(chat.pending_agent_notes.is_empty());
        let developer_sent = chat
            .pending_dispatched_user_messages
            .iter()
            .any(|msg| msg.contains("[developer]") && msg.contains("Merge the worktree") && msg.contains("auto-review-branch"));
        assert!(developer_sent, "developer merge-hint note should be injected when busy");
    }

    #[test]
    fn skipped_auto_review_with_findings_defers_to_next_turn() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let launches = Arc::new(AtomicUsize::new(0));
        let launches_clone = launches.clone();
        let _stub = AutoReviewStubGuard::install(move || {
            launches_clone.fetch_add(1, Ordering::SeqCst);
        });

        chat.config.tui.auto_review_enabled = true;
        chat.turn_sequence = 1;
        chat.turn_had_code_edits = true;
        let pending_base = GhostCommit::new("base-skip".to_string(), None);
        chat.auto_review_baseline = Some(pending_base.clone());

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-running".to_string(),
            agent_id: Some("agent-running".to_string()),
            snapshot: Some("ghost-running".to_string()),
            base: Some(GhostCommit::new("running-base".to_string(), None)),
            last_seen: Instant::now(),
        });

        chat.maybe_trigger_auto_review();
        assert_eq!(launches.load(Ordering::SeqCst), 0, "should skip while review runs");
        let pending = chat
            .pending_auto_review_range
            .as_ref()
            .expect("pending range queued");
        assert_eq!(pending.base.id(), pending_base.id());
        assert_eq!(pending.defer_until_turn, None);

        chat.on_background_review_finished(
            PathBuf::from("/tmp/wt"),
            "auto-review-running".to_string(),
            true,
            2,
            Some("found issues".to_string()),
            None,
            Some("agent-running".to_string()),
            Some("ghost-running".to_string()),
        );

        let pending_after_finish = chat
            .pending_auto_review_range
            .as_ref()
            .expect("pending kept after findings");
        assert_eq!(pending_after_finish.defer_until_turn, Some(chat.turn_sequence));
        assert_eq!(launches.load(Ordering::SeqCst), 0, "follow-up deferred to next turn");

        chat.turn_sequence = 2;
        chat.turn_had_code_edits = true;
        chat.auto_review_baseline = Some(GhostCommit::new("next-base".to_string(), None));

        chat.maybe_trigger_auto_review();
        assert_eq!(launches.load(Ordering::SeqCst), 1, "follow-up launched next turn");
        let running = chat
            .background_review
            .as_ref()
            .expect("follow-up review should be running");
        assert_eq!(
            running.base.as_ref().map(|c| c.id()),
            Some(pending_base.id()),
            "follow-up should use first skipped base",
        );
    }

    #[test]
    fn skipped_auto_review_clean_runs_immediately() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let launches = Arc::new(AtomicUsize::new(0));
        let launches_clone = launches.clone();
        let _stub = AutoReviewStubGuard::install(move || {
            launches_clone.fetch_add(1, Ordering::SeqCst);
        });

        chat.config.tui.auto_review_enabled = true;
        chat.turn_sequence = 1;
        chat.turn_had_code_edits = true;
        let pending_base = GhostCommit::new("base-clean".to_string(), None);
        chat.auto_review_baseline = Some(pending_base.clone());

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-running".to_string(),
            agent_id: Some("agent-running".to_string()),
            snapshot: Some("ghost-running".to_string()),
            base: Some(GhostCommit::new("running-base".to_string(), None)),
            last_seen: Instant::now(),
        });

        chat.maybe_trigger_auto_review();
        assert_eq!(launches.load(Ordering::SeqCst), 0);
        assert!(chat.pending_auto_review_range.is_some());

        chat.on_background_review_finished(
            PathBuf::from("/tmp/wt"),
            "auto-review-running".to_string(),
            false,
            0,
            None,
            None,
            Some("agent-running".to_string()),
            Some("ghost-running".to_string()),
        );

        assert_eq!(launches.load(Ordering::SeqCst), 1, "follow-up should start immediately");
        assert!(chat.pending_auto_review_range.is_none(), "pending should be consumed");
        let running = chat.background_review.as_ref().expect("follow-up running");
        assert_eq!(
            running.base.as_ref().map(|c| c.id()),
            Some(pending_base.id()),
            "follow-up should cover skipped base",
        );
    }

    #[test]
    fn multiple_skipped_auto_reviews_collapse_to_first_base() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let launches = Arc::new(AtomicUsize::new(0));
        let launches_clone = launches.clone();
        let _stub = AutoReviewStubGuard::install(move || {
            launches_clone.fetch_add(1, Ordering::SeqCst);
        });

        chat.config.tui.auto_review_enabled = true;
        chat.turn_sequence = 1;
        chat.turn_had_code_edits = true;
        let first_base = GhostCommit::new("base-first".to_string(), None);
        chat.auto_review_baseline = Some(first_base.clone());

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-running".to_string(),
            agent_id: Some("agent-running".to_string()),
            snapshot: Some("ghost-running".to_string()),
            base: Some(GhostCommit::new("running-base".to_string(), None)),
            last_seen: Instant::now(),
        });

        chat.maybe_trigger_auto_review();
        assert_eq!(launches.load(Ordering::SeqCst), 0);
        let pending = chat
            .pending_auto_review_range
            .as_ref()
            .expect("first pending queued");
        assert_eq!(pending.base.id(), first_base.id());

        // Second skip while review still running
        chat.auto_review_baseline = Some(GhostCommit::new("base-second".to_string(), None));
        chat.turn_had_code_edits = true;
        chat.maybe_trigger_auto_review();

        let pending_after_second = chat
            .pending_auto_review_range
            .as_ref()
            .expect("pending should persist");
        assert_eq!(pending_after_second.base.id(), first_base.id());

        chat.on_background_review_finished(
            PathBuf::from("/tmp/wt"),
            "auto-review-running".to_string(),
            false,
            0,
            None,
            None,
            Some("agent-running".to_string()),
            Some("ghost-running".to_string()),
        );

        assert_eq!(launches.load(Ordering::SeqCst), 1, "collapsed follow-up should run once");
        let running = chat.background_review.as_ref().expect("follow-up running");
        assert_eq!(running.base.as_ref().map(|c| c.id()), Some(first_base.id()));
        assert!(chat.pending_auto_review_range.is_none());
    }

    #[test]
    fn stale_background_review_is_reclaimed() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let launches = Arc::new(AtomicUsize::new(0));
        let launches_clone = launches.clone();
        let _stub = AutoReviewStubGuard::install(move || {
            launches_clone.fetch_add(1, Ordering::SeqCst);
        });

        chat.config.tui.auto_review_enabled = true;
        chat.turn_had_code_edits = true;
        let base = GhostCommit::new("stale-base".to_string(), None);
        let stale_started = Instant::now()
            .checked_sub(Duration::from_secs(400))
            .unwrap_or_else(Instant::now);

        chat.background_review = Some(BackgroundReviewState {
            worktree_path: PathBuf::from("/tmp/wt"),
            branch: "auto-review-running".to_string(),
            agent_id: Some("agent-running".to_string()),
            snapshot: Some("ghost-running".to_string()),
            base: Some(base.clone()),
            last_seen: stale_started,
        });

        chat.maybe_trigger_auto_review();

        assert_eq!(launches.load(Ordering::SeqCst), 1, "stale review should be relaunched");
        let running = chat.background_review.as_ref().expect("reclaimed review running");
        assert_eq!(running.base.as_ref().map(|c| c.id()), Some(base.id()));
        assert!(chat.pending_auto_review_range.is_none());
    }

    #[test]
    fn auto_drive_ctrl_s_overlay_keeps_screen_readable() {
        use crate::test_helpers::AutoContinueModeFixture;
        let _guard = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        harness.auto_drive_activate(
            "write some code",
            false,
            true,
            AutoContinueModeFixture::Immediate,
        );

        harness.open_auto_drive_settings();
        let frame_with_settings = crate::test_helpers::render_chat_widget_to_vt100(&mut harness, 90, 24);
        assert!(frame_with_settings.contains("Auto Drive Settings"));
        assert!(!frame_with_settings.contains('\u{fffd}'));

        harness.close_auto_drive_settings();
        let frame_after_close = crate::test_helpers::render_chat_widget_to_vt100(&mut harness, 90, 24);
        assert!(!frame_after_close.contains("Auto Drive Settings"));
        assert!(!frame_after_close.contains('\u{fffd}'));
    }

    #[test]
    fn slash_command_from_line_parses_prompt_expanding_commands() {
        assert!(matches!(
            ChatWidget::slash_command_from_line("/plan build it"),
            Some(SlashCommand::Plan)
        ));
        assert!(matches!(
            ChatWidget::slash_command_from_line("/code"),
            Some(SlashCommand::Code)
        ));
        assert_eq!(ChatWidget::slash_command_from_line("not-a-command"), None);
    }

    #[test]
    fn plan_multiline_commands_are_not_split() {
        assert!(ChatWidget::multiline_slash_command_requires_split("/auto"));
        assert!(!ChatWidget::multiline_slash_command_requires_split("/plan"));
        assert!(!ChatWidget::multiline_slash_command_requires_split("/solve add context"));
    }

    #[test]
    fn transient_error_sets_reconnect_ui() {
        let _guard = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();

        harness
            .chat()
            .on_error("stream error: retrying 1/5".to_string());

        assert!(harness.chat().reconnect_notice_active);
        harness.chat().clear_reconnecting();
        assert!(!harness.chat().reconnect_notice_active);
    }
    use ratatui::backend::TestBackend;
    use ratatui::text::Line;
    use ratatui::Terminal;
    use std::collections::HashMap;
    use std::time::{Duration, Instant, SystemTime};

    use code_core::protocol::{ReviewFinding, ReviewCodeLocation, ReviewLineRange};

    struct CaptureCommitStubGuard;

    impl CaptureCommitStubGuard {
        fn install<F>(stub: F) -> Self
        where
            F: Fn(&'static str, Option<String>) -> Result<GhostCommit, GitToolingError>
                + Send
                + Sync
                + 'static,
        {
            let mut slot = match CAPTURE_AUTO_TURN_COMMIT_STUB.lock() {
                Ok(guard) => guard,
                Err(poisoned) => poisoned.into_inner(),
            };
            assert!(slot.is_none(), "capture stub already installed");
            *slot = Some(Box::new(stub));
            Self
        }
    }

    impl Drop for CaptureCommitStubGuard {
        fn drop(&mut self) {
            match CAPTURE_AUTO_TURN_COMMIT_STUB.lock() {
                Ok(mut slot) => *slot = None,
                Err(poisoned) => {
                    let mut slot = poisoned.into_inner();
                    *slot = None;
                }
            }
        }
    }

    struct GitDiffStubGuard;

    impl GitDiffStubGuard {
        fn install<F>(stub: F) -> Self
        where
            F: Fn(String, String) -> Result<Vec<String>, String> + Send + Sync + 'static,
        {
            let mut slot = match GIT_DIFF_NAME_ONLY_BETWEEN_STUB.lock() {
                Ok(guard) => guard,
                Err(poisoned) => poisoned.into_inner(),
            };
            assert!(slot.is_none(), "git diff stub already installed");
            *slot = Some(Box::new(stub));
            Self
        }
    }

    impl Drop for GitDiffStubGuard {
        fn drop(&mut self) {
            match GIT_DIFF_NAME_ONLY_BETWEEN_STUB.lock() {
                Ok(mut slot) => *slot = None,
                Err(poisoned) => {
                    let mut slot = poisoned.into_inner();
                    *slot = None;
                }
            }
        }
    }

    fn reset_history(chat: &mut ChatWidget<'_>) {
        #[cfg(any(test, feature = "test-helpers"))]
        println!(
            "reset_history before: len={} test_mode={}",
            chat.history_cells.len(),
            chat.test_mode
        );
        chat.history_cells.clear();
        chat.history_cell_ids.clear();
        chat.history_live_window = None;
        chat.history_frozen_width = 0;
        chat.history_frozen_count = 0;
        chat.history_virtualization_sync_pending.set(false);
        chat.history_state = HistoryState::new();
        chat.history_render.invalidate_all();
        chat.cell_order_seq.clear();
        chat.cell_order_dbg.clear();
        chat.ui_background_seq_counters.clear();
        chat.last_assigned_order = None;
        chat.last_seen_request_index = 0;
        chat.current_request_index = 0;
        chat.internal_seq = 0;
        chat.order_request_bias = 0;
        chat.resume_expected_next_request = None;
        chat.resume_provider_baseline = None;
        chat.synthetic_system_req = None;
        chat.layout.scroll_offset = 0;
        chat.layout.last_max_scroll.set(0);
        chat.layout.last_history_viewport_height.set(0);
        #[cfg(any(test, feature = "test-helpers"))]
        println!("reset_history after: len={}", chat.history_cells.len());
    }

    fn insert_plain_cell(chat: &mut ChatWidget<'_>, lines: &[&str]) {
        use code_core::history::state::{
            InlineSpan,
            MessageLine,
            MessageLineKind,
            PlainMessageKind,
            PlainMessageRole,
            PlainMessageState,
            TextEmphasis,
            TextTone,
        };

        let state = PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: lines
                .iter()
                .map(|text| MessageLine {
                    kind: MessageLineKind::Paragraph,
                    spans: vec![InlineSpan {
                        text: (*text).to_string(),
                        tone: TextTone::Default,
                        emphasis: TextEmphasis::default(),
                        entity: None,
                    }],
                })
                .collect(),
            metadata: None,
        };

        let key = chat.next_internal_key();
        let _ = chat.history_insert_plain_state_with_key(state, key, "test");
    }

    fn make_pending_fix_state(review: ReviewOutputEvent) -> AutoResolveState {
        AutoResolveState {
            prompt: "prompt".to_string(),
            hint: "hint".to_string(),
            metadata: None,
            attempt: 0,
            max_attempts: AUTO_RESOLVE_MAX_REVIEW_ATTEMPTS,
            phase: AutoResolvePhase::PendingFix { review },
            last_review: None,
            last_fix_message: None,
            last_reviewed_commit: None,
            snapshot_epoch: None,
        }
    }

    #[allow(dead_code)]
    fn review_output_with_finding() -> ReviewOutputEvent {
        ReviewOutputEvent {
            findings: vec![ReviewFinding {
                title: "issue".to_string(),
                body: "details".to_string(),
                confidence_score: 0.5,
                priority: 0,
                code_location: ReviewCodeLocation {
                    absolute_file_path: PathBuf::from("src/lib.rs"),
                    line_range: ReviewLineRange { start: 1, end: 1 },
                },
            }],
            overall_correctness: "incorrect".to_string(),
            overall_explanation: "needs fixes".to_string(),
            overall_confidence_score: 0.5,
        }
    }

    #[test]
    fn review_dialog_uncommitted_option_runs_workspace_scope() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.open_review_dialog();
        chat.handle_key_event(KeyEvent::new(KeyCode::Down, KeyModifiers::NONE));
        chat.handle_key_event(KeyEvent::new(KeyCode::Enter, KeyModifiers::NONE));

        let (prompt, hint, preparation_label, metadata, auto_resolve) = harness
            .drain_events()
            .into_iter()
            .find_map(|event| match event {
                AppEvent::RunReviewWithScope {
                    prompt,
                    hint,
                    preparation_label,
                    metadata,
                    auto_resolve,
                } => Some((prompt, hint, preparation_label, metadata, auto_resolve)),
                _ => None,
            })
            .expect("uncommitted preset should dispatch a workspace review");

        assert_eq!(
            prompt,
            "Review the current workspace changes (staged, unstaged, and untracked files) and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string()
        );
        assert_eq!(hint, "current workspace changes");
        assert_eq!(
            preparation_label.as_deref(),
            Some("Preparing code review for current changes")
        );
        assert!(auto_resolve, "auto resolve now defaults to on for workspace reviews");

        let metadata = metadata.expect("workspace scope metadata");
        assert_eq!(metadata.scope.as_deref(), Some("workspace"));
        assert!(metadata.base_branch.is_none());
        assert!(metadata.current_branch.is_none());
    }

    #[test]
    fn esc_router_prioritizes_auto_stop_when_waiting_for_review() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.on_begin_review(false);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoStopActive);
        assert!(!route.allows_double_esc);
    }

    #[test]
    fn esc_router_prioritizes_cli_interrupt_before_agent_cancel() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });
        chat.active_task_ids.insert("turn-1".to_string());
        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
    }

    #[test]
    fn esc_router_cancels_agents_when_only_agents_running() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });
        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
    }

    #[test]
    fn esc_router_skips_auto_review_cancel() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "auto-1".to_string(),
            name: "Auto Review".to_string(),
            status: AgentStatus::Running,
            source_kind: Some(AgentSourceKind::AutoReview),
            batch_id: Some("review-batch".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let route = chat.describe_esc_context();
        assert_ne!(route.intent, EscIntent::CancelAgents);
    }

    #[test]
    fn cancelable_agents_excludes_auto_review_entries() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "auto-1".to_string(),
            name: "Auto Review".to_string(),
            status: AgentStatus::Running,
            source_kind: Some(AgentSourceKind::AutoReview),
            batch_id: Some("review-batch".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Other Agent".to_string(),
            status: AgentStatus::Pending,
            source_kind: None,
            batch_id: Some("work".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let (batches, agents) = chat.collect_cancelable_agents();
        assert_eq!(batches, vec!["work".to_string()]);
        assert!(agents.is_empty(), "batch cancel should cover the non-auto agent");
    }

    #[test]
    fn esc_router_cancels_active_auto_turn_streaming() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.active_task_ids.insert("turn-1".to_string());
        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        assert!(chat.execute_esc_intent(route.intent, esc_event));

        assert!(
            !chat.auto_state.is_active(),
            "Auto Drive should stop after cancelling the active turn",
        );
    }

    #[test]
    fn esc_requires_follow_up_after_canceling_agents() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoStopActive);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.is_active(), "Auto Drive stops before canceling agents");
        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.is_active());
        assert!(chat.has_cancelable_agents());
        assert!(chat.auto_state.last_run_summary.is_none());
    }

    #[test]
    fn cancel_agents_preserves_spinner_for_running_terminal_when_auto_inactive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let terminal_launch = TerminalLaunch {
            id: 42,
            title: "Terminal".to_string(),
            command: vec!["sleep".to_string(), "10".to_string()],
            command_display: "sleep 10".to_string(),
            controller: None,
            auto_close_on_success: false,
            start_running: true,
        };
        chat.terminal_open(&terminal_launch);

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        let mut route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::DismissModal);
        let mut attempts = 0;
        while route.intent == EscIntent::DismissModal && attempts < 3 {
            assert!(chat.execute_esc_intent(
                route.intent,
                KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
            ));
            route = chat.describe_esc_context();
            attempts += 1;
        }

        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(
            route.intent,
            KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
        ));

        assert!(!chat.auto_state.is_active(), "Auto Drive remains inactive");
        assert!(chat.has_cancelable_agents());
        chat.maybe_hide_spinner();
        assert!(
            chat.bottom_pane.is_task_running(),
            "Spinner stays active while agents or terminal work are still running",
        );
    }

    #[test]
    fn esc_cancels_agents_then_command_and_stops_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string(), "hi".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout_offset: 0,
                stderr_offset: 0,
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.is_active(), "Auto Drive should stop after cancelling the command");
        assert!(chat.auto_state.last_run_summary.is_none());

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
    }

    #[allow(dead_code)]
    fn esc_cancels_agents_then_command_without_auto_hint() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_agents.push(AgentInfo {
            id: "agent-1".to_string(),
            name: "Agent 1".to_string(),
            status: AgentStatus::Running,
            source_kind: None,
            batch_id: Some("batch-1".to_string()),
            model: None,
            result: None,
            error: None,
            last_progress: None,
        });

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string(), "hi".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout_offset: 0,
                stderr_offset: 0,
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelAgents);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.has_cancelable_agents());
        assert!(
            chat.bottom_pane.standard_terminal_hint().is_none(),
            "Auto Drive exit hint should not display when Auto Drive is inactive",
        );

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.exec.running_commands.is_empty());
        assert!(!chat.bottom_pane.is_task_running());
    }

    #[test]
    fn auto_disabled_cli_turn_preserves_send_prompt_label() {
        let mut harness = ChatWidgetHarness::new();
        harness.with_chat(|chat| {
            chat.config.auto_drive.coordinator_routing = false;
            chat.auto_state.continue_mode = AutoContinueMode::Immediate;
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.schedule_auto_cli_prompt(0, "echo ready".to_string());
        });

        let (button_label, countdown_override, ctrl_switch_hint, manual_hint_present) =
            harness.with_chat(|chat| {
                let model = chat
                    .bottom_pane
                    .auto_view_model()
                    .expect("auto coordinator view should be active");
                match model {
                    AutoCoordinatorViewModel::Active(active) => (
                        active
                            .button
                            .as_ref()
                            .expect("button expected")
                            .label
                            .clone(),
                        chat.auto_state.countdown_override,
                        active.ctrl_switch_hint.clone(),
                        active.manual_hint.is_some(),
                    ),
                }
            });

        assert!(button_label.starts_with("Send prompt"));
        assert_eq!(countdown_override, None);
        assert_eq!(ctrl_switch_hint.as_str(), "Esc to edit");
        assert!(manual_hint_present);

        harness.with_chat(|chat| {
            chat.auto_submit_prompt();
        });

        let auto_pending = harness.with_chat(|chat| chat.auto_pending_goal_request);
        assert!(!auto_pending);
    }

    #[test]
    fn auto_drive_view_marks_running_when_agents_active() {
        let mut harness = ChatWidgetHarness::new();
        harness.with_chat(|chat| {
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_rebuild_live_ring();
        });

        harness.handle_event(Event {
            id: "turn-1".to_string(),
            event_seq: 0,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Worker".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-1".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                    last_activity_at: None,
                    seconds_since_last_activity: None,
                    source_kind: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        let cli_running = harness.with_chat(|chat| {
            chat
                .bottom_pane
                .auto_view_model()
                .and_then(|model| match model {
                    AutoCoordinatorViewModel::Active(active) => Some(active.cli_running),
                })
                .unwrap_or(false)
        });

        assert!(
            cli_running,
            "auto drive view should treat running agents as active"
        );
    }

    #[test]
    fn auto_drive_error_enters_transient_recovery() {
        let mut harness = ChatWidgetHarness::new();
        harness.with_chat(|chat| {
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_state.on_prompt_ready(true);
            chat.auto_rebuild_live_ring();
        });

        harness.handle_event(Event {
            id: "turn-1".to_string(),
            event_seq: 0,
            msg: EventMsg::Error(ErrorEvent {
                message: "internal error; agent loop died unexpectedly".to_string(),
            }),
            order: None,
        });

        let (still_active, in_recovery) = harness.with_chat(|chat| {
            (chat.auto_state.is_active(), chat.auto_state.in_transient_recovery())
        });
        assert!(
            still_active && in_recovery,
            "auto drive should pause for recovery after an error event"
        );
    }

    #[test]
    fn auto_bootstrap_starts_from_history() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.config.auto_drive.coordinator_routing = false;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
            chat.config.approval_policy = AskForApproval::Never;
        }

        {
            let chat = harness.chat();
            insert_plain_cell(chat, &["User: summarize recent progress"]);
            insert_plain_cell(chat, &["Assistant: Tests are passing, next step pending."]);
            chat.handle_auto_command(Some(String::new()));
        }

        let chat = harness.chat();
        assert!(chat.auto_pending_goal_request);
        assert!(!chat.auto_goal_bootstrap_done);
        assert_eq!(
            chat.auto_state.goal.as_deref(),
            Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER)
        );
        assert!(chat.next_cli_text_format.is_none());
        let pending_prompt = chat
            .auto_state
            .current_cli_prompt
            .as_deref()
            .expect("bootstrap prompt");
        assert!(pending_prompt.trim().is_empty());
    }

    #[test]
    fn auto_bootstrap_updates_goal_after_first_decision() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string());
            chat.auto_goal_bootstrap_done = false;
        }

        {
            let chat = harness.chat();
            chat.auto_handle_decision(
                1,
                AutoCoordinatorStatus::Continue,
                None,
                None,
                Some("Finish migrations".to_string()),
                Some(AutoTurnCliAction {
                    prompt: "echo ready".to_string(),
                    context: None,
                    suppress_ui_context: false,
                }),
                None,
                Vec::new(),
                Vec::new(),
            );
        }

        let chat = harness.chat();
        assert_eq!(chat.auto_state.goal.as_deref(), Some("Finish migrations"));
        assert!(chat.auto_goal_bootstrap_done);
        assert!(!chat.auto_pending_goal_request);
        assert_eq!(chat.auto_state.current_cli_prompt.as_deref(), Some("echo ready"));
    }

    #[test]
    fn auto_card_goal_updates_after_derivation() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string());
            chat.auto_card_start(Some(AUTO_BOOTSTRAP_GOAL_PLACEHOLDER.to_string()));
        }

        {
            let chat = harness.chat();
            chat.auto_handle_decision(
                2,
                AutoCoordinatorStatus::Continue,
                None,
                None,
                Some("Document release tasks".to_string()),
                Some(AutoTurnCliAction {
                    prompt: "echo start".to_string(),
                    context: None,
                    suppress_ui_context: false,
                }),
                None,
                Vec::new(),
                Vec::new(),
            );
        }

        let chat = harness.chat();
        let tracker = chat
            .tools_state
            .auto_drive_tracker
            .as_ref()
            .expect("auto drive tracker should be present");
        assert_eq!(tracker.cell.goal_text(), Some("Document release tasks"));
    }

    #[test]
    fn auto_action_events_land_in_auto_drive_card() {
        let mut harness = ChatWidgetHarness::new();
        let note = "Retrying prompt generation after the previous response was too long to send to the CLI.";

        let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_card_start(Some("Ship feature".to_string()));
        chat.auto_handle_action(note.to_string());

        let tracker = chat
            .tools_state
            .auto_drive_tracker
            .as_ref()
            .expect("auto drive tracker should be present");
        let actions = tracker.cell.action_texts();
        assert!(
            actions.iter().any(|text| text == note),
            "auto drive action card should record retry note"
        );
    }

    #[test]
    fn auto_compacted_history_without_notice_skips_checkpoint_banner() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        let conversation = vec![
            ChatWidget::auto_drive_make_assistant_message("overlong prompt raw output".to_string())
                .expect("assistant message"),
        ];

        chat.auto_handle_compacted_history(std::sync::Arc::from(conversation), false);

        let has_checkpoint = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains(COMPACTION_CHECKPOINT_MESSAGE))
            })
        });

        assert!(
            !has_checkpoint,
            "compaction notice should not be shown when show_notice is false"
        );
    }

    #[test]
    fn auto_card_shows_status_title_in_state_detail() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.auto_state.goal = Some("Ship feature".to_string());
            chat.auto_card_start(Some("Ship feature".to_string()));
        }

        {
            let chat = harness.chat();
            chat.auto_handle_decision(
                3,
                AutoCoordinatorStatus::Continue,
                Some("Drafting fix".to_string()),
                Some("Past work".to_string()),
                None,
                Some(AutoTurnCliAction {
                    prompt: "echo work".to_string(),
                    context: None,
                    suppress_ui_context: false,
                }),
                None,
                Vec::new(),
                Vec::new(),
            );
        }

        let chat = harness.chat();
        let tracker = chat
            .tools_state
            .auto_drive_tracker
            .as_ref()
            .expect("auto drive tracker should be present");
        let actions = tracker.cell.action_texts();
        assert!(actions.iter().any(|text| text == "Status: Drafting fix"));
    }

    #[test]
    fn goal_entry_esc_sequence_preserves_draft_and_summary() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.last_run_summary = Some(AutoRunSummary {
            duration: Duration::from_secs(42),
            turns_completed: 3,
            message: Some("All tasks done.".to_string()),
            goal: Some("Finish feature".to_string()),
        });
        chat.auto_show_goal_entry_panel();
        chat.handle_paste("Suggested goal".to_string());
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::NeedsEnableEditing
        ));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalEnableEdit);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.auto_state.should_show_goal_entry());
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::ArmedForExit
        ));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(!chat.auto_state.should_show_goal_entry());
        assert_eq!(chat.bottom_pane.composer_text(), "Suggested goal");
        assert!(chat.auto_state.last_run_summary.is_some());

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoDismissSummary);
    }

    #[test]
    fn goal_entry_typing_arms_escape_state() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            chat.auto_show_goal_entry_panel();
        }

        harness.send_key(KeyEvent::new(KeyCode::Char('x'), KeyModifiers::NONE));

        let chat = harness.chat();
        assert!(matches!(
            chat.auto_goal_escape_state,
            AutoGoalEscState::NeedsEnableEditing
        ));
        assert_eq!(chat.bottom_pane.composer_text(), "x");
    }

    #[test]
    fn goal_entry_esc_exits_immediately_without_suggestion() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_show_goal_entry_panel();
        assert!(chat.auto_state.should_show_goal_entry());
        assert!(matches!(chat.auto_goal_escape_state, AutoGoalEscState::Inactive));

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));

        assert!(!chat.auto_state.should_show_goal_entry());
        assert_eq!(chat.bottom_pane.composer_text(), "");
    }

    #[test]
    fn esc_unwinds_cli_before_stopping_auto() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        let call_id = ExecCallId("exec-1".to_string());
        chat.exec.running_commands.insert(
            call_id.clone(),
            RunningCommand {
                command: vec!["echo".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout_offset: 0,
                stderr_offset: 0,
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(
            !chat.auto_state.is_active(),
            "Auto Drive now stops immediately after cancelling the CLI task",
        );

        chat.exec.running_commands.clear();
        chat.bottom_pane.set_task_running(false);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
    }

    #[test]
    fn esc_router_cancels_running_task() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.active_task_ids.insert("turn-1".to_string());
        chat.bottom_pane.set_task_running(true);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
    }

    #[test]
    fn esc_cancel_task_while_manual_command_does_not_trigger_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.exec.running_commands.insert(
            ExecCallId("exec-1".to_string()),
            RunningCommand {
                command: vec!["echo".to_string()],
                parsed: Vec::new(),
                history_index: None,
                history_id: None,
                explore_entry: None,
                stdout_offset: 0,
                stderr_offset: 0,
                wait_total: None,
                wait_active: false,
                wait_notes: Vec::new(),
            },
        );
        chat.bottom_pane.set_task_running(true);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::CancelTask);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(
            !chat.auto_state.is_active(),
            "Auto Drive should remain inactive after cancelling manual command",
        );
        assert!(
            chat.auto_state.last_run_summary.is_none(),
            "Cancelling manual command should not create an Auto Drive summary",
        );
    }

    #[test]
    fn esc_router_handles_diff_confirm_prompt() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.diffs.confirm = Some(crate::chatwidget::diff_ui::DiffConfirm {
            text_to_submit: "Please undo".to_string(),
        });

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::DiffConfirm);

        let esc_event = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
        assert!(chat.execute_esc_intent(route.intent, esc_event));
        assert!(chat.diffs.confirm.is_none(), "diff confirm should clear after Esc");
    }

    #[test]
    fn esc_router_handles_agents_terminal_overlay() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.agents_terminal.active = true;
        chat.agents_terminal.focus_detail();

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AgentsTerminal);
    }

    #[test]
    fn esc_router_clears_manual_entry_input() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_show_goal_entry_panel();
        assert!(chat.auto_state.should_show_goal_entry());
        chat.bottom_pane.insert_str("draft goal");

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::AutoGoalExitPreserveDraft);
    }

    #[test]
    fn esc_router_defaults_to_show_hint_when_idle() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let route = chat.describe_esc_context();
        assert_eq!(route.intent, EscIntent::ShowUndoHint);
        assert!(route.allows_double_esc);
    }

    #[test]
    fn reasoning_collapse_hides_intermediate_titles_in_consecutive_runs() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.show_reasoning = false;

        let agent_cell = history_cell::AgentRunCell::new("Batch".to_string());
        chat.history_push(agent_cell);

        let reasoning_one = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("First reasoning".to_string())],
            Some("r1".to_string()),
        );
        let reasoning_two = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("Second reasoning".to_string())],
            Some("r2".to_string()),
        );

        chat.history_push(reasoning_one);
        chat.history_push(reasoning_two);

        chat.refresh_reasoning_collapsed_visibility();

        let reasoning_cells: Vec<&history_cell::CollapsibleReasoningCell> = chat
            .history_cells
            .iter()
            .filter_map(|cell| {
                cell.as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            })
            .collect();

        assert_eq!(reasoning_cells.len(), 2, "expected exactly two reasoning cells");

        assert!(
            reasoning_cells[0].display_lines().is_empty(),
            "intermediate reasoning should hide when collapsed after agent anchor",
        );
        assert!(
            !reasoning_cells[1].display_lines().is_empty(),
            "last reasoning should remain visible",
        );
    }

    #[test]
    fn reasoning_collapse_applies_without_anchor_cells() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.show_reasoning = false;

        let reasoning_one = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("First reasoning".to_string())],
            Some("r1".to_string()),
        );
        let reasoning_two = history_cell::CollapsibleReasoningCell::new_with_id(
            vec![Line::from("Second reasoning".to_string())],
            Some("r2".to_string()),
        );

        chat.history_push(reasoning_one);
        chat.history_push(reasoning_two);

        chat.refresh_reasoning_collapsed_visibility();

        let reasoning_cells: Vec<&history_cell::CollapsibleReasoningCell> = chat
            .history_cells
            .iter()
            .filter_map(|cell| {
                cell.as_any()
                    .downcast_ref::<history_cell::CollapsibleReasoningCell>()
            })
            .collect();

        assert_eq!(reasoning_cells.len(), 2, "expected exactly two reasoning cells");

        assert!(
            reasoning_cells[0].display_lines().is_empty(),
            "intermediate reasoning should hide when collapsed without an anchor",
        );
        assert!(
            !reasoning_cells[1].display_lines().is_empty(),
            "last reasoning should remain visible",
        );
    }

    #[test]
    fn auto_drive_stays_paused_while_auto_resolve_pending_fix() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);
        chat.pending_turn_descriptor = None;
        chat.pending_auto_turn_config = None;
        chat.auto_resolve_state = Some(make_pending_fix_state(ReviewOutputEvent::default()));

        chat.auto_on_assistant_final();

        // With cloud-gpt-5.1-codex-max gated off, the review request is still queued but
        // may be processed synchronously; ensure the review slot was populated.
        if chat.auto_state.awaiting_review() {
            // Review remains pending; nothing else to assert.
        } else {
            assert!(chat.auto_state.current_cli_prompt.is_some());
        }
        assert!(!chat.auto_state.is_waiting_for_response());
    }

    #[test]
    fn auto_review_skip_resumes_auto_drive() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.set_waiting_for_response(true);
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review(), "post-turn review should be pending");

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        assert!(
            !chat.auto_state.awaiting_review(),
            "auto drive should clear waiting flag after skipped review"
        );

        let skip_banner = "Auto review skipped: no file changes detected this turn.";
        let skip_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains(skip_banner))
            })
        });
        assert!(skip_present, "skip banner should appear in history");

        assert!(
            !chat.auto_state.is_waiting_for_response(),
            "auto drive should resume conversation after skipped review"
        );
    }

    #[test]
    fn auto_review_skip_stays_blocked_when_auto_resolve_pending() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();
        chat.auto_state.on_complete_review();
        chat.auto_state.set_waiting_for_response(true);

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        chat.auto_resolve_state = Some(make_pending_fix_state(ReviewOutputEvent::default()));

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review(), "auto-resolve should block resume before skip");

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        assert!(
            chat.auto_state.awaiting_review(),
            "auto drive should remain waiting when auto-resolve blocks"
        );
        assert!(
            !chat.auto_state.is_waiting_for_response(),
            "skip should not resume coordinator when auto-resolve blocks"
        );
    }

    #[test]
    fn auto_resolve_limit_zero_runs_single_fix_cycle() {
        let _runtime_guard = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.review_auto_resolve = true;
        chat.config.auto_drive.auto_resolve_review_attempts =
            AutoResolveAttemptLimit::try_new(0).unwrap();

        chat.start_review_with_scope(
            "Review workspace".to_string(),
            "workspace".to_string(),
            Some("Preparing code review request...".to_string()),
            None,
            true,
        );

        let state = chat
            .auto_resolve_state
            .as_ref()
            .expect("limit 0 should still initialize auto-resolve state");
        assert_eq!(state.max_attempts, 0);

        chat.auto_resolve_handle_review_enter();

        let review = ReviewOutputEvent {
            findings: vec![ReviewFinding {
                title: "issue".to_string(),
                body: "details".to_string(),
                confidence_score: 0.6,
                priority: 1,
                code_location: ReviewCodeLocation {
                    absolute_file_path: PathBuf::from("src/lib.rs"),
                    line_range: ReviewLineRange { start: 1, end: 1 },
                },
            }],
            overall_correctness: "incorrect".to_string(),
            overall_explanation: "needs follow up".to_string(),
            overall_confidence_score: 0.6,
        };

        chat.auto_resolve_handle_review_exit(Some(review.clone()));
        assert!(
            matches!(
                chat.auto_resolve_state
                    .as_ref()
                    .map(|state| &state.phase),
                Some(AutoResolvePhase::PendingFix { .. })
            ),
            "limit 0 should still request an automated fix"
        );

        chat.auto_resolve_on_task_complete(Some("fix applied".to_string()));
        assert!(
            matches!(
                chat.auto_resolve_state
                    .as_ref()
                    .map(|state| &state.phase),
                Some(AutoResolvePhase::AwaitingFix { .. })
            ),
            "auto-resolve should wait for judge after fix"
        );

        chat.auto_resolve_on_task_complete(Some("ready for judge".to_string()));
        assert!(
            matches!(
                chat.auto_resolve_state
                    .as_ref()
                    .map(|state| &state.phase),
                Some(AutoResolvePhase::AwaitingJudge { .. })
            ),
            "auto-resolve should request a status check"
        );

        chat.auto_resolve_process_judge(
            review,
            r#"{"status":"review_again","rationale":"double-check"}"#.to_string(),
        );

        assert!(
            chat.auto_resolve_state.is_none(),
            "automation should halt after judge when limit is zero"
        );

        let attempts_string_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains("attempt 1 of 0"))
            })
        });
        assert!(
            !attempts_string_present,
            "history should not mention impossible attempt counts"
        );
    }

    #[test]
    fn auto_resolve_limit_one_stops_after_single_retry() {
        let _runtime_guard = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.config.tui.review_auto_resolve = true;
        chat.config.auto_drive.auto_resolve_review_attempts =
            AutoResolveAttemptLimit::try_new(1).unwrap();

        chat.start_review_with_scope(
            "Review workspace".to_string(),
            "workspace".to_string(),
            Some("Preparing code review request...".to_string()),
            None,
            true,
        );

        assert_eq!(
            chat.auto_resolve_state.as_ref().map(|state| state.max_attempts),
            Some(1),
            "auto-resolve state should honor configured limit"
        );

        chat.auto_resolve_handle_review_enter();

        let review = ReviewOutputEvent {
            findings: vec![ReviewFinding {
                title: "issue".to_string(),
                body: "details".to_string(),
                confidence_score: 0.6,
                priority: 1,
                code_location: ReviewCodeLocation {
                    absolute_file_path: PathBuf::from("src/lib.rs"),
                    line_range: ReviewLineRange { start: 1, end: 1 },
                },
            }],
            overall_correctness: "incorrect".to_string(),
            overall_explanation: "needs follow up".to_string(),
            overall_confidence_score: 0.6,
        };

        chat.auto_resolve_handle_review_exit(Some(review.clone()));
        assert!(
            matches!(
                chat.auto_resolve_state.as_ref().map(|state| &state.phase),
                Some(AutoResolvePhase::PendingFix { .. })
            ),
            "auto-resolve should request a fix after first findings"
        );

        chat.auto_resolve_on_task_complete(Some("fix applied".to_string()));
        chat.auto_resolve_process_judge(
            review.clone(),
            r#"{"status":"review_again","rationale":"double-check"}"#.to_string(),
        );

        let state = chat
            .auto_resolve_state
            .as_ref()
            .expect("limit 1 should schedule a single re-review");
        assert!(matches!(state.phase, AutoResolvePhase::WaitingForReview));

        chat.auto_resolve_handle_review_enter();
        chat.auto_resolve_handle_review_exit(Some(review.clone()));

        assert!(
            chat.auto_resolve_state.is_none(),
            "automation should halt after completing the allowed re-review"
        );

        let mut history_strings = Vec::new();
        for cell in &chat.history_cells {
            for line in cell.display_lines_trimmed() {
                for span in &line.spans {
                    history_strings.push(span.content.to_string());
                }
            }
        }

        let attempt_limit_notice_present = history_strings
            .iter()
            .any(|line| line.contains("attempt limit") && line.contains("reached"));
        assert!(
            attempt_limit_notice_present,
            "user should be notified when the attempt limit stops automation"
        );

        assert!(
            history_strings
                .iter()
                .all(|line| !line.contains("attempt 1 of 0")),
            "no messaging should reference impossible attempt counts"
        );
    }

    #[test]
    fn auto_handle_decision_launches_cli_agents_and_review() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;

        chat.auto_handle_decision(
            4,
            AutoCoordinatorStatus::Continue,
            Some("Running unit tests".to_string()),
            Some("Finished setup".to_string()),
            Some("Refine goal".to_string()),
            Some(AutoTurnCliAction {
                prompt: "Run cargo test".to_string(),
                context: Some("use --all-features".to_string()),
                suppress_ui_context: false,
            }),
            Some(AutoTurnAgentsTiming::Parallel),
            vec![AutoTurnAgentsAction {
                prompt: "Draft alternative fix".to_string(),
                context: None,
                write: false,
                write_requested: Some(false),
                models: None,
            }],
            Vec::new(),
        );

        assert_eq!(
            chat.auto_state.current_cli_prompt.as_deref(),
            Some("Run cargo test")
        );
        assert!(!chat.auto_state.awaiting_review());
        assert_eq!(chat.auto_state.pending_agent_actions.len(), 1);
        assert_eq!(
            chat.auto_state.pending_agent_timing,
            Some(AutoTurnAgentsTiming::Parallel)
        );
        let action = &chat.auto_state.pending_agent_actions[0];
        assert_eq!(action.prompt, "Draft alternative fix");
        assert!(action.write);

        let notice = "Auto Drive enabled write mode";
        let write_notice_present = chat
            .history_cells
            .iter()
            .any(|cell| {
                cell.display_lines_trimmed().iter().any(|line| {
                    line.spans
                        .iter()
                        .any(|span| span.content.contains(notice))
                })
            });
        assert!(write_notice_present);
    }

    #[test]
    fn coordinator_router_emits_notice_for_status_question() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
        }

        let baseline_notice_count = {
            let chat = harness.chat();
            chat.history_cells
                .iter()
                .filter(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .count()
        };

        {
            let chat = harness.chat();
            chat.auto_handle_user_reply(
                Some("Two active agents reporting steady progress.".to_string()),
                None,
            );
        }

        let notice_count = {
            let chat = harness.chat();
            chat.history_cells
                .iter()
                .filter(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .count()
        };
        assert!(notice_count > baseline_notice_count);

        let header_span = {
            let chat = harness.chat();
            let notice_cell = chat
                .history_cells
                .iter()
                .rev()
                .find(|cell| matches!(cell.kind(), HistoryCellType::Notice))
                .expect("notice cell");
            let lines = notice_cell.display_lines_trimmed();
            assert!(!lines.is_empty());
            lines
                .first()
                .and_then(|line| line.spans.first())
                .map(|span| span.content.to_string())
                .unwrap_or_default()
        };
        assert_eq!(header_span, "AUTO DRIVE RESPONSE");
    }

    #[test]
    fn coordinator_router_injects_cli_for_plan_requests() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
            chat.config.sandbox_policy = SandboxPolicy::DangerFullAccess;
        }

        harness.drain_events();

        {
            let chat = harness.chat();
            chat.auto_handle_user_reply(None, Some("/plan".to_string()));
        }

        let events = harness.drain_events();
        let (command, payload) = events
            .iter()
            .find_map(|event| match event {
                AppEvent::DispatchCommand(cmd, payload) => Some((cmd, payload.clone())),
                _ => None,
            })
            .expect("dispatch for /plan");
        assert_eq!(*command, SlashCommand::Auto);
        assert!(payload.contains("/plan"), "payload={payload}");
    }

    #[test]
    fn coordinator_router_bypasses_slash_commands() {
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
        chat.auto_state.set_phase(AutoRunPhase::Active);
            chat.config.auto_drive.coordinator_routing = true;
        }

        harness.drain_events();
        {
            let chat = harness.chat();
            chat.submit_user_message(UserMessage::from("/status".to_string()));
        }

        let events = harness.drain_events();
        assert!(
            events.iter().any(|event| matches!(event, AppEvent::DispatchCommand(_, _))
                || matches!(event, AppEvent::CodexOp(_))),
            "slash command should follow existing dispatch path"
        );
    }

    #[test]
    fn build_turn_message_includes_agent_guidance() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        chat.auto_state.subagents_enabled = true;
        chat.auto_state.pending_agent_actions = vec![AutoTurnAgentsAction {
            prompt: "Draft alternative fix".to_string(),
            context: Some("Focus on parser module".to_string()),
            write: false,
            write_requested: Some(false),
            models: Some(vec![
                "claude-sonnet-4.5".to_string(),
                "gemini-3-pro".to_string(),
            ]),
        }];
        chat.auto_state.pending_agent_timing = Some(AutoTurnAgentsTiming::Blocking);

        chat.auto_state.current_cli_context = Some("Workspace root: /tmp".to_string());

        let message = chat
            .build_auto_turn_message("Run diagnostics")
            .expect("message");
        assert!(message.contains("Workspace root: /tmp"));
        assert!(message.contains("Run diagnostics"));
        assert!(message.contains("Please run agent.create"));
        assert!(message.contains("write: false"));
        assert!(message.contains("Models: [claude-sonnet-4.5, gemini-3-pro]"));
        assert!(message.contains("Draft alternative fix"));
        assert!(message.contains("Focus on parser module"));
        assert!(message.contains("agent.wait"));
        assert!(message.contains("Timing (blocking)"));
        assert!(message.contains("Launch these agents first"));
        assert!(!message.contains("agent {\"action\""), "message should not include raw agent JSON");
    }

    #[test]
    fn task_complete_triggers_review_when_waiting_flag_set() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();

        let _stub_lock = AUTO_STUB_LOCK.lock().unwrap();

        chat.auto_state.set_phase(AutoRunPhase::Active);
        chat.auto_state.review_enabled = true;
        chat.auto_state.on_prompt_submitted();

        let turn_config = TurnConfig {
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            text_format_override: None,
        };
        chat.pending_auto_turn_config = Some(turn_config.clone());
        chat.pending_turn_descriptor = Some(TurnDescriptor {
            mode: TurnMode::Normal,
            read_only: false,
            complexity: Some(TurnComplexity::Low),
            agent_preferences: None,
            review_strategy: None,
            text_format_override: None,
        });

        let base_id = "base-commit".to_string();
        let final_id = "final-commit".to_string();

        chat.auto_turn_review_state = Some(AutoTurnReviewState {
            base_commit: Some(GhostCommit::new(base_id.clone(), None)),
        });

        let base_for_capture = base_id.clone();
        let final_for_capture = final_id.clone();
        let _capture_guard = CaptureCommitStubGuard::install(move |message, parent| {
            assert_eq!(message, "auto turn change snapshot");
            assert_eq!(parent.as_deref(), Some(base_for_capture.as_str()));
            Ok(GhostCommit::new(final_for_capture.clone(), parent))
        });

        let base_for_diff = base_id.clone();
        let final_for_diff = final_id.clone();
        let _diff_guard = GitDiffStubGuard::install(move |base, head| {
            assert_eq!(base, base_for_diff);
            assert_eq!(head, final_for_diff);
            Ok(Vec::new())
        });

        chat.auto_on_assistant_final();
        assert!(chat.auto_state.awaiting_review());

        let descriptor_snapshot = chat.pending_turn_descriptor.clone();
        chat.auto_handle_post_turn_review(turn_config.clone(), descriptor_snapshot.as_ref());

        chat.handle_code_event(Event {
            id: "turn".to_string(),
            event_seq: 42,
            msg: EventMsg::TaskComplete(TaskCompleteEvent {
                last_agent_message: None,
            }),
            order: None,
        });

        assert!(
            !chat.auto_state.awaiting_review(),
            "waiting flag should clear after TaskComplete launches skip review"
        );

        let skip_banner = "Auto review skipped: no file changes detected this turn.";
        let skip_present = chat.history_cells.iter().any(|cell| {
            cell.display_lines_trimmed().iter().any(|line| {
                line.spans
                    .iter()
                    .any(|span| span.content.contains(skip_banner))
            })
        });
        assert!(skip_present, "skip banner should appear after review skip");
    }

    #[test]
    fn finalize_explore_updates_even_with_stale_index() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let call_id = "call-explore".to_string();
        let order = OrderMeta {
            request_ordinal: 1,
            output_index: Some(0),
            sequence_number: Some(0),
        };

        chat.handle_code_event(Event {
            id: call_id.clone(),
            event_seq: 0,
            msg: EventMsg::ExecCommandBegin(ExecCommandBeginEvent {
                call_id: call_id.clone(),
                command: vec!["bash".into(), "-lc".into(), "cat foo.txt".into()],
                cwd: std::env::temp_dir(),
                parsed_cmd: vec![ParsedCommand::Read {
                    cmd: "cat foo.txt".to_string(),
                    name: "foo.txt".to_string(),
                }],
            }),
            order: Some(order.clone()),
        });

        let exec_call_id = ExecCallId(call_id.clone());
        let running = chat
            .exec
            .running_commands
            .get_mut(&exec_call_id)
            .expect("explore command should be tracked");
        let (agg_idx, entry_idx) = running
            .explore_entry
            .expect("read command should register an explore entry");

        // Simulate an out-of-date index so finalize must recover by searching.
        running.explore_entry = Some((usize::MAX, entry_idx));
        chat.exec.running_explore_agg_index = Some(usize::MAX);

        chat.finalize_all_running_due_to_answer();

        let cell = chat.history_cells[agg_idx]
            .as_any()
            .downcast_ref::<ExploreAggregationCell>()
            .expect("explore aggregation cell should remain present");
        let entry = cell
            .record()
            .entries
            .get(entry_idx)
            .expect("entry index should still be valid");
        assert!(
            !matches!(entry.status, history_cell::ExploreEntryStatus::Running),
            "explore entry should not remain running after finalize_all_running_due_to_answer"
        );
        assert!(
            !chat.exec.running_commands.contains_key(&exec_call_id),
            "finalization should clear the running command"
        );
    }

    #[test]
    fn ordering_keeps_new_answers_after_prior_backgrounds() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;
        chat.current_request_index = 1;
        chat.internal_seq = 0;

        chat.push_background_tail("background-one".to_string());
        chat.push_background_tail("background-two".to_string());

        assert_eq!(chat.history_cells.len(), 2, "expected two background cells");

        let answer_id = "answer-turn-1";
        let seeded_key = OrderKey {
            req: 1,
            out: 1,
            seq: 0,
        };
        chat.seed_stream_order_key(StreamKind::Answer, answer_id, seeded_key);

        let response_text = "assistant-response";
        chat.insert_final_answer_with_id(
            Some(answer_id.to_string()),
            vec![Line::from(response_text)],
            response_text.to_string(),
        );

        assert_eq!(chat.history_cells.len(), 3, "expected assistant cell to be added");

        let tail_kinds: Vec<HistoryCellType> = chat
            .history_cells
            .iter()
            .map(|cell| cell.kind())
            .collect();

        let len = tail_kinds.len();
        assert_eq!(
            &tail_kinds[len - 3..],
            &[
                HistoryCellType::BackgroundEvent,
                HistoryCellType::BackgroundEvent,
                HistoryCellType::Assistant,
            ],
            "assistant output should appear after existing background cells",
        );
    }

    #[test]
    fn final_answer_clears_spinner_when_agent_never_reports_terminal_status() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let turn_id = "turn-1".to_string();

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 1,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                    last_activity_at: None,
                    seconds_since_last_activity: None,
                    source_kind: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });
        assert!(
            chat.bottom_pane.is_task_running(),
            "spinner should remain active while the agent reports running"
        );

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 2,
            msg: EventMsg::AgentMessage(AgentMessageEvent {
                message: "Completed todo items.".to_string(),
            }),
            order: None,
        });
        assert!(
            chat.bottom_pane.is_task_running(),
            "spinner should remain active after an assistant message until TaskComplete"
        );

        assert_eq!(chat.overall_task_status, "running".to_string());

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 3,
            msg: EventMsg::TaskComplete(TaskCompleteEvent {
                last_agent_message: None,
            }),
            order: None,
        });

        assert!(
            !chat.bottom_pane.is_task_running(),
            "spinner should clear on TaskComplete even when agent runtime is missing"
        );

        assert_eq!(chat.overall_task_status, "complete".to_string());

        assert!(
            chat
                .agent_runtime
                .values()
                .all(|rt| rt.completed_at.is_none()),
            "runtime should remain incomplete until backend reports a terminal status"
        );

        assert!(
            chat
                .active_agents
                .iter()
                .all(|agent| !matches!(agent.status, AgentStatus::Pending | AgentStatus::Running)),
            "agents should be forced into a terminal status after the answer completes"
        );
    }

    #[test]
    fn spinner_rearms_when_late_agent_update_reports_running() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let turn_id = "turn-1".to_string();

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 1,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                    last_activity_at: None,
                    seconds_since_last_activity: None,
                    source_kind: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        assert!(chat.bottom_pane.is_task_running(), "spinner should be running initially");

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 2,
            msg: EventMsg::AgentMessage(AgentMessageEvent {
                message: "Completed todo items.".to_string(),
            }),
            order: None,
        });

        assert!(chat.bottom_pane.is_task_running(), "spinner stays running after assistant message");

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 3,
            msg: EventMsg::TaskComplete(TaskCompleteEvent {
                last_agent_message: None,
            }),
            order: None,
        });

        assert!(
            !chat.bottom_pane.is_task_running(),
            "TaskComplete should clear the spinner"
        );

        chat.handle_code_event(Event {
            id: turn_id.clone(),
            event_seq: 4,
            msg: EventMsg::AgentStatusUpdate(AgentStatusUpdateEvent {
                agents: vec![CoreAgentInfo {
                    id: "agent-1".to_string(),
                    name: "Todo Agent".to_string(),
                    status: "running".to_string(),
                    batch_id: Some("batch-single".to_string()),
                    model: None,
                    last_progress: None,
                    result: None,
                    error: None,
                    elapsed_ms: None,
                    token_count: None,
                    last_activity_at: None,
                    seconds_since_last_activity: None,
                    source_kind: None,
                }],
                context: None,
                task: None,
            }),
            order: None,
        });

        assert!(
            chat.bottom_pane.is_task_running(),
            "late running update should re-enable the spinner"
        );
    }

    #[test]
    fn scrollback_spacer_preserves_top_cell_bottom_line() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        let viewport_height = 6;
        chat.layout.scroll_offset = 2;

        let mut terminal = Terminal::new(TestBackend::new(40, viewport_height)).expect("terminal");
        terminal
            .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
            .expect("draw history");

        let adjusted = chat.history_render.adjust_scroll_to_content(2);
        assert_eq!(adjusted, 1, "scroll origin should step back from spacer row");

        let prefix = chat.history_render.prefix_sums.borrow();
        assert!(!prefix.is_empty(), "prefix sums populated after draw");
        let start_idx = match prefix.binary_search(&adjusted) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        assert_eq!(start_idx, 0, "expected first cell to be visible after adjustment");

        let content_y = prefix[start_idx];
        drop(prefix);
        let skip_top = adjusted.saturating_sub(content_y);
        assert_eq!(skip_top, 1, "should display the second line of the oldest cell");

        let cell = &chat.history_cells[start_idx];
        let lines = cell.display_lines_trimmed();
        let line = lines
            .get(skip_top as usize)
            .expect("line available after scroll adjustment");
        let text: String = line.spans.iter().map(|span| span.content.as_ref()).collect();
        assert_eq!(text.trim(), "old-2");
    }

    #[test]
    fn final_answer_without_task_complete_clears_spinner() {
        let _rt = enter_test_runtime_guard();
        let mut harness = ChatWidgetHarness::new();
        {
            let chat = harness.chat();
            reset_history(chat);
        }

        let turn_id = "turn-1".to_string();
        let order = OrderMeta {
            request_ordinal: 1,
            output_index: Some(0),
            sequence_number: Some(0),
        };

        harness.handle_event(Event {
            id: turn_id.clone(),
            event_seq: 0,
            msg: EventMsg::TaskStarted,
            order: None,
        });

        harness.handle_event(Event {
            id: turn_id.clone(),
            event_seq: 1,
            msg: EventMsg::AgentReasoningDelta(AgentReasoningDeltaEvent {
                delta: "thinking about the change".to_string(),
            }),
            order: Some(order.clone()),
        });

        harness.handle_event(Event {
            id: turn_id.clone(),
            event_seq: 2,
            msg: EventMsg::AgentMessage(AgentMessageEvent {
                message: "All done".to_string(),
            }),
            order: Some(OrderMeta {
                request_ordinal: 1,
                output_index: Some(0),
                sequence_number: Some(1),
            }),
        });

        harness.flush_into_widget();

        assert!(
            !harness.chat().bottom_pane.is_task_running(),
            "spinner should clear after the final answer even when TaskComplete never arrives"
        );
    }

    #[test]
    fn scrollback_spacer_exact_offset_adjusts_to_content() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        let viewport_height = 6;
        chat.layout.scroll_offset = 2;

        {
            let mut terminal =
                Terminal::new(TestBackend::new(40, viewport_height)).expect("terminal");
            terminal
                .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
                .expect("draw history");
        }

        let ranges = chat.history_render.spacing_ranges_for_test();
        let (pos, _) = ranges
            .first()
            .copied()
            .expect("expected a spacer-induced adjustment");
        let adjusted = chat.history_render.adjust_scroll_to_content(pos);
        assert!(
            adjusted < pos,
            "scroll adjustment should reduce the origin when landing on a spacer"
        );
    }

    #[test]
    fn scrollback_top_boundary_retains_oldest_content() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        insert_plain_cell(chat, &["old-1", "old-2"]);
        insert_plain_cell(chat, &["mid-1", "mid-2"]);
        insert_plain_cell(chat, &["new-1", "new-2"]);

        {
            let mut terminal = Terminal::new(TestBackend::new(40, 6)).expect("terminal");
            terminal
                .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
                .expect("draw history");
        }

        let max_scroll = chat.layout.last_max_scroll.get();
        assert!(max_scroll > 0, "expected overflow to produce a positive max scroll");
        chat.layout.scroll_offset = max_scroll;

        let mut terminal = Terminal::new(TestBackend::new(40, 6)).expect("terminal");
        terminal
            .draw(|frame| frame.render_widget_ref(&*chat, frame.area()))
            .expect("draw history at top boundary");

        let max_scroll = chat.layout.last_max_scroll.get();
        let scroll_from_top = max_scroll.saturating_sub(chat.layout.scroll_offset);
        let effective = chat.history_render.adjust_scroll_to_content(scroll_from_top);
        let prefix = chat.history_render.prefix_sums.borrow();
        let mut start_idx = match prefix.binary_search(&effective) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        start_idx = start_idx.min(prefix.len().saturating_sub(1));
        start_idx = start_idx.min(chat.history_cells.len().saturating_sub(1));
        let content_y = prefix[start_idx];
        drop(prefix);

        let skip = effective.saturating_sub(content_y) as usize;
        let cell = &chat.history_cells[start_idx];
        let lines = cell.display_lines_trimmed();
        let target_index = skip.min(lines.len().saturating_sub(1));
        let visible = lines
            .get(target_index)
            .map(|line| {
                line.spans
                    .iter()
                    .map(|span| span.content.as_ref())
                    .collect::<String>()
            })
            .unwrap_or_default();

        assert!(
            visible.contains("old-1"),
            "scrolling to the top should keep the oldest content visible"
        );
    }

    #[test]
    fn ordering_stream_delta_should_follow_existing_background_tail() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;
        chat.push_background_tail("background".to_string());

        let stream_state = AssistantStreamState {
            id: HistoryId::ZERO,
            stream_id: "stream-1".into(),
            preview_markdown: "partial".into(),
            deltas: vec![AssistantStreamDelta {
                delta: "partial".into(),
                sequence: Some(0),
                received_at: SystemTime::now(),
            }],
            citations: vec![],
            metadata: None,
            in_progress: true,
            last_updated_at: SystemTime::now(),
            truncated_prefix_bytes: 0,
        };
        let stream_cell = history_cell::new_streaming_content(stream_state, &chat.config);

        chat.history_insert_with_key_global_tagged(
            Box::new(stream_cell),
            OrderKey {
                req: 1,
                out: 0,
                seq: 0,
            },
            "stream",
            None,
        );

        let kinds: Vec<HistoryCellType> = chat
            .history_cells
            .iter()
            .map(|cell| cell.kind())
            .collect();

        assert_eq!(
            kinds,
            vec![HistoryCellType::BackgroundEvent, HistoryCellType::Assistant],
            "streaming assistant output should append after the existing background tail cell",
        );
    }

    #[test]
    fn ordering_tool_reasoning_explore_should_preserve_arrival_sequence() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        chat.last_seen_request_index = 1;

        let make_plain = |text: &str| PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: text.to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        // Reasoning arrives first with later output index.
        let reasoning_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(2),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("reasoning"), reasoning_key, "reasoning");

        // Explore summary follows immediately afterwards.
        let explore_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(3),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("explore"), explore_key, "explore");

        // Tool run summary arrives last but references an earlier output index.
        let tool_key = ChatWidget::raw_order_key_from_order_meta(&OrderMeta {
            request_ordinal: 1,
            output_index: Some(1),
            sequence_number: Some(0),
        });
        chat.history_insert_plain_state_with_key(make_plain("tool"), tool_key, "tool");

        let labels: Vec<String> = chat
            .history_cells
            .iter()
            .map(|cell| {
                cell.display_lines_trimmed()
                    .first()
                    .map(|line| line.spans.iter().map(|span| span.content.as_ref()).collect())
                    .unwrap_or_default()
            })
            .collect();

        assert_eq!(
            labels,
            vec!["reasoning".to_string(), "explore".to_string(), "tool".to_string()],
            "later inserts with smaller output_index should not leapfrog visible reasoning/explore summaries",
        );
    }

    #[test]
    fn ordering_cross_request_pre_prompt_should_not_prepend_previous_turn() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let make_plain = |text: &str| PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Plain,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: text.to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        chat.history_insert_plain_state_with_key(
            make_plain("req1"),
            OrderKey {
                req: 1,
                out: 0,
                seq: 0,
            },
            "req1",
        );

        chat.last_seen_request_index = 1;
        chat.pending_user_prompts_for_next_turn = 0;

        let key = chat.system_order_key(SystemPlacement::PrePromptInCurrent, None);
        chat.history_insert_plain_state_with_key(make_plain("system"), key, "system");

        let labels: Vec<String> = chat
            .history_cells
            .iter()
            .map(|cell| {
                cell.display_lines_trimmed()
                    .first()
                    .map(|line| line.spans.iter().map(|span| span.content.as_ref()).collect())
                    .unwrap_or_default()
            })
            .collect();

        assert_eq!(
            labels,
            vec!["req1".to_string(), "system".to_string()],
            "pre-prompt system notices for a new request should append after the prior turn rather than prepending it",
        );
    }

    #[test]
    fn resume_ordering_offsets_provider_ordinals() {
        let mut harness = ChatWidgetHarness::new();
        let chat = harness.chat();
        reset_history(chat);

        let make_plain = |id: u64,
                           text: &str,
                           role: PlainMessageRole,
                           kind: PlainMessageKind| -> PlainMessageState {
            PlainMessageState {
                id: HistoryId(id),
                role,
                kind,
                header: None,
                lines: vec![MessageLine {
                    kind: MessageLineKind::Paragraph,
                    spans: vec![InlineSpan {
                        text: text.to_string(),
                        tone: TextTone::Default,
                        emphasis: TextEmphasis::default(),
                        entity: None,
                    }],
                }],
                metadata: None,
            }
        };

        let snapshot = HistorySnapshot {
            records: vec![
                HistoryRecord::PlainMessage(make_plain(
                    1,
                    "user-turn",
                    PlainMessageRole::User,
                    PlainMessageKind::User,
                )),
                HistoryRecord::PlainMessage(make_plain(
                    2,
                    "assistant-turn",
                    PlainMessageRole::Assistant,
                    PlainMessageKind::Assistant,
                )),
            ],
            next_id: 3,
            exec_call_lookup: HashMap::new(),
            tool_call_lookup: HashMap::new(),
            stream_lookup: HashMap::new(),
            order: vec![
                OrderKeySnapshot {
                    req: 5,
                    out: 0,
                    seq: 0,
                },
                OrderKeySnapshot {
                    req: 5,
                    out: 1,
                    seq: 0,
                },
            ],
            order_debug: Vec::new(),
        };

        chat.restore_history_snapshot(&snapshot);

        assert_eq!(
            chat.last_seen_request_index, 5,
            "restoring snapshot should set last_seen_request_index"
        );

        let order_meta = OrderMeta {
            request_ordinal: 0,
            output_index: Some(0),
            sequence_number: Some(0),
        };
        let key = chat.provider_order_key_from_order_meta(&order_meta);
        assert_eq!(
            key.req, 6,
            "resume should bias provider ordinals so new output slots after restored history"
        );

        let new_state = PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::Assistant,
            kind: PlainMessageKind::Assistant,
            header: None,
            lines: vec![MessageLine {
                kind: MessageLineKind::Paragraph,
                spans: vec![InlineSpan {
                    text: "new-assistant".to_string(),
                    tone: TextTone::Default,
                    emphasis: TextEmphasis::default(),
                    entity: None,
                }],
            }],
            metadata: None,
        };

        let pos = chat.history_insert_plain_state_with_key(new_state, key, "resume-order");
        assert_eq!(pos, chat.history_cells.len().saturating_sub(1));

        let inserted_key = chat.cell_order_seq[pos];
        assert_eq!(inserted_key.req, 6);

        let inserted_text: String = chat.history_cells[pos]
            .display_lines_trimmed()
            .iter()
            .flat_map(|line| line.spans.iter().map(|span| span.content.as_ref()))
            .collect();
        assert!(
            inserted_text.contains("new-assistant"),
            "resume insertion should surface the new assistant answer at the tail"
        );
    }



}

fn append_thought_ellipsis(text: &str) -> String {
    let trimmed = text.trim_end();
    if trimmed.ends_with('…') {
        trimmed.to_string()
    } else {
        format!("{trimmed}…")
    }
}

fn extract_latest_bold_title(text: &str) -> Option<String> {
    fn prev_non_ws(text: &str, end: usize) -> Option<char> {
        text[..end].chars().rev().find(|ch| !ch.is_whitespace())
    }

    fn next_non_ws(text: &str, start: usize) -> Option<char> {
        text[start..].chars().find(|ch| !ch.is_whitespace())
    }

    fn normalize_candidate(candidate: &str) -> Option<String> {
        let trimmed = candidate.trim();
        if trimmed.is_empty() {
            return None;
        }
        Some(trimmed.to_string())
    }

    let bytes = text.as_bytes();
    let mut idx = 0usize;
    let mut latest: Option<String> = None;
    let mut open_start: Option<usize> = None;

    while idx + 1 < bytes.len() {
        if bytes[idx] == b'*' && bytes[idx + 1] == b'*' {
            if let Some(start) = open_start {
                let candidate = &text[start..idx];
                let before = prev_non_ws(text, start);
                let after = next_non_ws(text, idx + 2);
                let looks_like_heading = before
                    .map(|ch| matches!(ch, '"' | '\n' | '\r' | ':' | '[' | '{'))
                    .unwrap_or(true)
                    && after
                        .map(|ch| matches!(ch, '"' | '\n' | '\r' | ',' | '}' | ']'))
                        .unwrap_or(true);

                if looks_like_heading {
                    if let Some(clean) = normalize_candidate(candidate) {
                        latest = Some(clean);
                    }
                }
                open_start = None;
                idx += 2;
                continue;
            } else {
                open_start = Some(idx + 2);
                idx += 2;
                continue;
            }
        }
        idx += 1;
    }

    if latest.is_none() {
        if let Some(start) = open_start {
            if let Some(clean) = normalize_candidate(&text[start..]) {
                latest = Some(clean);
            }
        }
    }

    if latest.is_some() {
        return latest;
    }

    for raw_line in text.lines() {
        let trimmed = raw_line.trim();
        if trimmed.is_empty() {
            continue;
        }

        if let Some(title) = heading_from_line(trimmed) {
            latest = Some(title);
        }
    }

    latest
}

fn heading_from_line(line: &str) -> Option<String> {
    let normalized = remove_bullet_prefix(line.trim_start());
    if !normalized.starts_with("**") {
        return None;
    }

    let rest = &normalized[2..];
    let end = rest.find("**");
    let title = match end {
        Some(idx) => &rest[..idx],
        None => rest,
    };

    if title.trim().is_empty() {
        return None;
    }

    Some(title.to_string())
}

fn remove_bullet_prefix(line: &str) -> &str {
    let mut normalized = line;
    for prefix in ["- ", "* ", "\u{2022} "] {
        if normalized.starts_with(prefix) {
            normalized = normalized[prefix.len()..].trim_start();
            break;
        }
    }
    normalized
}

fn strip_role_prefix_if_present(input: &str) -> (&str, bool) {
    const PREFIXES: [&str; 2] = ["Coordinator:", "CLI:"];
    for prefix in PREFIXES {
        if input.len() >= prefix.len() {
            let (head, tail) = input.split_at(prefix.len());
            if head.eq_ignore_ascii_case(prefix) {
                return (tail, true);
            }
        }
    }
    (input, false)
}

impl ChatWidget<'_> {
    fn auto_resolve_enabled(&self) -> bool {
        self.auto_resolve_state.is_some()
    }

    fn configured_auto_resolve_re_reviews(&self) -> u32 {
        self.config
            .auto_drive
            .auto_resolve_review_attempts
            .get()
    }

    fn auto_resolve_clear(&mut self) {
        self.auto_resolve_state = None;
        self.maybe_resume_auto_after_review();
    }

    fn auto_resolve_notice<S: Into<String>>(&mut self, message: S) {
        self.push_background_tail(message.into());
        self.request_redraw();
    }

    fn auto_resolve_commit_sha(&self) -> Option<String> {
        self.auto_resolve_state
            .as_ref()
            .and_then(|state| state.metadata.as_ref())
            .and_then(|metadata| metadata.commit.clone())
    }

    fn auto_resolve_scope(&self) -> Option<String> {
        self.auto_resolve_state
            .as_ref()
            .and_then(|state| state.metadata.as_ref())
            .and_then(|metadata| metadata.scope.clone())
    }

    fn worktree_has_uncommitted_changes(&self) -> Option<bool> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["status", "--short"])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout);
        Some(!stdout.trim().is_empty())
    }

    fn current_head_commit_sha(&self) -> Option<String> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["rev-parse", "HEAD"])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if stdout.is_empty() {
            None
        } else {
            Some(stdout)
        }
    }

    fn commit_subject_for(&self, commit: &str) -> Option<String> {
        let output = Command::new("git")
            .current_dir(&self.config.cwd)
            .args(["show", "-s", "--format=%s", commit])
            .output()
            .ok()?;
        if !output.status.success() {
            return None;
        }
        let stdout = String::from_utf8_lossy(&output.stdout).trim().to_string();
        if stdout.is_empty() {
            None
        } else {
            Some(stdout)
        }
    }

    fn strip_context_sections(text: &str) -> String {
        // Remove any <context>...</context> blocks. If a closing tag is missing,
        // drop everything from the opening tag to the end of the string so we
        // never leak a stray <context> marker back into the next prompt.
        const START: &str = "<context"; // allow attributes or whitespace before '>'
        const END: &str = "</context>";

        let lower = text.to_ascii_lowercase();
        let mut cleaned = String::with_capacity(text.len());
        let mut cursor: usize = 0;

        while let Some(start_rel) = lower[cursor..].find(START) {
            let start = cursor + start_rel;
            cleaned.push_str(&text[cursor..start]);

            // Advance past the opening tag terminator '>' if present; otherwise
            // treat the rest of the string as part of the unclosed context block.
            let after_start = match text[start..].find('>') {
                Some(off) => start + off + 1,
                None => return cleaned, // Unclosed start tag: drop the remainder
            };

            // Look for the matching closing tag. If not found, drop the tail.
            if let Some(end_rel) = lower[after_start..].find(END) {
                let end = after_start + end_rel + END.len();
                cursor = end;
            } else {
                return cleaned;
            }
        }

        // Append any trailing text after the last removed block.
        cleaned.push_str(&text[cursor..]);

        // Clean up any stray closing tags that had no opener.
        if cleaned.contains(END) {
            cleaned = cleaned.replace(END, "");
        }

        cleaned
    }

    fn turn_context_block(&self) -> Option<String> {
        let mut lines: Vec<String> = Vec::new();
        let mut any = false;
        lines.push("<context>".to_string());
        lines.push("Below are the most recent messages related to this code change.".to_string());
        if let Some(user) = self
            .last_user_message
            .as_ref()
            .map(|msg| Self::strip_context_sections(msg))
            .map(|msg| msg.trim().to_string())
            .filter(|msg| !msg.is_empty())
        {
            any = true;
            lines.push(format!("<user>{user}</user>"));
        }
        if let Some(dev) = self
            .last_developer_message
            .as_ref()
            .map(|msg| Self::strip_context_sections(msg))
            .map(|msg| msg.trim().to_string())
            .filter(|msg| !msg.is_empty())
        {
            any = true;
            lines.push(format!("<developer>{dev}</developer>"));
        }
        if let Some(assistant) = self
            .last_assistant_message
            .as_ref()
            .map(|msg| Self::strip_context_sections(msg))
            .map(|msg| msg.trim().to_string())
            .filter(|msg| !msg.is_empty())
        {
            any = true;
            lines.push(format!("<assistant>{assistant}</assistant>"));
        }
        lines.push("</context>".to_string());

        if any {
            Some(lines.join("\n"))
        } else {
            None
        }
    }

    fn auto_resolve_should_block_auto_resume(&self) -> bool {
        match self.auto_resolve_state.as_ref().map(|state| &state.phase) {
            Some(AutoResolvePhase::PendingFix { .. })
            | Some(AutoResolvePhase::AwaitingFix { .. })
            | Some(AutoResolvePhase::AwaitingJudge { .. }) => true,
            Some(AutoResolvePhase::WaitingForReview) => self.is_review_flow_active(),
            None => false,
        }
    }

    fn maybe_resume_auto_after_review(&mut self) {
        if !self.auto_state.is_active() || !self.auto_state.awaiting_review() {
            return;
        }
        if self.is_review_flow_active() || self.auto_resolve_should_block_auto_resume() {
            return;
        }
        self.auto_state.on_complete_review();
        if !self.auto_state.should_bypass_coordinator_next_submit() {
            self.auto_send_conversation();
        }
        self.request_redraw();
    }

    fn auto_resolve_format_findings(review: &ReviewOutputEvent) -> String {
        let mut sections: Vec<String> = Vec::new();
        if !review.findings.is_empty() {
            sections.push(format_review_findings_block(&review.findings, None));
        }
        let explanation = review.overall_explanation.trim();
        if !explanation.is_empty() {
            sections.push(explanation.to_string());
        }
        sections
            .into_iter()
            .map(|s| s.trim().to_string())
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>()
            .join("\n\n")
    }

    fn auto_resolve_handle_review_enter(&mut self) {
        if let Some(state) = self.auto_resolve_state.as_mut() {
            state.phase = AutoResolvePhase::WaitingForReview;
            state.last_review = None;
            state.last_fix_message = None;
        }
    }

    fn auto_resolve_handle_review_exit(&mut self, review_output: Option<ReviewOutputEvent>) {
        if self.auto_resolve_state.is_none() {
            return;
        }

        let notice: Option<String>;
        let mut should_clear = false;
        {
            let state = self.auto_resolve_state.as_mut().unwrap();
            match review_output {
                Some(ref output) => {
                    state.attempt = state.attempt.saturating_add(1);
                    state.last_review = Some(output.clone());
                    state.last_fix_message = None;

                    if output.findings.is_empty() {
                        notice = Some("Auto-resolve: review reported no actionable findings. Exiting.".to_string());
                        should_clear = true;
                    } else if state.max_attempts > 0 && state.attempt > state.max_attempts {
                        let limit = state.max_attempts;
                        notice = Some(match limit {
                            0 => "Auto-resolve: attempt limit is set to 0, so automation stopped after the initial review.".to_string(),
                            1 => "Auto-resolve: reached the review attempt limit (1 allowed review). Handing control back to you.".to_string(),
                            _ => format!(
                                "Auto-resolve: reached the review attempt limit ({limit} allowed reviews). Handing control back to you."
                            ),
                        });
                        should_clear = true;
                    } else {
                        state.phase = AutoResolvePhase::PendingFix {
                            review: output.clone(),
                        };
                        notice = Some("Auto-resolve: review found issues. Preparing follow-up fix request.".to_string());
                    }
                }
                None => {
                    notice = Some(
                        "Auto-resolve: review ended without findings. Please inspect manually.".to_string(),
                    );
                    should_clear = true;
                }
            }
        }

        if should_clear {
            self.auto_resolve_clear();
        }
        if let Some(message) = notice {
            self.auto_resolve_notice(message);
        }
    }

    fn auto_resolve_on_task_complete(&mut self, last_agent_message: Option<String>) {
        let Some(state_snapshot) = self.auto_resolve_state.clone() else {
            return;
        };

        match state_snapshot.phase {
            AutoResolvePhase::PendingFix { review } => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.phase = AutoResolvePhase::AwaitingFix {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_fix(&review);
            }
            AutoResolvePhase::AwaitingFix { review } => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.last_fix_message = last_agent_message.clone();
                    state.phase = AutoResolvePhase::AwaitingJudge {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_judge(&review, last_agent_message);
            }
            AutoResolvePhase::AwaitingJudge { review } => {
                let message = last_agent_message.unwrap_or_default();
                self.auto_resolve_process_judge(review, message);
            }
            AutoResolvePhase::WaitingForReview => {}
        }
    }

    fn dispatch_auto_fix(&mut self, review: &ReviewOutputEvent) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "You are continuing an automated /review resolution loop. Review the listed findings and determine whether they represent real issues introduced by our changes. If they are, apply the necessary fixes and resolve any similar issues you can identify before responding."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nFindings:\n");
            preface.push_str(&summary);
        }
        if self
            .auto_resolve_scope()
            .as_deref()
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = self.auto_resolve_commit_sha() {
                let short_sha: String = commit.chars().take(7).collect();
                preface.push_str("\n\nCommit under review: ");
                preface.push_str(&commit);
                preface.push_str(" (short SHA ");
                preface.push_str(&short_sha);
                preface.push_str(
                    "). If you make changes to address these findings, amend this commit before responding so the review target reflects your fixes.",
                );
            }
        }

        // Pass the full structured output so the resolving agent sees file paths and line ranges.
        if let Ok(raw_json) = serde_json::to_string_pretty(review) {
            preface.push_str("\n\nFull review JSON (includes file paths and line ranges):\n");
            preface.push_str(&raw_json);
        }

        if let Some(context) = self.turn_context_block() {
            preface.push_str("\n\n");
            preface.push_str(&context);
        }

        self.auto_resolve_notice("Auto-resolve: asking the agent to verify and address the review findings.");
        self.submit_hidden_text_message_with_preface(
            "Is this a real issue introduced by our changes? If so, please fix and resolve all similar issues.".to_string(),
            preface,
        );
    }

    fn dispatch_auto_judge(&mut self, review: &ReviewOutputEvent, fix_message: Option<String>) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "You are evaluating whether the latest fixes resolved the findings from `/review`. Respond with a strict JSON object containing `status` and optional `rationale`. Valid `status` values: `review_again`, `no_issue`, `continue_fix`. Do not include any additional text before or after the JSON."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nOriginal findings:\n");
            preface.push_str(&summary);
        }
        if let Some(fix) = fix_message.as_ref().map(|s| s.trim()).filter(|s| !s.is_empty()) {
            preface.push_str("\n\nLatest agent response:\n");
            preface.push_str(fix);
        }
        preface.push_str("\n\nReturn JSON: {\"status\": \"...\", \"rationale\": \"optional explanation\"}.");
        if self
            .auto_resolve_scope()
            .as_deref()
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = self.auto_resolve_commit_sha() {
                let short_sha: String = commit.chars().take(7).collect();
                preface.push_str("\n\nCommit under review: ");
                preface.push_str(&commit);
                preface.push_str(" (short SHA ");
                preface.push_str(&short_sha);
                preface.push_str(
                    "). Confirm that any fixes have been committed (amend the commit if necessary) before returning `no_issue`.",
                );
            }
        }

        if let Some(context) = self.turn_context_block() {
            preface.push_str("\n\n");
            preface.push_str(&context);
        }

        self.auto_resolve_notice("Auto-resolve: requesting status JSON from the agent.");
        self.submit_hidden_text_message_with_preface("Auto-resolve status check".to_string(), preface);
    }

    fn dispatch_auto_continue(&mut self, review: &ReviewOutputEvent) {
        let summary = Self::auto_resolve_format_findings(review);
        let mut preface = String::from(
            "The previous status check indicated more work is required on the review findings. Continue addressing the remaining issues before responding."
        );
        if !summary.is_empty() {
            preface.push_str("\n\nOutstanding findings:\n");
            preface.push_str(&summary);
        }
        if let Some(context) = self.turn_context_block() {
            preface.push_str("\n\n");
            preface.push_str(&context);
        }
        self.auto_resolve_notice("Auto-resolve: asking the agent to continue working on the findings.");
        self.submit_hidden_text_message_with_preface("Please continue".to_string(), preface);
    }

    fn restart_auto_resolve_review(&mut self) {
        let Some(state_snapshot) = self.auto_resolve_state.clone() else {
            return;
        };
        let next_attempt = state_snapshot.attempt.saturating_add(1);
        let re_reviews_allowed = state_snapshot.max_attempts;
        let total_allowed = re_reviews_allowed.saturating_add(1);
        let attempt_label = if re_reviews_allowed == 0 {
            "attempt limit reached".to_string()
        } else {
            format!("attempt {next_attempt} of {total_allowed}")
        };
        let prep_label = format!("Preparing follow-up code review ({attempt_label})");
        let mut base_prompt = state_snapshot.prompt.trim_end().to_string();
        if let Some(idx) = base_prompt.find(AUTO_RESOLVE_REVIEW_FOLLOWUP) {
            base_prompt = base_prompt[..idx].trim_end().to_string();
        }

        let mut next_hint = state_snapshot.hint.clone();
        let mut next_metadata = state_snapshot.metadata.clone();

        if next_metadata
            .as_ref()
            .and_then(|meta| meta.scope.as_ref())
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(new_commit) = self.current_head_commit_sha() {
                let short_sha: String = new_commit.chars().take(7).collect();
                let subject = self.commit_subject_for(&new_commit);
                base_prompt = if let Some(subject) = subject {
                    format!(
                        "Review the code changes introduced by commit {new_commit} (\"{subject}\"). Provide prioritized, actionable findings."
                    )
                } else {
                    format!(
                        "Review the code changes introduced by commit {new_commit}. Provide prioritized, actionable findings."
                    )
                };
                next_hint = format!("commit {short_sha}");
                if let Some(meta) = next_metadata.as_mut() {
                    meta.commit = Some(new_commit.clone());
                }
            }
        }

        let mut continued_prompt = base_prompt.clone();
        if let Some(last_review) = state_snapshot.last_review.as_ref() {
            let recap = Self::auto_resolve_format_findings(last_review);
            if !recap.is_empty() {
                continued_prompt.push_str("\n\nPreviously reported findings to re-validate:\n");
                continued_prompt.push_str(&recap);
            }
        }
        if state_snapshot
            .metadata
            .as_ref()
            .and_then(|meta| meta.scope.as_ref())
            .is_some_and(|scope| scope.eq_ignore_ascii_case("commit"))
        {
            if let Some(commit) = state_snapshot
                .metadata
                .as_ref()
                .and_then(|meta| meta.commit.clone())
            {
                if let Some(true) = self.worktree_has_uncommitted_changes() {
                    continued_prompt.push_str("\n\nNote: there are uncommitted changes in the working tree since commit ");
                    continued_prompt.push_str(&commit);
                    continued_prompt.push_str(
                        ". Ensure the review covers the updated workspace rather than only the original commit snapshot.",
                    );
                }
            }
        }
        continued_prompt.push_str("\n\n");
        continued_prompt.push_str(AUTO_RESOLVE_REVIEW_FOLLOWUP);
        self.begin_review(
            continued_prompt,
            next_hint.clone(),
            Some(prep_label),
            next_metadata.clone(),
        );
        if let Some(state) = self.auto_resolve_state.as_mut() {
            state.phase = AutoResolvePhase::WaitingForReview;
            state.prompt = base_prompt;
            state.hint = next_hint;
            state.metadata = next_metadata;
            state.last_review = None;
            state.last_fix_message = None;
        }
    }

    fn auto_resolve_process_judge(&mut self, review: ReviewOutputEvent, message: String) {
        let trimmed = message.trim();
        let Some(decision) = Self::auto_resolve_parse_decision(trimmed) else {
            self.auto_resolve_notice("Auto-resolve: expected JSON status but received something else. Stopping automation.");
            self.auto_resolve_clear();
            return;
        };

        let status = decision.status.to_ascii_lowercase();
        let rationale = decision.rationale.unwrap_or_default();

        match status.as_str() {
            "no_issue" => {
                let rationale_text = rationale.trim();
                let attempt_limit_reached = self
                    .auto_resolve_state
                    .as_ref()
                    .is_some_and(|state| {
                        let allowed = state.max_attempts.saturating_add(1);
                        state.attempt >= allowed
                    });

                if attempt_limit_reached {
                    let limit = self
                        .auto_resolve_state
                        .as_ref()
                        .map(|state| state.max_attempts)
                        .unwrap_or(0);
                    let message = if rationale_text.is_empty() {
                        match limit {
                            0 => "Auto-resolve: agent reported no remaining issues but automation is disabled (limit 0). Please inspect manually.".to_string(),
                            1 => "Auto-resolve: agent reported no remaining issues but hit the single allowed review. Please inspect manually.".to_string(),
                            _ => format!(
                                "Auto-resolve: agent reported no remaining issues but hit the review attempt limit ({limit}). Please inspect manually."
                            ),
                        }
                    } else {
                        match limit {
                            0 => format!(
                                "Auto-resolve: no remaining issues. {rationale_text} Automation is disabled (limit 0); handing control back to you."
                            ),
                            1 => format!(
                                "Auto-resolve: no remaining issues. {rationale_text} The single allowed review is complete; handing control back to you."
                            ),
                            _ => format!(
                                "Auto-resolve: no remaining issues. {rationale_text} Review attempt limit ({limit}) reached; handing control back to you."
                            ),
                        }
                    };
                    self.auto_resolve_notice(message);
                    self.auto_resolve_clear();
                } else {
                    if rationale_text.is_empty() {
                        self.auto_resolve_notice(
                            "Auto-resolve: agent reported no remaining issues. Running follow-up /review to confirm.".to_string(),
                        );
                    } else {
                        self.auto_resolve_notice(format!(
                            "Auto-resolve: no remaining issues. {rationale_text} Running follow-up /review to confirm."
                        ));
                    }
                    if let Some(state) = self.auto_resolve_state.as_mut() {
                        state.phase = AutoResolvePhase::WaitingForReview;
                    }
                    self.restart_auto_resolve_review();
                }
            }
            "continue_fix" => {
                if let Some(state) = self.auto_resolve_state.as_mut() {
                    state.phase = AutoResolvePhase::AwaitingFix {
                        review: review.clone(),
                    };
                }
                self.dispatch_auto_continue(&review);
            }
            "review_again" => {
                let stop = self
                    .auto_resolve_state
                    .as_ref()
                    .is_some_and(|state| {
                        let allowed = state.max_attempts.saturating_add(1);
                        state.attempt >= allowed
                    });
                if stop {
                    let limit = self
                        .auto_resolve_state
                        .as_ref()
                        .map(|state| state.max_attempts)
                        .unwrap_or(0);
                    let message = if limit == 0 {
                        "Auto-resolve: review-again requested but automation is disabled (limit 0). Stopping.".to_string()
                    } else if limit == 1 {
                        "Auto-resolve: review-again requested but the attempt limit has been reached (1 allowed review). Stopping.".to_string()
                    } else {
                        format!(
                            "Auto-resolve: review-again requested but the attempt limit has been reached ({limit} allowed reviews). Stopping."
                        )
                    };
                    self.auto_resolve_notice(message);
                    self.auto_resolve_clear();
                } else {
                    if rationale.trim().is_empty() {
                        self.auto_resolve_notice("Auto-resolve: running another /review pass.".to_string());
                    } else {
                        let rationale_text = rationale.trim();
                        self.auto_resolve_notice(format!(
                            "Auto-resolve: running another /review pass. {rationale_text}"
                        ));
                    }
                    self.restart_auto_resolve_review();
                }
            }
            other => {
                self.auto_resolve_notice(format!(
                    "Auto-resolve: unexpected status '{other}'. Stopping automation."
                ));
                self.auto_resolve_clear();
            }
        }
    }

    fn auto_resolve_parse_decision(raw: &str) -> Option<AutoResolveDecision> {
        if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(raw) {
            return Some(decision);
        }

        if let Some(start) = raw.find("{" ) {
            if let Some(end) = raw.rfind("}") {
                let slice = &raw[start..=end];
                if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(slice) {
                    return Some(decision);
                }
            }
        }

        // try to strip ```json fences
        if let Some(json_start) = raw.find("```") {
            if let Some(rest) = raw[json_start + 3..].split_once("```") {
                let candidate = rest.0.trim_start_matches("json").trim();
                if let Ok(decision) = serde_json::from_str::<AutoResolveDecision>(candidate) {
                    return Some(decision);
                }
            }
        }

        None
    }

    pub(crate) fn open_review_dialog(&mut self) {
        if self.is_task_running() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/review` — complete or cancel the current task before starting a new review.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let mut items: Vec<SelectionItem> = Vec::new();

        let max_attempts = self.configured_auto_resolve_re_reviews();
        let auto_note = if self.config.tui.review_auto_resolve {
            if max_attempts == 0 {
                "Auto Resolve is enabled (no automatic re-reviews)."
            } else if max_attempts == 1 {
                "Auto Resolve is enabled (max 1 re-review)."
            } else {
                "Auto Resolve is enabled."
            }
        } else {
            "Auto Resolve is disabled."
        };
        items.push(SelectionItem {
            name: "Auto Resolve settings moved to /settings".to_string(),
            description: Some(format!(
                "{} Manage Auto Resolve reviews and max re-reviews via `/settings review`.",
                auto_note
            )),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::DispatchCommand(
                    SlashCommand::Settings,
                    "review".to_string(),
                ));
            })],
        });

        let workspace_prompt = "Review the current workspace changes (staged, unstaged, and untracked files) and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string();
        let workspace_hint = "current workspace changes".to_string();
        let workspace_preparation = "Preparing code review for current changes".to_string();
        let workspace_metadata = Some(ReviewContextMetadata {
            scope: Some("workspace".to_string()),
            ..Default::default()
        });
        let workspace_auto_resolve = self.config.tui.review_auto_resolve;
        items.push(SelectionItem {
            name: "Review uncommitted changes".to_string(),
            description: Some("Look at staged, unstaged, and untracked files".to_string()),
            is_current: false,
            actions: vec![Box::new({
                let prompt = workspace_prompt.clone();
                let hint = workspace_hint.clone();
                let preparation = workspace_preparation.clone();
                let metadata = workspace_metadata.clone();
                move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                        prompt: prompt.clone(),
                        hint: hint.clone(),
                        preparation_label: Some(preparation.clone()),
                        metadata: metadata.clone(),
                        auto_resolve: workspace_auto_resolve,
                    });
                }
            })],
        });

        items.push(SelectionItem {
            name: "Review /branch changes".to_string(),
            description: Some("Compare your worktree branch against its merge target".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::RunReviewCommand(String::new()));
            })],
        });

        items.push(SelectionItem {
            name: "Review a specific commit".to_string(),
            description: Some("Pick from recent commits".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::StartReviewCommitPicker);
            })],
        });

        items.push(SelectionItem {
            name: "Review against a base branch".to_string(),
            description: Some("Diff current branch against another".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::StartReviewBranchPicker);
            })],
        });

        items.push(SelectionItem {
            name: "Custom review instructions".to_string(),
            description: Some("Describe exactly what to audit".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(crate::app_event::AppEvent::OpenReviewCustomPrompt);
            })],
        });

        let view: ListSelectionView = ListSelectionView::new(
            " Review options ".to_string(),
            Some("Choose what scope to review".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            6,
        );

        self.bottom_pane.show_list_selection(
            "Review options".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_review_custom_prompt(&mut self) {
        let submit_tx = self.app_event_tx.clone();
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            submit_tx.send(crate::app_event::AppEvent::RunReviewCommand(text));
        });
        let view = CustomPromptView::new(
            "Custom review instructions".to_string(),
            "Describe the files or changes you want reviewed".to_string(),
            Some("Press Enter to submit · Esc cancel".to_string()),
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    pub(crate) fn set_review_auto_resolve_enabled(&mut self, enabled: bool) {
        if self.config.tui.review_auto_resolve == enabled {
            return;
        }

        self.config.tui.review_auto_resolve = enabled;
        if !enabled {
            self.auto_resolve_clear();
        }

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_tui_review_auto_resolve(&home, enabled) {
                Ok(_) => {
                    tracing::info!("Persisted review auto resolve toggle: {}", enabled);
                    if enabled {
                        "Auto Resolve reviews enabled."
                    } else {
                        "Auto Resolve reviews disabled."
                    }
                }
                Err(e) => {
                    tracing::warn!("Failed to persist review auto resolve toggle: {}", e);
                    if enabled {
                        "Auto Resolve enabled for this session (failed to persist)."
                    } else {
                        "Auto Resolve disabled for this session (failed to persist)."
                    }
                }
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist review auto resolve toggle");
            if enabled {
                "Auto Resolve enabled for this session."
            } else {
                "Auto Resolve disabled for this session."
            }
        };

        self.bottom_pane.flash_footer_notice(message.to_string());
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    pub(crate) fn set_auto_review_enabled(&mut self, enabled: bool) {
        if self.config.tui.auto_review_enabled == enabled {
            return;
        }

        self.config.tui.auto_review_enabled = enabled;

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_tui_auto_review_enabled(&home, enabled) {
                Ok(_) => {
                    tracing::info!("Persisted auto review toggle: {}", enabled);
                    if enabled {
                        "Auto Review enabled."
                    } else {
                        "Auto Review disabled."
                    }
                }
                Err(e) => {
                    tracing::warn!("Failed to persist auto review toggle: {}", e);
                    if enabled {
                        "Auto Review enabled for this session (failed to persist)."
                    } else {
                        "Auto Review disabled for this session (failed to persist)."
                    }
                }
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist auto review toggle");
            if enabled {
                "Auto Review enabled for this session."
            } else {
                "Auto Review disabled for this session."
            }
        };

        self.bottom_pane.flash_footer_notice(message.to_string());
        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    fn maybe_trigger_auto_review(&mut self) {
        if !self.config.tui.auto_review_enabled {
            return;
        }
        self.recover_stuck_background_review();

        if !self.turn_had_code_edits && self.pending_auto_review_range.is_none() {
            return;
        }
        if matches!(self.current_turn_origin, Some(TurnOrigin::Developer)) {
            return;
        }

        if self.pending_auto_review_deferred_for_current_turn() {
            return;
        }

        if let Some(reviewed) = self.auto_review_reviewed_marker.as_ref() {
            if !self.auto_review_has_changes_since(reviewed) {
                return;
            }
        }

        if self.background_review.is_some() || self.is_review_flow_active() {
            if let Some(base) = self.take_or_capture_auto_review_baseline() {
                self.queue_skipped_auto_review(base);
            }
            return;
        }

        let base_snapshot = if let Some(base) = self.take_ready_pending_range_base() {
            Some(base)
        } else {
            self.take_or_capture_auto_review_baseline()
        };

        if let Some(base) = base_snapshot {
            self.launch_background_review(Some(base));
        }
    }

    fn auto_review_has_changes_since(&self, reviewed: &GhostCommit) -> bool {
        let reviewed_id = reviewed.id();
        let tracked_changes = match self.run_git_command(
            ["diff", "--name-only", reviewed_id],
            |stdout| {
                Ok(stdout.lines().any(|line| !line.trim().is_empty()))
            },
        ) {
            Ok(changed) => changed,
            Err(err) => {
                tracing::warn!("auto review diff failed for {reviewed_id}: {err}");
                return true;
            }
        };

        if tracked_changes {
            return true;
        }

        let snapshot_paths = match self.run_git_command(
            ["ls-tree", "-r", "--name-only", reviewed_id],
            |stdout| {
                let mut paths = HashSet::new();
                for line in stdout.lines().map(str::trim) {
                    if !line.is_empty() {
                        paths.insert(line.to_string());
                    }
                }
                Ok(paths)
            },
        ) {
            Ok(paths) => paths,
            Err(err) => {
                tracing::warn!("auto review snapshot listing failed for {reviewed_id}: {err}");
                return true;
            }
        };

        let untracked_changes = match self.run_git_command(
            ["ls-files", "--others", "--exclude-standard"],
            |stdout| {
                Ok(stdout
                    .lines()
                    .map(str::trim)
                    .filter(|line| !line.is_empty())
                    .any(|path| !snapshot_paths.contains(path)))
            },
        ) {
            Ok(changed) => changed,
            Err(err) => {
                tracing::warn!("auto review untracked check failed: {err}");
                return true;
            }
        };

        untracked_changes
    }

    fn pending_auto_review_deferred_for_current_turn(&self) -> bool {
        matches!(
            self.pending_auto_review_range.as_ref(),
            Some(range)
                if matches!(range.defer_until_turn, Some(turn) if turn == self.turn_sequence)
        )
    }

    fn take_ready_pending_range_base(&mut self) -> Option<GhostCommit> {
        if let Some(range) = self.pending_auto_review_range.as_ref() {
            if let Some(turn) = range.defer_until_turn {
                if turn == self.turn_sequence {
                    return None;
                }
            }
        }
        self.pending_auto_review_range.take().map(|range| range.base)
    }

    fn take_or_capture_auto_review_baseline(&mut self) -> Option<GhostCommit> {
        if let Some(existing) = self.auto_review_baseline.take() {
            return Some(existing);
        }
        match self.capture_auto_turn_commit("auto review baseline snapshot", None) {
            Ok(commit) => Some(commit),
            Err(err) => {
                tracing::warn!("failed to capture auto review baseline: {err}");
                self.auto_review_reviewed_marker.clone()
            }
        }
    }

    fn queue_skipped_auto_review(&mut self, base: GhostCommit) {
        if self.pending_auto_review_range.is_some() {
            return;
        }
        self.pending_auto_review_range = Some(PendingAutoReviewRange {
            base,
            defer_until_turn: None,
        });
    }

    fn recover_stuck_background_review(&mut self) {
        let Some(state) = self.background_review.as_ref() else {
            return;
        };

        let elapsed = state.last_seen.elapsed();
        if elapsed.as_secs() < AUTO_REVIEW_STALE_SECS {
            return;
        }

        let stale = self.background_review.take();
        self.background_review_guard = None;

        let Some(stale) = stale else {
            return;
        };

        if self.pending_auto_review_range.is_none() {
            if let Some(base) = stale.base {
                self.pending_auto_review_range = Some(PendingAutoReviewRange {
                    base,
                    defer_until_turn: None,
                });
            }
        }
    }

    fn launch_background_review(&mut self, base_snapshot: Option<GhostCommit>) {
        // Record state immediately to avoid duplicate launches when multiple
        // TaskComplete events fire in quick succession.
        self.turn_had_code_edits = false;
        let had_notice = self.auto_review_notice.is_some();
        let had_fixed_indicator = matches!(
            self.auto_review_status,
            Some(AutoReviewStatus { status: AutoReviewIndicatorStatus::Fixed, .. })
        );
        self.background_review = Some(BackgroundReviewState {
            worktree_path: std::path::PathBuf::new(),
            branch: String::new(),
            agent_id: None,
            snapshot: None,
            base: base_snapshot.clone(),
            last_seen: std::time::Instant::now(),
        });
        self.auto_review_status = None;
        self.bottom_pane.set_auto_review_status(None);
        self.auto_review_notice = None;
        self.set_auto_review_indicator(
            AutoReviewIndicatorStatus::Running,
            None,
            AutoReviewPhase::Reviewing,
        );

        #[cfg(test)]
        if let Some(stub) = AUTO_REVIEW_STUB.lock().unwrap().as_mut() {
            (stub)();
            return;
        }

        let config = self.config.clone();
        let app_event_tx = self.app_event_tx.clone();
        let base_snapshot_for_task = base_snapshot.clone();
        let turn_context = self.turn_context_block();
        let prefer_fallback = had_notice || had_fixed_indicator;
        tokio::spawn(async move {
            run_background_review(
                config,
                app_event_tx,
                base_snapshot_for_task,
                turn_context,
                prefer_fallback,
            )
            .await;
        });
    }

    fn observe_auto_review_status(&mut self, agents: &[code_core::protocol::AgentInfo]) {
        let now = Instant::now();
        for agent in agents {
            if !Self::is_auto_review_agent(agent) {
                continue;
            }

            if let Some(progress) = agent.last_progress.as_deref() {
                if progress.contains(SKIP_REVIEW_PROGRESS_SENTINEL) {
                    // Treat skipped review as benign: clear indicator and state, do not surface.
                    self.clear_auto_review_indicator();
                    self.background_review = None;
                    self.background_review_guard = None;
                    self.processed_auto_review_agents.insert(agent.id.clone());
                    continue;
                }
            }

            if let Some(state) = self.background_review.as_mut() {
                state.last_seen = now;
                if state.agent_id.is_none() {
                    state.agent_id = Some(agent.id.clone());
                }
                if state.branch.is_empty() {
                    if let Some(batch) = agent.batch_id.as_ref() {
                        state.branch = batch.clone();
                    }
                }
            }

            let status = agent_status_from_str(agent.status.as_str());
            let is_terminal = matches!(
                status,
                AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled
            );
            let phase = detect_auto_review_phase(agent.last_progress.as_deref());

            if matches!(status, AgentStatus::Running | AgentStatus::Pending) {
                let findings = self.auto_review_status.and_then(|s| s.findings);
                self.set_auto_review_indicator(
                    AutoReviewIndicatorStatus::Running,
                    findings,
                    phase,
                );
                continue;
            }

            if let Some(mut state) = self.auto_review_status {
                state.phase = phase;
                self.auto_review_status = Some(state);
                self.bottom_pane.set_auto_review_status(Some(AutoReviewFooterStatus {
                    status: state.status,
                    findings: state.findings,
                    phase,
                }));
            }

            if is_terminal && self.processed_auto_review_agents.contains(&agent.id) {
                continue;
            }
            if !is_terminal {
                continue;
            }

            let (worktree_path, branch, snapshot) = if let Some(state) = self.background_review.as_ref() {
                (
                    state.worktree_path.clone(),
                    state.branch.clone(),
                    state.snapshot.clone(),
                )
            } else {
                let branch = agent.batch_id.clone().unwrap_or_default();
                let worktree_path = resolve_auto_review_worktree_path(&self.config.cwd, &branch)
                    .unwrap_or_default();
                (worktree_path, branch, None)
            };

            let (has_findings, findings, summary) = Self::parse_agent_review_result(agent.result.as_deref());

            self.on_background_review_finished(
                worktree_path,
                branch,
                has_findings,
                findings,
                summary,
                agent.error.clone(),
                Some(agent.id.clone()),
                snapshot,
            );
            self.processed_auto_review_agents.insert(agent.id.clone());
        }
    }

    /// Parse the auto-review agent result to derive findings count and a concise summary.
    /// Tries to deserialize `ReviewOutputEvent` JSON (direct or fenced). Falls back to heuristics.
    fn parse_agent_review_result(raw: Option<&str>) -> (bool, usize, Option<String>) {
        let Some(text) = raw else { return (false, 0, None); };
        let trimmed = text.trim();
        if trimmed.is_empty() {
            return (false, 0, None);
        }

        #[derive(serde::Deserialize)]
        struct MultiRunReview {
            #[serde(flatten)]
            latest: ReviewOutputEvent,
            #[serde(default)]
            runs: Vec<ReviewOutputEvent>,
        }

        // Try multi-run JSON first (our /review output that preserves all passes).
        if let Ok(wrapper) = serde_json::from_str::<MultiRunReview>(trimmed) {
            let mut runs = wrapper.runs;
            if runs.is_empty() {
                runs.push(wrapper.latest);
            }
            return Self::review_result_from_runs(&runs);
        }

        // Try direct JSON first.
        if let Ok(output) = serde_json::from_str::<ReviewOutputEvent>(trimmed) {
            return Self::review_result_from_output(&output);
        }

        // Try to extract JSON from fenced code blocks.
        if let Some(start) = trimmed.find("```") {
            if let Some((body, _)) = trimmed[start + 3..].split_once("```") {
                let candidate = body.trim_start_matches("json").trim();
                if let Ok(output) = serde_json::from_str::<ReviewOutputEvent>(candidate) {
                    return Self::review_result_from_output(&output);
                }
            }
        }

        // Heuristic: treat plain text as summary; infer findings only when the text
        // explicitly mentions issues. Avoid false positives for skip/lock messages.
        let lowered = trimmed.to_ascii_lowercase();
        let clean_phrases = ["no issues", "no findings", "clean", "looks good", "nothing to fix"];
        let skip_phrases = ["already running", "another review", "skipping this", "skip this"];
        let issue_markers = ["issue", "issues", "finding", "findings", "bug", "bugs", "problem", "problems", "error", "errors"]; // keep broad but guarded

        if skip_phrases.iter().any(|p| lowered.contains(p)) {
            return (false, 0, Some(trimmed.to_string()));
        }

        if clean_phrases.iter().any(|p| lowered.contains(p)) {
            return (false, 0, Some(trimmed.to_string()));
        }

        let has_findings = issue_markers.iter().any(|p| lowered.contains(p));
        (has_findings, 0, Some(trimmed.to_string()))
    }

    fn review_result_from_runs(outputs: &[ReviewOutputEvent]) -> (bool, usize, Option<String>) {
        if outputs.is_empty() {
            return (false, 0, None);
        }

        let last = outputs.last().unwrap();
        let last_with_findings_idx = outputs
            .iter()
            .rposition(|o| !o.findings.is_empty());

        let (mut has_findings, mut findings_len, mut summary) = Self::review_result_from_output(last);

        if let Some(idx) = last_with_findings_idx {
            let with_findings = &outputs[idx];
            let (has, len, summary_with_findings) = Self::review_result_from_output(with_findings);
            has_findings |= has;
            findings_len = len;
            summary = summary_with_findings.or(summary);

            // If fixes cleared the final pass, note that in the summary.
            if last.findings.is_empty() {
                let tail = "Final pass reported no issues after auto-resolve.";
                summary = Some(match summary {
                    Some(existing) if existing.contains(tail) => existing,
                    Some(existing) => format!("{existing} \n{tail}"),
                    None => tail.to_string(),
                });
            }
        }

        (has_findings, findings_len, summary)
    }

    fn review_result_from_output(output: &ReviewOutputEvent) -> (bool, usize, Option<String>) {
        let findings_len = output.findings.len();
        let has_findings = findings_len > 0;

        let mut summary_parts: Vec<String> = Vec::new();
        if !output.overall_explanation.trim().is_empty() {
            summary_parts.push(output.overall_explanation.trim().to_string());
        }
        if findings_len > 0 {
            let titles: Vec<String> = output
                .findings
                .iter()
                .filter_map(|f| {
                    let title = f.title.trim();
                    (!title.is_empty()).then_some(title.to_string())
                })
                .collect();
            if !titles.is_empty() {
                summary_parts.push(format!("Findings: {}", titles.join("; ")));
            }
        }

        let summary = if summary_parts.is_empty() {
            None
        } else {
            Some(summary_parts.join(" \n"))
        };

        (has_findings, findings_len, summary)
    }

    fn set_auto_review_indicator(
        &mut self,
        status: AutoReviewIndicatorStatus,
        findings: Option<usize>,
        phase: AutoReviewPhase,
    ) {
        let state = AutoReviewStatus {
            status,
            findings,
            phase,
        };
        self.auto_review_status = Some(state);
        self.bottom_pane
            .set_auto_review_status(Some(AutoReviewFooterStatus {
                status,
                findings,
                phase,
            }));
        self.request_redraw();
    }

    fn clear_auto_review_indicator(&mut self) {
        self.auto_review_status = None;
        self.bottom_pane.set_auto_review_status(None);
    }

    fn last_assistant_cell_index(&self) -> Option<usize> {
        self.history_cells.iter().enumerate().rev().find_map(|(idx, cell)| {
            cell.as_any()
                .downcast_ref::<history_cell::AssistantMarkdownCell>()
                .map(|_| idx)
        })
    }

    fn insert_auto_review_notice(
        &mut self,
        branch: &str,
        worktree_path: &std::path::Path,
        summary: Option<&str>,
        findings: usize,
    ) {
        let path_text = format!("{}", worktree_path.display());
        let has_path = !path_text.is_empty();

        let summary_text = summary.and_then(|text| {
            let trimmed = text.trim();
            (!trimmed.is_empty()).then_some(trimmed.to_string())
        });

        let mut line = format!("Auto Review: {findings} issue(s) found");
        if let Some(summary_text) = summary_text {
            line.push_str(". ");
            line.push_str(&summary_text);
        } else {
            line.push_str(&format!(" in '{branch}'"));
        }
        if has_path {
            line.push(' ');
            line.push_str(&format!("Merge {path_text} to apply fixes."));
        }
        line.push_str(" [Ctrl+A] Show");

        let message_lines = vec![MessageLine {
            kind: MessageLineKind::Paragraph,
            spans: vec![InlineSpan {
                text: line,
                tone: TextTone::Default,
                emphasis: TextEmphasis::default(),
                entity: None,
            }],
        }];

        let state = PlainMessageState {
            id: HistoryId::ZERO,
            role: PlainMessageRole::System,
            kind: PlainMessageKind::Notice,
            header: Some(MessageHeader { label: "Auto Review".to_string(), badge: None }),
            lines: message_lines,
            metadata: None,
        };

        // Replace existing notice if present
        if let Some(notice) = self.auto_review_notice.clone() {
            if let Some(idx) = self
                .history_cell_ids
                .iter()
                .position(|maybe| maybe.map(|id| id == notice.history_id).unwrap_or(false))
            {
                let cell = crate::history_cell::PlainHistoryCell::from_state(state.clone());
                self.history_replace_at(idx, Box::new(cell));
                return;
            }
        }

        // Insert after the indicator if present; otherwise after the assistant cell
        let base_key = self
            .last_assistant_cell_index()
            .and_then(|idx| self.cell_order_seq.get(idx).copied())
            .unwrap_or_else(|| OrderKey {
                req: 0,
                out: -1,
                seq: 0,
            });

        let insert_key = Self::order_key_successor(base_key);
        let pos = self.history_insert_plain_state_with_key(state, insert_key, "auto-review-notice");
        if let Some(Some(id)) = self.history_cell_ids.get(pos) {
            self.auto_review_notice = Some(AutoReviewNotice { history_id: *id });
        }
    }

    pub(crate) fn on_background_review_started(
        &mut self,
        worktree_path: std::path::PathBuf,
        branch: String,
        agent_id: Option<String>,
        snapshot: Option<String>,
    ) {
        if let Some(state) = self.background_review.as_mut() {
            state.worktree_path = worktree_path.clone();
            state.branch = branch.clone();
            state.agent_id = agent_id;
            state.snapshot = snapshot;
            state.last_seen = Instant::now();
        }
        if self.auto_review_status.is_none() {
            self.set_auto_review_indicator(
                AutoReviewIndicatorStatus::Running,
                None,
                AutoReviewPhase::Reviewing,
            );
        }
        // Ensure the main status spinner is cleared once the foreground turn ends;
        // background auto review should not keep the composer in a "running" state.
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());
        self.auto_review_notice = None;
        self.request_redraw();
    }

    pub(crate) fn on_background_review_finished(
        &mut self,
        worktree_path: std::path::PathBuf,
        branch: String,
        has_findings: bool,
        findings: usize,
        summary: Option<String>,
        error: Option<String>,
        agent_id: Option<String>,
        snapshot: Option<String>,
    ) {
        // Normalize zero-count "issues" so the indicator and developer notes stay
        // aligned with the overlay: if the parser could not produce a findings list,
        // treat the run as clean instead of "fixed".
        let mut has_findings = has_findings;
        if has_findings && findings == 0 {
            has_findings = false;
        }

        let inflight_base = self
            .background_review
            .as_ref()
            .and_then(|state| state.base.clone());
        let inflight_snapshot = snapshot.clone().or_else(|| {
            self.background_review
                .as_ref()
                .and_then(|state| state.snapshot.clone())
        });
        // Clear flags up front so subsequent auto reviews can start even if this finishes with an error
        self.background_review = None;
        self.background_review_guard = None;
        release_background_lock(&agent_id);
        let mut developer_note: Option<String> = None;
        let snapshot_note = inflight_snapshot
            .as_deref()
            .map(str::trim)
            .filter(|s| !s.is_empty())
            .map(|s| format!("Snapshot: {s} (review target)"))
            .unwrap_or_else(|| "Snapshot: (unknown)".to_string());
        let agent_note = agent_id
            .as_deref()
            .map(str::trim)
            .filter(|s| !s.is_empty())
            .map(|id| {
                let short = id.chars().take(8).collect::<String>();
                format!("Agent: #{short} (auto-review)")
            })
            .unwrap_or_else(|| "Agent: (unknown)".to_string());
        let summary_note = summary
            .as_deref()
            .map(str::trim)
            .filter(|s| !s.is_empty())
            .map(|s| s.replace('\n', " "))
            .map(|s| format!("Summary: {s}"));
        let errored = error.is_some();
        let indicator_status = if let Some(err) = error {
            developer_note = Some(format!(
                "[developer] Background auto-review failed.\n\nThis auto-review ran in an isolated git worktree and did not modify your current workspace.\n\nWorktree: '{branch}'\nWorktree path: {}\n{snapshot_note}\n{agent_note}\nError: {err}",
                worktree_path.display(),
            ));
            AutoReviewIndicatorStatus::Failed
        } else if has_findings {
            let mut note = format!(
                "[developer] Background auto-review completed and reported {findings} issue(s).\n\nA separate LLM ran /review (and may have run auto-resolve) in an isolated git worktree. Any proposed fixes live only in that worktree until you merge them.\n\nNext: Decide if the findings are genuine. If yes, Merge the worktree '{branch}' to apply the changes (or cherry-pick selectively). If not, do not merge.\n\nWorktree path: {}\n{snapshot_note}\n{agent_note}",
                worktree_path.display(),
            );
            if let Some(summary_note) = summary_note {
                note.push('\n');
                note.push_str(&summary_note);
            }
            developer_note = Some(note);
            AutoReviewIndicatorStatus::Fixed
        } else {
            AutoReviewIndicatorStatus::Clean
        };

        let findings_for_indicator =
            matches!(indicator_status, AutoReviewIndicatorStatus::Fixed).then_some(findings.max(1));
        let phase = self
            .auto_review_status
            .map(|s| s.phase)
            .unwrap_or(AutoReviewPhase::Reviewing);
        self.set_auto_review_indicator(indicator_status, findings_for_indicator, phase);
        if matches!(indicator_status, AutoReviewIndicatorStatus::Fixed) {
            self.insert_auto_review_notice(
                &branch,
                &worktree_path,
                summary.as_deref(),
                findings.max(1),
            );
        }

        if let Some(note) = developer_note {
            // Immediately inject as a developer message so the user sees it in the
            // transcript, even if tasks/streams are still running. Do not defer to
            // pending_agent_notes; that path can be lost if the session ends.
            self.submit_hidden_text_message_with_preface(String::new(), note);
        }

        // Auto review completion should never leave the composer spinner active.
        self.bottom_pane.set_task_running(false);
        self.bottom_pane.update_status_text(String::new());

        self.handle_auto_review_completion_state(
            has_findings,
            errored,
            inflight_base,
            inflight_snapshot,
        );
        self.maybe_resume_auto_after_review();
        self.request_redraw();
    }

    fn handle_auto_review_completion_state(
        &mut self,
        has_findings: bool,
        errored: bool,
        inflight_base: Option<GhostCommit>,
        snapshot: Option<String>,
    ) {
        let was_skipped = !has_findings && !errored && snapshot.is_none();

        if !errored {
            if let Some(id) = snapshot.as_ref() {
                self.auto_review_reviewed_marker = Some(GhostCommit::new(id.clone(), None));
            }
        }

        if was_skipped || errored {
            if let Some(base) = inflight_base {
                self.queue_skipped_auto_review(base);
            }
            return;
        }

        if has_findings {
            if let Some(range) = self.pending_auto_review_range.as_mut() {
                if range.defer_until_turn.is_none() {
                    range.defer_until_turn = Some(self.turn_sequence);
                }
            } else if let Some(base) = inflight_base {
                self.pending_auto_review_range = Some(PendingAutoReviewRange {
                    base,
                    defer_until_turn: Some(self.turn_sequence),
                });
            }
            return;
        }

        if let Some(pending) = self.pending_auto_review_range.take() {
            self.launch_background_review(Some(pending.base));
        }
    }

    pub(crate) fn set_review_auto_resolve_attempts(&mut self, attempts: u32) {
        use code_core::config_types::AutoResolveAttemptLimit;

        let Ok(limit) = AutoResolveAttemptLimit::try_new(attempts) else {
            tracing::warn!("Ignoring invalid auto-resolve attempt value: {}", attempts);
            return;
        };

        self.auto_resolve_attempts_baseline = limit.get();

        if self
            .config
            .auto_drive
            .auto_resolve_review_attempts
            .get()
            == limit.get()
        {
            return;
        }

        self.config.auto_drive.auto_resolve_review_attempts = limit;
        if let Some(state) = self.auto_resolve_state.as_mut() {
            state.max_attempts = limit.get();
            let allowed_total = state.max_attempts.saturating_add(1);
            if state.attempt >= allowed_total {
                self.auto_resolve_clear();
            }
        }

        let message = if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_auto_drive_settings(
                &home,
                &self.config.auto_drive,
                self.config.auto_drive_use_chat_model,
            ) {
                Ok(_) => {
                    tracing::info!(
                        "Persisted auto resolve attempt limit: {}",
                        limit.get()
                    );
                    format!("Max re-reviews set to {}.", limit.get())
                }
                Err(err) => {
                    tracing::warn!("Failed to persist auto resolve attempts: {err}");
                    format!(
                        "Max re-reviews set to {} for this session (failed to persist).",
                        limit.get()
                    )
                }
            }
        } else {
            tracing::warn!("Could not locate Codex home to persist auto resolve attempts");
            format!("Max re-reviews set to {} for this session.", limit.get())
        };

        self.bottom_pane.flash_footer_notice(message);
        self.update_review_settings_model_row();
        self.refresh_settings_overview_rows();
        self.request_redraw();
    }

    pub(crate) fn set_auto_review_followup_attempts(&mut self, attempts: u32) {
        use code_core::config_types::AutoResolveAttemptLimit;

        let Ok(limit) = AutoResolveAttemptLimit::try_new(attempts) else {
            tracing::warn!("Ignoring invalid auto-review follow-up value: {}", attempts);
            return;
        };

        if self
            .config
            .auto_drive
            .auto_review_followup_attempts
            .get()
            == limit.get()
        {
            return;
        }

        self.config.auto_drive.auto_review_followup_attempts = limit;

        if let Ok(home) = code_core::config::find_code_home() {
            match code_core::config::set_auto_drive_settings(
                &home,
                &self.config.auto_drive,
                self.config.auto_drive_use_chat_model,
            ) {
                Ok(_) => {
                    tracing::info!(
                        "Persisted auto-review follow-up limit: {}",
                        limit.get()
                    );
                    self.bottom_pane.flash_footer_notice(format!(
                        "Auto Review follow-ups set to {}.",
                        limit.get()
                    ));
                }
                Err(err) => {
                    tracing::warn!("Failed to persist auto-review follow-up attempts: {err}");
                    self.bottom_pane.flash_footer_notice(format!(
                        "Auto Review follow-ups set to {} for this session (failed to persist).",
                        limit.get()
                    ));
                }
            }
        }

        self.refresh_settings_overview_rows();
        self.update_review_settings_model_row();
        self.request_redraw();
    }

    fn restore_auto_resolve_attempts_if_lost(&mut self) {
        if self.auto_resolve_attempts_baseline == 0 {
            return;
        }
        let current = self
            .config
            .auto_drive
            .auto_resolve_review_attempts
            .get();
        if current == 0 {
            if let Ok(limit) = code_core::config_types::AutoResolveAttemptLimit::try_new(
                self.auto_resolve_attempts_baseline,
            ) {
                self.config.auto_drive.auto_resolve_review_attempts = limit;
            }
        }

        self.background_review = None;
    }

    fn update_review_settings_model_row(&mut self) {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if let Some(content) = overlay.review_content_mut() {
                content.update_review_model(
                    self.config.review_model.clone(),
                    self.config.review_model_reasoning_effort,
                );
                content.set_review_use_chat_model(self.config.review_use_chat_model);
                content.update_review_resolve_model(
                    self.config.review_resolve_model.clone(),
                    self.config.review_resolve_model_reasoning_effort,
                );
                content.set_review_resolve_use_chat_model(self.config.review_resolve_use_chat_model);
                content.update_auto_review_model(
                    self.config.auto_review_model.clone(),
                    self.config.auto_review_model_reasoning_effort,
                );
                content.set_auto_review_use_chat_model(self.config.auto_review_use_chat_model);
                content.update_auto_review_resolve_model(
                    self.config.auto_review_resolve_model.clone(),
                    self.config.auto_review_resolve_model_reasoning_effort,
                );
                content.set_auto_review_resolve_use_chat_model(
                    self.config.auto_review_resolve_use_chat_model,
                );
                content.set_review_followups(self.config.auto_drive.auto_resolve_review_attempts.get());
                content.set_auto_review_followups(
                    self.config.auto_drive.auto_review_followup_attempts.get(),
                );
            }
        }
    }

    fn update_planning_settings_model_row(&mut self) {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if let Some(content) = overlay.planning_content_mut() {
                content.update_planning_model(
                    self.config.planning_model.clone(),
                    self.config.planning_model_reasoning_effort,
                );
                content.set_use_chat_model(self.config.planning_use_chat_model);
            }
        }
    }

    fn update_auto_drive_settings_model_row(&mut self) {
        if let Some(overlay) = self.settings.overlay.as_mut() {
            if let Some(content) = overlay.auto_drive_content_mut() {
                content.update_model(
                    self.config.auto_drive.model.clone(),
                    self.config.auto_drive.model_reasoning_effort,
                );
                content.set_use_chat_model(
                    self.config.auto_drive_use_chat_model,
                    self.config.model.clone(),
                    self.config.model_reasoning_effort,
                );
            }
        }
    }

    pub(crate) fn show_review_commit_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading recent commits…".to_string(),
            description: None,
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select a commit ".to_string(),
            Some("Fetching recent commits from git".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Select a commit".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_review_commit_picker(&mut self, commits: Vec<CommitLogEntry>) {
        if commits.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No recent commits found for review".to_string());
            self.request_redraw();
            return;
        }

        let auto_resolve = self.config.tui.review_auto_resolve;
        let mut items: Vec<SelectionItem> = Vec::with_capacity(commits.len());
        for entry in commits {
            let subject = entry.subject.trim().to_string();
            let sha = entry.sha.trim().to_string();
            if sha.is_empty() {
                continue;
            }
            let short_sha: String = sha.chars().take(7).collect();
            let title = if subject.is_empty() {
                short_sha.clone()
            } else {
                format!("{short_sha} — {subject}")
            };
            let prompt = if subject.is_empty() {
                format!(
                    "Review the code changes introduced by commit {sha}. Provide prioritized, actionable findings."
                )
            } else {
                format!(
                    "Review the code changes introduced by commit {sha} (\"{subject}\"). Provide prioritized, actionable findings."
                )
            };
            let hint = format!("commit {short_sha}");
            let preparation = format!("Preparing code review for commit {short_sha}");
            let prompt_closure = prompt.clone();
            let hint_closure = hint.clone();
            let prep_closure = preparation.clone();
            let metadata_option = Some(ReviewContextMetadata {
                scope: Some("commit".to_string()),
                commit: Some(sha.clone()),
                ..Default::default()
            });
            let auto_flag = auto_resolve;
            items.push(SelectionItem {
                name: title,
                description: None,
                is_current: false,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                        prompt: prompt_closure.clone(),
                        hint: hint_closure.clone(),
                        preparation_label: Some(prep_closure.clone()),
                        metadata: metadata_option.clone(),
                        auto_resolve: auto_flag,
                    });
                })],
            });
        }

        if items.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No recent commits found for review".to_string());
            self.request_redraw();
            return;
        }

        let view = ListSelectionView::new(
            " Select a commit ".to_string(),
            Some("Choose a commit to review".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Select a commit to review".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_review_branch_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading local branches…".to_string(),
            description: None,
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select a base branch ".to_string(),
            Some("Fetching local branches".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Select a base branch".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_review_branch_picker(
        &mut self,
        current_branch: Option<String>,
        branches: Vec<String>,
    ) {
        let current_trimmed = current_branch.as_ref().map(|s| s.trim().to_string());
        let mut items: Vec<SelectionItem> = Vec::new();
        let auto_resolve = self.config.tui.review_auto_resolve;
        for branch in branches {
            let branch_trimmed = branch.trim();
            if branch_trimmed.is_empty() {
                continue;
            }
            if current_trimmed
                .as_ref()
                .is_some_and(|current| current == branch_trimmed)
            {
                continue;
            }

            let title = if let Some(current) = current_trimmed.as_ref() {
                format!("{current} → {branch_trimmed}")
            } else {
                format!("Compare against {branch_trimmed}")
            };

            let prompt = if let Some(current) = current_trimmed.as_ref() {
                format!(
                    "Review the code changes between the current branch '{current}' and '{branch_trimmed}'. Identify the intent of the changes in '{current}' and ensure no obvious gaps remain. Find all geniune bugs or regressions which need to be addressed before merging. Return ALL issues which need to be addressed, not just the first one you find."
                )
            } else {
                format!(
                    "Review the code changes that would merge into '{branch_trimmed}'. Identify bugs, regressions, risky patterns, and missing tests before merge."
                )
            };
            let hint = format!("against {branch_trimmed}");
            let preparation = format!("Preparing code review against {branch_trimmed}");
            let prompt_closure = prompt.clone();
            let hint_closure = hint.clone();
            let prep_closure = preparation.clone();
            let metadata_option = Some(ReviewContextMetadata {
                scope: Some("branch_diff".to_string()),
                base_branch: Some(branch_trimmed.to_string()),
                current_branch: current_trimmed.clone(),
                ..Default::default()
            });
            let auto_flag = auto_resolve;
            items.push(SelectionItem {
                name: title,
                description: None,
                is_current: false,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                        prompt: prompt_closure.clone(),
                        hint: hint_closure.clone(),
                        preparation_label: Some(prep_closure.clone()),
                        metadata: metadata_option.clone(),
                        auto_resolve: auto_flag,
                    });
                })],
            });
        }

        if items.is_empty() {
            self.bottom_pane
                .flash_footer_notice("No alternative branches found for review".to_string());
            self.request_redraw();
            return;
        }

        let subtitle = current_trimmed
            .as_ref()
            .map(|current| format!("Current branch: {current}"));

        let view = ListSelectionView::new(
            " Select a base branch ".to_string(),
            subtitle,
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Compare against a branch".to_string(),
            None,
            None,
            view,
        );
    }

    /// Handle `/review [focus]` command by starting a dedicated review session.
    pub(crate) fn handle_review_command(&mut self, args: String) {
        if self.is_task_running() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/review` — complete or cancel the current task before starting a new review.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let trimmed = args.trim();
        let auto_resolve = self.config.tui.review_auto_resolve;
        if trimmed.is_empty() {
            if Self::is_branch_worktree_path(&self.config.cwd) {
                if let Some(git_root) =
                    code_core::git_info::resolve_root_git_project_for_trust(&self.config.cwd)
                {
                    let worktree_cwd = self.config.cwd.clone();
                    let tx = self.app_event_tx.clone();
                    let auto_flag = auto_resolve;
                    tokio::spawn(async move {
                    let branch_metadata =
                        code_core::git_worktree::load_branch_metadata(&worktree_cwd);
                    let metadata_base = branch_metadata.as_ref().and_then(|meta| {
                        meta.remote_ref.clone().or_else(|| {
                            if let (Some(remote_name), Some(base_branch)) =
                                (meta.remote_name.clone(), meta.base_branch.clone())
                            {
                                Some(format!("{}/{}", remote_name, base_branch))
                            } else {
                                None
                            }
                        })
                        .or_else(|| meta.base_branch.clone())
                    });
                    let default_branch = match metadata_base {
                        Some(value) => Some(value),
                        None => code_core::git_worktree::detect_default_branch(&git_root)
                            .await
                            .map(|name| name.trim().to_string())
                            .filter(|name| !name.is_empty()),
                    };
                    let current_branch = code_core::git_info::current_branch_name(&worktree_cwd)
                        .await
                        .map(|name| name.trim().to_string())
                        .filter(|name| !name.is_empty());

                        if let (Some(base_branch), Some(current_branch)) =
                            (default_branch, current_branch)
                        {
                            if base_branch != current_branch {
                                let prompt = format!(
                                    "Review the code changes between the current branch '{current_branch}' and '{base_branch}'. Identify the intent of the changes in '{current_branch}' and ensure no obvious gaps remain. Find all geniune bugs or regressions which need to be addressed before merging. Return ALL issues which need to be addressed, not just the first one you find."
                                );
                                let hint = format!("against {base_branch}");
                                let preparation_label =
                                    Some(format!("Preparing code review against {base_branch}"));
                                let metadata = Some(ReviewContextMetadata {
                                    scope: Some("branch_diff".to_string()),
                                    base_branch: Some(base_branch.clone()),
                                    current_branch: Some(current_branch.clone()),
                                    ..Default::default()
                                });
                                tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                                    prompt,
                                    hint,
                                    preparation_label,
                                    metadata,
                                    auto_resolve: auto_flag,
                                });
                                return;
                            }
                        }

                        tx.send(crate::app_event::AppEvent::RunReviewWithScope {
                            prompt: "Review the current workspace changes and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string(),
                            hint: "current workspace changes".to_string(),
                            preparation_label: Some("Preparing code review request...".to_string()),
                            metadata: Some(ReviewContextMetadata {
                                scope: Some("workspace".to_string()),
                                ..Default::default()
                            }),
                            auto_resolve: auto_flag,
                        });
                    });
                    return;
                }
            }

            let metadata = ReviewContextMetadata {
                scope: Some("workspace".to_string()),
                ..Default::default()
            };
            self.start_review_with_scope(
                "Review the current workspace changes and highlight bugs, regressions, risky patterns, and missing tests before merge.".to_string(),
                "current workspace changes".to_string(),
                Some("Preparing code review request...".to_string()),
                Some(metadata),
                auto_resolve,
            );
        } else {
            let value = trimmed.to_string();
            let preparation = format!("Preparing code review for {value}");
            let metadata = ReviewContextMetadata {
                scope: Some("custom".to_string()),
                ..Default::default()
            };
            self.start_review_with_scope(value.clone(), value, Some(preparation), Some(metadata), auto_resolve);
        }
    }

    pub(crate) fn start_review_with_scope(
        &mut self,
        prompt: String,
        hint: String,
        preparation_label: Option<String>,
        metadata: Option<ReviewContextMetadata>,
        auto_resolve: bool,
    ) {
        if auto_resolve {
            let max_re_reviews = self.configured_auto_resolve_re_reviews();
            self.auto_resolve_state = Some(AutoResolveState::new_with_limit(
                prompt.clone(),
                hint.clone(),
                metadata.clone(),
                max_re_reviews,
            ));
        } else {
            self.auto_resolve_state = None;
        }

        self.begin_review(prompt, hint, preparation_label, metadata);
    }

    fn begin_review(
        &mut self,
        prompt: String,
        hint: String,
        preparation_label: Option<String>,
        metadata: Option<ReviewContextMetadata>,
    ) {
        self.active_review_hint = None;
        self.active_review_prompt = None;

        let trimmed_hint = hint.trim();
        let preparation_notice = preparation_label.unwrap_or_else(|| {
            if trimmed_hint.is_empty() {
                "Preparing code review request...".to_string()
            } else {
                format!("Preparing code review for {trimmed_hint}")
            }
        });

        self.insert_background_event_early(preparation_notice);
        self.request_redraw();

        let review_request = ReviewRequest {
            prompt,
            user_facing_hint: hint,
            metadata,
        };
        match try_acquire_lock("review", &self.config.cwd) {
            Ok(Some(guard)) => {
                self.review_guard = Some(guard);
                self.submit_op(Op::Review { review_request });
            }
            Ok(None) => {
                self.push_background_tail("Review skipped: another review is already running.".to_string());
            }
            Err(err) => {
                self.push_background_tail(format!("Review skipped: could not acquire review lock ({err})"));
            }
        }
    }

    fn is_review_flow_active(&self) -> bool {
        self.active_review_hint.is_some() || self.active_review_prompt.is_some()
    }

    fn build_review_summary_cell(
        &self,
        hint: Option<&str>,
        prompt: Option<&str>,
        output: &ReviewOutputEvent,
    ) -> history_cell::AssistantMarkdownCell {
        let mut sections: Vec<String> = Vec::new();
        let title = match hint {
            Some(h) if !h.trim().is_empty() => {
                let trimmed = h.trim();
                format!("**Review summary — {trimmed}**")
            }
            _ => "**Review summary**".to_string(),
        };
        sections.push(title);

        if let Some(p) = prompt {
            let trimmed_prompt = p.trim();
            if !trimmed_prompt.is_empty() {
                sections.push(format!("**Prompt:** {trimmed_prompt}"));
            }
        }

        let explanation = output.overall_explanation.trim();
        if !explanation.is_empty() {
            sections.push(explanation.to_string());
        }
        if !output.findings.is_empty() {
            sections.push(format_review_findings_block(&output.findings, None).trim().to_string());
        }
        let correctness = output.overall_correctness.trim();
        if !correctness.is_empty() {
            sections.push(format!("**Overall correctness:** {correctness}"));
        }
        if output.overall_confidence_score > 0.0 {
            let score = output.overall_confidence_score;
            sections.push(format!("**Confidence score:** {score:.1}"));
        }
        if sections.len() == 1 {
            sections.push("No detailed findings were provided.".to_string());
        }

        let markdown = sections
            .into_iter()
            .map(|part| part.trim().to_string())
            .filter(|part| !part.is_empty())
            .collect::<Vec<_>>()
            .join("\n\n");

        let state = AssistantMessageState {
            id: HistoryId::ZERO,
            stream_id: None,
            markdown,
            citations: Vec::new(),
            metadata: None,
            token_usage: None,
            mid_turn: false,
            created_at: SystemTime::now(),
        };
        history_cell::AssistantMarkdownCell::from_state(state, &self.config)
    }

    /// Handle `/branch [task]` command. Creates a worktree under `.code/branches`,
    /// optionally copies current uncommitted changes, then switches the session cwd
    /// into the worktree. If `task` is non-empty, submits it immediately.
    pub(crate) fn handle_cloud_command(&mut self, args: String) {
        let trimmed = args.trim();
        self.consume_pending_prompt_for_ui_only_turn();
        if trimmed.is_empty() {
            self.open_cloud_menu();
            return;
        }

        let mut parts = trimmed.splitn(2, ' ');
        let head = parts.next().unwrap_or("").to_ascii_lowercase();
        let rest = parts.next().map(str::trim).unwrap_or("");

        match head.as_str() {
            "list" => {
                if rest.is_empty() {
                    self.request_cloud_task_refresh(None);
                } else {
                    self.request_cloud_task_refresh(Some(rest.to_string()));
                }
            }
            "env" => {
                self.app_event_tx.send(AppEvent::FetchCloudEnvironments);
            }
            "new" => {
                if rest.is_empty() {
                    self.show_cloud_task_create_prompt();
                } else if let Some(env) = self.cloud_tasks_selected_env.clone() {
                    if self.cloud_tasks_creation_inflight {
                        self.bottom_pane.flash_footer_notice(
                            "Cloud task creation already in progress".to_string(),
                        );
                    } else {
                        self.cloud_tasks_creation_inflight = true;
                        self.cloud_task_create_ticket = Some(self.make_background_tail_ticket());
                        self.app_event_tx.send(AppEvent::SubmitCloudTaskCreate {
                            env_id: env.id.clone(),
                            prompt: rest.to_string(),
                            best_of_n: self.cloud_tasks_best_of_n,
                        });
                        self.show_cloud_task_create_progress();
                    }
                } else {
                    self.show_cloud_tasks_error(
                        "Select an environment before creating a cloud task".to_string(),
                    );
                    self.app_event_tx.send(AppEvent::FetchCloudEnvironments);
                }
            }
            _ => {
                self.history_push_plain_state(history_cell::new_error_event(format!(
                    "`/cloud` — unknown option '{head}'. Try `/cloud`, `/cloud list`, `/cloud new`, or `/cloud env`."
                )));
                self.request_redraw();
            }
        }
    }

    fn open_cloud_menu(&mut self) {
        let current = self.cloud_env_label();
        let env_id = self
            .cloud_tasks_selected_env
            .as_ref()
            .map(|env| env.id.clone());
        let fetch_action_env = env_id.clone();
        let mut items: Vec<SelectionItem> = Vec::new();
        items.push(SelectionItem {
            name: "Browse cloud tasks".to_string(),
            description: Some(format!("Current filter: {current}")),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTasks {
                    environment: fetch_action_env.clone(),
                });
            })],
        });
        items.push(SelectionItem {
            name: "Select environment".to_string(),
            description: Some("Choose which environment to browse".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudEnvironments);
            })],
        });
        items.push(SelectionItem {
            name: "Create new task".to_string(),
            description: Some("Open the composer to submit a new cloud task".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::OpenCloudTaskCreate);
            })],
        });

        let view = ListSelectionView::new(
            " Cloud tasks ".to_string(),
            Some("Choose an action".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            6,
        );

        self.bottom_pane.show_list_selection(
            "Cloud tasks".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_cloud_tasks_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading cloud tasks…".to_string(),
            description: Some("Fetching latest tasks from Codex Cloud".to_string()),
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Cloud tasks ".to_string(),
            Some(self.cloud_env_label()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Loading cloud tasks".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_cloud_tasks(
        &mut self,
        environment: Option<String>,
        tasks: Vec<TaskSummary>,
    ) {
        self.cloud_tasks_last_tasks = tasks.clone();
        let env_label = match environment {
            Some(ref id) => self
                .cloud_tasks_selected_env
                .as_ref()
                .filter(|env| env.id == *id)
                .map(|env| self.display_name_for_env(env))
                .unwrap_or_else(|| format!("Environment {id}")),
            None => "All environments".to_string(),
        };
        let view = CloudTasksView::new(
            tasks,
            Some(env_label.clone()),
            environment,
            self.app_event_tx.clone(),
        );
        self.bottom_pane.show_cloud_tasks(view);
        self.request_redraw();
    }

    pub(crate) fn show_cloud_tasks_error(&mut self, message: String) {
        self.bottom_pane.flash_footer_notice(message.clone());
        self.history_push_plain_state(history_cell::new_error_event(format!(
            "`/cloud` — {message}"
        )));
        self.request_redraw();
    }

    pub(crate) fn show_cloud_environment_loading(&mut self) {
        let loading_item = SelectionItem {
            name: "Loading environments…".to_string(),
            description: Some("Fetching available Codex Cloud environments".to_string()),
            is_current: true,
            actions: Vec::new(),
        };
        let view = ListSelectionView::new(
            " Select environment ".to_string(),
            Some("Choose which environment to browse".to_string()),
            Some("Esc cancel".to_string()),
            vec![loading_item],
            self.app_event_tx.clone(),
            8,
        );
        self.bottom_pane.show_list_selection(
            "Select environment".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn present_cloud_environment_picker(
        &mut self,
        environments: Vec<CloudEnvironment>,
    ) {
        if environments.is_empty() {
            self.show_cloud_tasks_error("No environments available".to_string());
            return;
        }
        self.cloud_tasks_environments = environments.clone();

        let mut items: Vec<SelectionItem> = Vec::with_capacity(environments.len() + 1);
        items.push(SelectionItem {
            name: "All environments".to_string(),
            description: Some("Show tasks across every environment".to_string()),
            is_current: self.cloud_tasks_selected_env.is_none(),
            actions: vec![Box::new(|tx: &AppEventSender| {
                tx.send(AppEvent::SetCloudEnvironment { environment: None });
            })],
        });

        for env in environments {
            let env_clone = env.clone();
            let display = self.display_name_for_env(&env_clone);
            let repo_hint = env_clone
                .repo_hints
                .clone()
                .map(|hint| format!("Repo: {hint}"));
            items.push(SelectionItem {
                name: display,
                description: repo_hint,
                is_current: self
                    .cloud_tasks_selected_env
                    .as_ref()
                    .map(|selected| selected.id == env_clone.id)
                    .unwrap_or(false),
                actions: vec![Box::new(move |tx: &AppEventSender| {
                    tx.send(AppEvent::SetCloudEnvironment {
                        environment: Some(env_clone.clone()),
                    });
                })],
            });
        }

        let view = ListSelectionView::new(
            " Select environment ".to_string(),
            Some("Pick the environment to browse".to_string()),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane.show_list_selection(
            "Select environment".to_string(),
            None,
            None,
            view,
        );
    }

    pub(crate) fn set_cloud_environment(&mut self, environment: Option<CloudEnvironment>) {
        self.cloud_tasks_selected_env = environment.clone();
        let label = environment
            .as_ref()
            .map(|env| self.display_name_for_env(env))
            .unwrap_or_else(|| "All environments".to_string());
        self.bottom_pane
            .flash_footer_notice(format!("Cloud tasks filter set to {label}"));
        self.request_cloud_task_refresh(None);
    }

    fn display_name_for_env(&self, env: &CloudEnvironment) -> String {
        match env.label.as_ref() {
            Some(label) if !label.is_empty() => format!("{label} ({})", env.id),
            _ => env.id.clone(),
        }
    }

    fn request_cloud_task_refresh(&mut self, env_override: Option<String>) {
        let selected = env_override.or_else(|| self.current_cloud_env_id());
        self.app_event_tx
            .send(AppEvent::FetchCloudTasks { environment: selected });
    }

    fn cloud_env_label(&self) -> String {
        self.cloud_tasks_selected_env
            .as_ref()
            .map(|env| self.display_name_for_env(env))
            .unwrap_or_else(|| "All environments".to_string())
    }

    fn current_cloud_env_id(&self) -> Option<String> {
        self.cloud_tasks_selected_env
            .as_ref()
            .map(|env| env.id.clone())
    }

    pub(crate) fn show_cloud_task_actions(&mut self, task_id: String) {
        let Some(task) = self.find_cloud_task(&task_id) else {
            self.show_cloud_tasks_error(format!("Task {task_id} no longer available"));
            return;
        };

        let status_label = format!("Status: {:?}", task.status);
        let env_display = task
            .environment_label
            .as_ref()
            .or(task.environment_id.as_ref())
            .cloned()
            .unwrap_or_else(|| "Unknown environment".to_string());

        let mut items: Vec<SelectionItem> = Vec::new();
        let diff_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "View diff".to_string(),
            description: Some("Open the unified diff in history".to_string()),
            is_current: true,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTaskDiff {
                    task_id: diff_id.clone(),
                });
            })],
        });

        let msg_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "View assistant output".to_string(),
            description: Some("Show assistant messages associated with this task".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::FetchCloudTaskMessages {
                    task_id: msg_id.clone(),
                });
            })],
        });

        let preflight_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "Preflight apply".to_string(),
            description: Some("Check whether the patch applies cleanly".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::ApplyCloudTask {
                    task_id: preflight_id.clone(),
                    preflight: true,
                });
            })],
        });

        let apply_id = task.id.0.clone();
        items.push(SelectionItem {
            name: "Apply task".to_string(),
            description: Some("Apply the diff to the working tree".to_string()),
            is_current: false,
            actions: vec![Box::new(move |tx: &AppEventSender| {
                tx.send(AppEvent::ApplyCloudTask {
                    task_id: apply_id.clone(),
                    preflight: false,
                });
            })],
        });

        let subtitle = format!("{} • Env: {}", status_label, env_display);
        let view = ListSelectionView::new(
            format!(" Task {} ", task.title),
            Some(subtitle),
            Some("Enter choose · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            8,
        );

        self.bottom_pane.show_list_selection(
            format!("Cloud task: {}", task.title),
            None,
            None,
            view,
        );
    }

    pub(crate) fn show_cloud_task_create_prompt(&mut self) {
        let Some(env) = self.cloud_tasks_selected_env.clone() else {
            self.show_cloud_tasks_error(
                "Select an environment before creating a cloud task".to_string(),
            );
            return;
        };

        let env_display = self.display_name_for_env(&env);
        let submit_tx = self.app_event_tx.clone();
        let env_id = env.id.clone();
        let best_of = self.cloud_tasks_best_of_n;
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            if text.trim().is_empty() {
                return;
            }
            submit_tx.send(AppEvent::SubmitCloudTaskCreate {
                env_id: env_id.clone(),
                prompt: text,
                best_of_n: best_of,
            });
        });

        let view = CustomPromptView::new(
            format!("Create cloud task ({env_display})"),
            "Describe the change you want Codex to implement".to_string(),
            Some("Press Enter to submit · Esc cancel".to_string()),
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    pub(crate) fn show_cloud_task_create_progress(&mut self) {
        self.cloud_tasks_creation_inflight = true;
        self.bottom_pane
            .flash_footer_notice("Submitting cloud task…".to_string());
        self.request_redraw();
    }

    pub(crate) fn handle_cloud_task_created(
        &mut self,
        env_id: String,
        result: Result<CreatedTask, CloudTaskError>,
    ) {
        self.cloud_tasks_creation_inflight = false;
        match result {
            Ok(created) => {
                let ticket = self
                    .cloud_task_create_ticket
                    .take()
                    .unwrap_or_else(|| self.make_background_tail_ticket());
                self.app_event_tx.send_background_event_with_ticket(
                    &ticket,
                    format!("✅ Created cloud task {} in {env_id}", created.id.0),
                );
                self.request_cloud_task_refresh(None);
            }
            Err(err) => {
                self.show_cloud_tasks_error(format!(
                    "Failed to create cloud task in {env_id}: {}",
                    describe_cloud_error(&err)
                ));
            }
        }
    }

    pub(crate) fn show_cloud_task_apply_status(&mut self, task_id: &str, preflight: bool) {
        let key = (task_id.to_string(), preflight);
        if !self.cloud_task_apply_tickets.contains_key(&key) {
            let ticket = self.make_background_tail_ticket();
            self.cloud_task_apply_tickets.insert(key.clone(), ticket);
        }
        let ticket = self
            .cloud_task_apply_tickets
            .get_mut(&key)
            .expect("ticket just inserted");
        if preflight {
            self.app_event_tx.send_background_event_with_ticket(
                ticket,
                format!("Preflighting cloud task {task_id}…"),
            );
        } else {
            self.app_event_tx.send_background_event_with_ticket(
                ticket,
                format!("Applying cloud task {task_id}…"),
            );
        }
    }

    pub(crate) fn handle_cloud_task_apply_finished(
        &mut self,
        task_id: String,
        outcome: Result<ApplyOutcome, CloudTaskError>,
        preflight: bool,
    ) {
        match outcome {
            Ok(result) => {
                let mut message = if preflight {
                    format!("Preflight result for {task_id}: {}", result.message)
                } else {
                    format!("Apply result for {task_id}: {}", result.message)
                };
                if !result.skipped_paths.is_empty() {
                    message.push_str("\nSkipped: ");
                    message.push_str(&result.skipped_paths.join(", "));
                }
                if !result.conflict_paths.is_empty() {
                    message.push_str("\nConflicts: ");
                    message.push_str(&result.conflict_paths.join(", "));
                }
                let key = (task_id.clone(), preflight);
                let ticket = self
                    .cloud_task_apply_tickets
                    .remove(&key)
                    .unwrap_or_else(|| self.make_background_tail_ticket());
                self.app_event_tx
                    .send_background_event_with_ticket(&ticket, message);
                if !preflight {
                    self.request_cloud_task_refresh(None);
                }
            }
            Err(err) => {
                self.show_cloud_tasks_error(format!(
                    "Cloud task {task_id} failed: {}",
                    describe_cloud_error(&err)
                ));
            }
        }
    }

    fn find_cloud_task(&self, task_id: &str) -> Option<&TaskSummary> {
        self.cloud_tasks_last_tasks
            .iter()
            .find(|task| task.id.0 == task_id)
    }

    fn ensure_git_repo_for_action(&mut self, resume: GitInitResume, reason: &str) -> bool {
        if code_core::git_info::get_git_repo_root(&self.config.cwd).is_some() {
            if self.git_init_declined {
                self.git_init_declined = false;
            }
            return false;
        }

        if self.git_init_inflight {
            self.bottom_pane
                .flash_footer_notice("Initializing git repository...".to_string());
            return true;
        }

        if self.git_init_declined {
            let notice = format!(
                "{reason} Run `git init` in {} to enable write-enabled agents and worktrees.",
                self.config.cwd.display()
            );
            self.history_push_plain_paragraphs(
                PlainMessageKind::Notice,
                vec!["Git repository not initialized.".to_string(), notice],
            );
            self.request_redraw();
            return true;
        }

        self.show_git_init_prompt(resume, reason);
        true
    }

    fn show_git_init_prompt(&mut self, resume: GitInitResume, reason: &str) {
        let subtitle = format!(
            "{reason}\nInitialize a git repository in {}?",
            self.config.cwd.display()
        );
        let resume_init = resume.clone();
        let items = vec![
            SelectionItem {
                name: "Initialize git repository".to_string(),
                description: Some("Run `git init` in this folder (recommended).".to_string()),
                is_current: true,
                actions: vec![Box::new(move |tx: &AppEventSender| {
                    tx.send(AppEvent::ConfirmGitInit {
                        resume: resume_init.clone(),
                    });
                })],
            },
            SelectionItem {
                name: "Continue without git".to_string(),
                description: Some("Write-enabled agents and worktrees will be unavailable.".to_string()),
                is_current: false,
                actions: vec![Box::new(|tx: &AppEventSender| {
                    tx.send(AppEvent::DeclineGitInit);
                })],
            },
        ];

        let view = ListSelectionView::new(
            " Git repository required ".to_string(),
            Some(subtitle),
            Some("Enter select - Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            6,
        );
        self.bottom_pane.show_list_selection(
            "Git repository required".to_string(),
            None,
            None,
            view,
        );
        self.request_redraw();
    }

    pub(crate) fn confirm_git_init(&mut self, resume: GitInitResume) {
        if self.git_init_inflight {
            self.bottom_pane
                .flash_footer_notice("Git init already running...".to_string());
            return;
        }

        self.pending_git_init_resume = Some(resume);
        self.git_init_inflight = true;

        let cwd = self.config.cwd.clone();
        let ticket = self.make_background_tail_ticket();
        self.app_event_tx.send_background_event_with_ticket(
            &ticket,
            format!("Initializing git repository in {}...", cwd.display()),
        );

        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            let output = tokio::process::Command::new("git")
                .current_dir(&cwd)
                .arg("init")
                .output()
                .await;

            let (ok, message) = match output {
                Ok(out) if out.status.success() => {
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    let trimmed = stdout.trim();
                    let msg = if trimmed.is_empty() {
                        format!("Initialized git repository in {}.", cwd.display())
                    } else {
                        trimmed.to_string()
                    };
                    (true, msg)
                }
                Ok(out) => {
                    let stderr = String::from_utf8_lossy(&out.stderr);
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    let detail = if !stderr.trim().is_empty() {
                        stderr.trim().to_string()
                    } else {
                        stdout.trim().to_string()
                    };
                    let msg = if detail.is_empty() {
                        "git init failed.".to_string()
                    } else {
                        format!("git init failed: {detail}")
                    };
                    (false, msg)
                }
                Err(e) => (false, format!("Failed to run git init: {e}")),
            };

            tx.send(AppEvent::GitInitFinished { ok, message });
        });
    }

    pub(crate) fn decline_git_init(&mut self) {
        self.git_init_declined = true;
        let notice = format!(
            "Write-enabled agents and worktrees are unavailable until you run `git init` in {}.",
            self.config.cwd.display()
        );
        self.history_push_plain_paragraphs(
            PlainMessageKind::Notice,
            vec!["Git repository not initialized.".to_string(), notice],
        );
        self.request_redraw();
    }

    pub(crate) fn handle_git_init_finished(&mut self, ok: bool, message: String) {
        self.git_init_inflight = false;
        if ok {
            self.git_init_declined = false;
            let notice = if message.trim().is_empty() {
                format!("Initialized git repository in {}.", self.config.cwd.display())
            } else {
                message
            };
            self.push_background_tail(notice);
            if let Some(resume) = self.pending_git_init_resume.take() {
                match resume {
                    GitInitResume::SubmitText { text } => {
                        self.app_event_tx.send(AppEvent::SubmitTextWithPreface {
                            visible: text,
                            preface: String::new(),
                        });
                    }
                    GitInitResume::DispatchCommand {
                        command,
                        command_text,
                    } => {
                        self.app_event_tx
                            .send(AppEvent::DispatchCommand(command, command_text));
                    }
                }
            }
        } else {
            let err = if message.trim().is_empty() {
                "git init failed.".to_string()
            } else {
                message
            };
            self.history_push_plain_state(history_cell::new_error_event(err));
            self.pending_git_init_resume = None;
        }
        self.request_redraw();
    }

    pub(crate) fn handle_branch_command(&mut self, args: String) {
        self.consume_pending_prompt_for_ui_only_turn();
        let command_text = if args.trim().is_empty() {
            "/branch".to_string()
        } else {
            format!("/branch {}", args.trim())
        };
        if self.ensure_git_repo_for_action(
            GitInitResume::DispatchCommand {
                command: SlashCommand::Branch,
                command_text,
            },
            "Creating a branch worktree requires a git repository.",
        ) {
            return;
        }
        if Self::is_branch_worktree_path(&self.config.cwd) {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/branch` — already inside a branch worktree; switch to the repo root before creating another branch."
                    .to_string(),
            ));
            self.request_redraw();
            return;
        }
        let args_trim = args.trim().to_string();
        let cwd = self.config.cwd.clone();
        let tx = self.app_event_tx.clone();
        let branch_tail_ticket = self.make_background_tail_ticket();
        // Add a quick notice into history, include task preview if provided
        if args_trim.is_empty() {
            self.insert_background_event_with_placement(
                "Creating branch worktree...".to_string(),
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
        } else {
            self.insert_background_event_with_placement(
                format!("Creating branch worktree... Task: {}", args_trim),
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
        }
        self.request_redraw();

        tokio::spawn(async move {
            use tokio::process::Command;
            let ticket = branch_tail_ticket;
            // Resolve git root
            let git_root = match code_core::git_worktree::get_git_root_from(&cwd).await {
                Ok(p) => p,
                Err(e) => {
                    tx.send_background_event_with_ticket(
                        &ticket,
                        format!("`/branch` — not a git repo: {}", e),
                    );
                    return;
                }
            };
            let current_base_branch = Command::new("git")
                .current_dir(&git_root)
                .args(["branch", "--show-current"])
                .output()
                .await
                .ok()
                .filter(|o| o.status.success())
                .and_then(|o| {
                    let name = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if name.is_empty() { None } else { Some(name) }
                });
            // Determine branch name
            let task_opt = if args.trim().is_empty() {
                None
            } else {
                Some(args.trim())
            };
            let branch_name = code_core::git_worktree::generate_branch_name_from_task(task_opt);
            // Create worktree
            let (worktree, used_branch) =
                match code_core::git_worktree::setup_worktree(&git_root, &branch_name, None).await {
                    Ok((p, b)) => (p, b),
                    Err(e) => {
                        tx.send_background_event_with_ticket(
                            &ticket,
                            format!("`/branch` — failed to create worktree: {}", e),
                        );
                        return;
                    }
                };
            remember_worktree_root_hint(&worktree, &git_root);
            // Copy uncommitted changes from the source root into the new worktree
            let copied =
                match code_core::git_worktree::copy_uncommitted_to_worktree(&git_root, &worktree)
                    .await
                {
                    Ok(n) => n,
                    Err(e) => {
                        tx.send_background_event_with_ticket(
                            &ticket,
                            format!("`/branch` — failed to copy changes: {}", e),
                        );
                        // Still switch to the branch even if copy fails
                        0
                    }
                };

            let mut branch_metadata: Option<code_core::git_worktree::BranchMetadata> = None;
            match code_core::git_worktree::ensure_local_default_remote(
                &git_root,
                current_base_branch.as_deref(),
            )
            .await
            {
                Ok(meta_option) => {
                    if let Some(meta) = meta_option.clone() {
                        if let Err(e) = code_core::git_worktree::write_branch_metadata(&worktree, &meta).await
                        {
                            tx.send_background_event_with_ticket(
                                &ticket,
                                format!("`/branch` — failed to record branch metadata: {}", e),
                            );
                        }
                        branch_metadata = meta_option;
                    }
                }
                Err(err) => {
                    tx.send_background_event_with_ticket(
                        &ticket,
                        format!(
                            "`/branch` — failed to configure local-default remote: {}",
                            err
                        ),
                    );
                }
            }

            // Attempt to set upstream for the new branch to match the source branch's upstream,
            // falling back to origin/<default> when available. Also ensure origin/HEAD is set.
            let mut _upstream_msg: Option<String> = None;
            // Discover source branch upstream like 'origin/main'
            let src_upstream = Command::new("git")
                .current_dir(&git_root)
                .args(["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{u}"])
                .output()
                .await
                .ok()
                .filter(|o| o.status.success())
                .and_then(|o| {
                    let s = String::from_utf8_lossy(&o.stdout).trim().to_string();
                    if s.is_empty() { None } else { Some(s) }
                });
            // Ensure origin/HEAD points at the remote default, if origin exists.
            let _ = Command::new("git")
                .current_dir(&git_root)
                .args(["remote", "set-head", "origin", "-a"])
                .output()
                .await;
            // Compute fallback remote default
            let fallback_remote = code_core::git_worktree::detect_default_branch(&git_root)
                .await
                .map(|d| format!("origin/{}", d));
            let target_upstream = src_upstream.clone().or(fallback_remote);
            if let Some(up) = target_upstream {
                let set = Command::new("git")
                    .current_dir(&worktree)
                    .args([
                        "branch",
                        "--set-upstream-to",
                        up.as_str(),
                        used_branch.as_str(),
                    ])
                    .output()
                    .await;
                if let Ok(o) = set {
                    if o.status.success() {
                        _upstream_msg =
                            Some(format!("Set upstream for '{}' to {}", used_branch, up));
                    } else {
                        let e = String::from_utf8_lossy(&o.stderr).trim().to_string();
                        if !e.is_empty() {
                            _upstream_msg = Some(format!("Upstream not set ({}).", e));
                        }
                    }
                }
            }

            // Build clean multi-line output as a BackgroundEvent (not streaming Answer)
            let base_summary = branch_metadata
                .as_ref()
                .and_then(|meta| {
                    if let Some(remote_ref) = meta.remote_ref.as_ref() {
                        Some(format!("\n  Base: {remote_ref}"))
                    } else if let (Some(remote_name), Some(base_branch)) =
                        (meta.remote_name.as_ref(), meta.base_branch.as_ref())
                    {
                        Some(format!("\n  Base: {remote_name}/{base_branch}"))
                    } else if let Some(remote_name) = meta.remote_name.as_ref() {
                        Some(format!("\n  Base remote: {remote_name}"))
                    } else {
                        None
                    }
                })
                .unwrap_or_default();
            let msg = if let Some(task_text) = task_opt {
                format!(
                    "Created worktree '{used}'\n  Path: {path}\n  Copied {copied} changed files{base}\n  Task: {task}\n  Starting task...",
                    used = used_branch,
                    path = worktree.display(),
                    copied = copied,
                    task = task_text,
                    base = base_summary
                )
            } else {
                format!(
                    "Created worktree '{used}'\n  Path: {path}\n  Copied {copied} changed files{base}\n  Type your task when ready.",
                    used = used_branch,
                    path = worktree.display(),
                    copied = copied,
                    base = base_summary
                )
            };
            tx.send_background_event_with_ticket(&ticket, msg);

            // Switch cwd and optionally submit the task
            // Prefix the auto-submitted task so it's obvious it started in the new branch
            let initial_prompt = task_opt.map(|s| format!("[branch created] {}", s));
            let _ = tx.send(AppEvent::SwitchCwd(worktree, initial_prompt));
        });
    }

    pub(crate) fn handle_push_command(&mut self) {
        self.consume_pending_prompt_for_ui_only_turn();
        if self.ensure_git_repo_for_action(
            GitInitResume::DispatchCommand {
                command: SlashCommand::Push,
                command_text: "/push".to_string(),
            },
            "Pushing changes requires a git repository.",
        ) {
            return;
        }
        let Some(git_root) =
            code_core::git_info::resolve_root_git_project_for_trust(&self.config.cwd)
        else {
            self.push_background_tail("`/push` — run this command inside a git repository.".to_string());
            self.request_redraw();
            return;
        };

        self.push_background_tail("Commit, push and monitor workflows.".to_string());
        self.request_redraw();

        let tx = self.app_event_tx.clone();
        let ticket = self.make_background_tail_ticket();
        let worktree = git_root.clone();

        tokio::spawn(async move {
            use std::fmt::Write as _;
            use tokio::{fs, process::Command};

            let short_status = match ChatWidget::git_short_status(&worktree).await {
                Ok(output) => output,
                Err(err) => {
                    tx.send_background_event_with_ticket(
                        &ticket,
                        format!("`/push` — failed to read git status: {err}"),
                    );
                    return;
                }
            };
            let has_dirty_changes = short_status.lines().any(|line| !line.trim().is_empty());

            let gh_available = Command::new("gh")
                .arg("--version")
                .output()
                .await
                .map(|out| out.status.success())
                .unwrap_or(false);

            let workflow_dir = worktree.join(".github").join("workflows");
            let workflows_exist = if fs::metadata(&workflow_dir)
                .await
                .map(|meta| meta.is_dir())
                .unwrap_or(false)
            {
                match fs::read_dir(&workflow_dir).await {
                    Ok(mut dir) => {
                        let mut found = false;
                        loop {
                            match dir.next_entry().await {
                                Ok(Some(entry)) => {
                                    if entry
                                        .file_type()
                                        .await
                                        .map(|ft| ft.is_file())
                                        .unwrap_or(false)
                                    {
                                        found = true;
                                        break;
                                    }
                                }
                                Ok(None) | Err(_) => {
                                    break;
                                }
                            }
                        }
                        found
                    }
                    Err(_) => false,
                }
            } else {
                false
            };

            let status_snippet = if short_status.trim().is_empty() {
                "(clean working tree)".to_string()
            } else {
                short_status.trim_end().to_string()
            };

            let diff_output = Command::new("git")
                .current_dir(&worktree)
                .args(["diff", "--cached"])
                .output()
                .await;
            let diff_snippet = match diff_output {
                Ok(out) if out.status.success() => {
                    let diff_text = String::from_utf8_lossy(&out.stdout);
                    if diff_text.trim().is_empty() {
                        "(no staged changes)".to_string()
                    } else {
                        const MAX_LINES: usize = 200;
                        const MAX_CHARS: usize = 16_000;
                        let mut preview = String::new();
                        let mut truncated = false;
                        let mut emitted = 0usize;
                        let mut chars = 0usize;
                        for line in diff_text.lines() {
                            if emitted >= MAX_LINES || chars >= MAX_CHARS {
                                truncated = true;
                                break;
                            }
                            preview.push_str(line);
                            preview.push('\n');
                            emitted += 1;
                            chars += line.len() + 1;
                        }
                        if truncated {
                            preview.push_str("…\n(truncated)\n");
                        }
                        preview.trim_end().to_string()
                    }
                }
                Ok(out) => {
                    let err = String::from_utf8_lossy(&out.stderr).trim().to_string();
                    if err.is_empty() {
                        "(failed to read staged diff)".to_string()
                    } else {
                        format!("(failed to read staged diff: {err})")
                    }
                }
                Err(err) => format!("(failed to run git diff --cached: {err})"),
            };

            let mut steps = Vec::new();
            if has_dirty_changes {
                steps.push(
                    "Briefly clean this repo (add working files/secrets to .gitignore, delete any temporary files) if neccessary, then commit all remaining dirty files."
                        .to_string(),
                );
            }
            steps.push(
                "Run git pull and merge any remote changes, carefully. Ensure conflicts are resolved line-by-line, do not bulk checkout or prefer changes from one side or the other."
                    .to_string(),
            );
            steps.push("Perform a git push.".to_string());
            if gh_available && workflows_exist {
                steps.push(
                    "Use gh_run_wait to monitor any triggered workflows."
                        .to_string(),
                );
                steps.push(
                    "If the workflow fails, then view errors, commit, push, monitor and repeat until the workflow succeeds."
                        .to_string(),
                );
            }

            let mut message = String::from("You have permission to commit and push.\n");
            message.push_str("\nRepository snapshot:\n");
            message.push_str("`git status --short`:\n");
            message.push_str(&status_snippet);
            message.push_str("\n\n`git diff --cached` (first 200 lines, 16k chars):\n");
            message.push_str(&diff_snippet);
            message.push_str("\n\n");
            for (idx, step) in steps.iter().enumerate() {
                let _ = writeln!(message, "{}. {}", idx + 1, step);
            }
            message.push_str(
                "You must ensure all workflows complete successfully. Do not yeild or respond until this has been completed.",
            );

            tx.send(AppEvent::SubmitHiddenTextWithPreface {
                agent_text: message,
                preface: String::new(),
                surface_notice: false,
            });
        });
    }

    pub(crate) fn handle_weave_command(&mut self, args: String) {
        let args = args.trim();
        if args.is_empty() || args.eq_ignore_ascii_case("menu") {
            self.request_weave_session_menu();
            return;
        }

        let mut parts = args.splitn(2, |c: char| c.is_whitespace());
        let subcommand = parts.next().unwrap_or("").trim();
        let rest = parts.next().unwrap_or("").trim();

        match subcommand {
            "name" => {
                if rest.is_empty() {
                    self.app_event_tx.send(AppEvent::OpenWeaveAgentNamePrompt);
                } else {
                    self.set_weave_agent_name(rest.to_string());
                }
            }
            "create" => {
                if rest.is_empty() {
                    self.app_event_tx
                        .send(AppEvent::OpenWeaveSessionCreatePrompt);
                } else {
                    self.create_weave_session(Some(rest.to_string()));
                }
            }
            "close" => {
                if rest.is_empty() {
                    self.request_weave_session_close_menu();
                } else {
                    self.close_weave_session(rest.to_string());
                }
            }
            "join" => {
                if rest.is_empty() {
                    self.request_weave_session_menu();
                } else {
                    self.set_weave_session_selection(Some(WeaveSession {
                        id: rest.to_string(),
                        name: None,
                    }));
                }
            }
            "leave" | "disconnect" => {
                self.set_weave_session_selection(None);
            }
            "refresh" => {
                self.request_weave_agent_list();
            }
            "help" => {
                let kind = crate::history::state::PlainMessageKind::Notice;
                let role = crate::history_cell::plain_role_for_kind(kind);
                let mut state = crate::history_cell::plain_message_state_from_paragraphs(
                    kind,
                    role,
                    vec![
                        "/weave".to_string(),
                        "/weave name <name>".to_string(),
                        "/weave create <session name>".to_string(),
                        "/weave join <session id>".to_string(),
                        "/weave leave".to_string(),
                        "/weave close <session id>".to_string(),
                        "/weave refresh".to_string(),
                    ],
                );
                state.header = Some(crate::history::state::MessageHeader {
                    label: "weave".to_string(),
                    badge: None,
                });
                self.history_push_plain_state(state);
                self.request_redraw();
            }
            _ => {
                self.history_push_plain_state(crate::history_cell::new_error_event(format!(
                    "Unknown /weave subcommand: {subcommand}. Try `/weave help`."
                )));
                self.request_redraw();
            }
        }
    }

    fn request_weave_session_menu(&self) {
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            match weave_client::list_sessions().await {
                Ok(mut sessions) => {
                    sessions.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                    tx.send(AppEvent::OpenWeaveSessionMenu { sessions });
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to list Weave sessions: {err}"),
                    });
                }
            }
        });
    }

    fn request_weave_session_close_menu(&self) {
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            match weave_client::list_sessions().await {
                Ok(mut sessions) => {
                    sessions.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                    tx.send(AppEvent::OpenWeaveSessionCloseMenu { sessions });
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to list Weave sessions: {err}"),
                    });
                }
            }
        });
    }

    pub(crate) fn open_weave_session_menu(&mut self, sessions: Vec<WeaveSession>) {
        let current_session = self.selected_weave_session_name.clone();
        let connected = self.weave_agent_connection.is_some();
        let subtitle = if let Some(label) = current_session {
            let status = if connected { "connected" } else { "connecting…" };
            format!("agent: {} • session: {} ({status})", self.weave_agent_name, label)
        } else {
            format!("agent: {} • not connected", self.weave_agent_name)
        };

        let mut items: Vec<SelectionItem> = Vec::new();

        items.push(SelectionItem {
            name: "Set agent name".to_string(),
            description: Some(format!("Current: {}", self.weave_agent_name)),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(AppEvent::OpenWeaveAgentNamePrompt);
            })],
        });
        let color_label = self
            .weave_agent_accent
            .map(|idx| format!("{idx}"))
            .unwrap_or_else(|| "auto".to_string());
        items.push(SelectionItem {
            name: "Set agent color".to_string(),
            description: Some(format!("Current: {}", color_label)),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(AppEvent::OpenWeaveAgentColorMenu);
            })],
        });
        items.push(SelectionItem {
            name: "Create new session".to_string(),
            description: Some("Create and join a new Weave session.".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(AppEvent::OpenWeaveSessionCreatePrompt);
            })],
        });
        items.push(SelectionItem {
            name: "Close session".to_string(),
            description: Some("Close an existing Weave session.".to_string()),
            is_current: false,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                let tx = tx.clone();
                tokio::spawn(async move {
                    match weave_client::list_sessions().await {
                        Ok(mut sessions) => {
                            sessions.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                            tx.send(AppEvent::OpenWeaveSessionCloseMenu { sessions });
                        }
                        Err(err) => {
                            tx.send(AppEvent::WeaveError {
                                message: format!("Failed to list Weave sessions: {err}"),
                            });
                        }
                    }
                });
            })],
        });

        let selected_id = self.selected_weave_session_id.as_deref();
        for session in sessions {
            let session_id = session.id.clone();
            let display_name = session.display_name();
            let is_selected = selected_id == Some(session_id.as_str());
            let label = if is_selected {
                format!("✓ {display_name}")
            } else {
                display_name
            };
            let selection = if is_selected { None } else { Some(session.clone()) };
            items.push(SelectionItem {
                name: label,
                description: Some(format!("id: {session_id}")),
                is_current: is_selected,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(AppEvent::SetWeaveSessionSelection {
                        session: selection.clone(),
                    });
                })],
            });
        }

        let view = ListSelectionView::new(
            " Weave ".to_string(),
            Some(subtitle),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane
            .show_list_selection("Weave".to_string(), None, None, view);
    }

    pub(crate) fn open_weave_session_close_menu(&mut self, sessions: Vec<WeaveSession>) {
        let mut items: Vec<SelectionItem> = Vec::new();
        for session in sessions {
            let session_id = session.id.clone();
            let display_name = session.display_name();
            items.push(SelectionItem {
                name: display_name,
                description: Some(format!("id: {session_id}")),
                is_current: false,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(AppEvent::CloseWeaveSession {
                        session_id: session_id.clone(),
                    });
                })],
            });
        }

        let view = ListSelectionView::new(
            " Close Weave session ".to_string(),
            Some("Select a session to close".to_string()),
            Some("Enter close · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane
            .show_list_selection("Close Weave session".to_string(), None, None, view);
    }

    pub(crate) fn open_weave_agent_name_prompt(&mut self) {
        let current = self.weave_agent_name.clone();
        let submit_tx = self.app_event_tx.clone();
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            submit_tx.send(AppEvent::SetWeaveAgentName { name: text });
        });
        let view = CustomPromptView::new(
            "Weave agent name".to_string(),
            "Type a name and press Enter".to_string(),
            Some(format!("Current: {current}")),
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    pub(crate) fn open_weave_agent_color_menu(&mut self) {
        let current = self.weave_agent_accent;

        let mut items: Vec<SelectionItem> = Vec::new();
        let is_auto = current.is_none();
        items.push(SelectionItem {
            name: if is_auto {
                "✓ Auto".to_string()
            } else {
                "Auto".to_string()
            },
            description: Some("Choose a stable color based on agent id.".to_string()),
            is_current: is_auto,
            actions: vec![Box::new(|tx: &crate::app_event_sender::AppEventSender| {
                tx.send(AppEvent::SetWeaveAgentColor { accent: None });
            })],
        });

        for accent in 0..8 {
            let is_current = current == Some(accent);
            let label = if is_current {
                format!("✓ Accent {accent}")
            } else {
                format!("Accent {accent}")
            };
            let selected = Some(accent);
            items.push(SelectionItem {
                name: label,
                description: None,
                is_current,
                actions: vec![Box::new(move |tx: &crate::app_event_sender::AppEventSender| {
                    tx.send(AppEvent::SetWeaveAgentColor { accent: selected });
                })],
            });
        }

        let subtitle = format!("agent: {}", self.weave_agent_name);
        let view = ListSelectionView::new(
            " Weave agent color ".to_string(),
            Some(subtitle),
            Some("Enter select · Esc cancel".to_string()),
            items,
            self.app_event_tx.clone(),
            10,
        );

        self.bottom_pane
            .show_list_selection("Weave agent color".to_string(), None, None, view);
    }

    pub(crate) fn open_weave_session_create_prompt(&mut self) {
        let submit_tx = self.app_event_tx.clone();
        let on_submit: Box<dyn Fn(String) + Send + Sync> = Box::new(move |text: String| {
            submit_tx.send(AppEvent::CreateWeaveSession { name: Some(text) });
        });
        let view = CustomPromptView::new(
            "Create Weave session".to_string(),
            "Type a session name and press Enter".to_string(),
            None,
            self.app_event_tx.clone(),
            None,
            on_submit,
        );
        self.bottom_pane.show_custom_prompt(view);
    }

    fn choose_unique_weave_agent_name(&self, requested: &str, agents: &[WeaveAgent]) -> String {
        let requested = requested.trim();
        if requested.is_empty() {
            return String::new();
        }

        let mut taken: HashSet<String> = HashSet::new();
        for agent in agents {
            if agent.id == self.weave_agent_id {
                continue;
            }
            taken.insert(agent.mention_text().to_ascii_lowercase());
        }

        let requested_key = requested.to_ascii_lowercase();
        if !taken.contains(&requested_key) {
            return requested.to_string();
        }

        for suffix in 2..=99 {
            let candidate = format!("{requested}-{suffix}");
            if !taken.contains(&candidate.to_ascii_lowercase()) {
                return candidate;
            }
        }

        let short = self
            .weave_agent_id
            .split('-')
            .next()
            .unwrap_or(self.weave_agent_id.as_str());
        let candidate = format!("{requested}-{short}");
        if !taken.contains(&candidate.to_ascii_lowercase()) {
            return candidate;
        }

        format!("{requested}-{}", self.weave_agent_id)
    }

    pub(crate) fn set_weave_agent_name(&mut self, name: String) {
        let trimmed = name.trim();
        if trimmed.is_empty() {
            return;
        }
        if trimmed.chars().any(char::is_whitespace) {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "Weave names must be a single token (no spaces).".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let requested = trimmed.to_string();
        let resolved = self
            .weave_agents
            .as_deref()
            .map(|agents| self.choose_unique_weave_agent_name(&requested, agents))
            .unwrap_or_else(|| requested.clone());

        if self.weave_agent_name == resolved {
            return;
        }
        self.weave_agent_name = resolved.clone();
        self.persist_weave_identity();
        self.refresh_weave_footer_status();
        if resolved == requested {
            self.bottom_pane
                .flash_footer_notice(format!("Weave name set to {}", self.weave_agent_name));
        } else {
            self.bottom_pane.flash_footer_notice(format!(
                "Weave name '{}' is taken; using '{}'.",
                requested, resolved
            ));
        }

        if let Some(connection) = self.weave_agent_connection.as_mut() {
            connection.set_agent_name(self.weave_agent_name.clone());
            let sender = connection.sender();
            let name = self.weave_agent_name.clone();
            let tx = self.app_event_tx.clone();
            tokio::spawn(async move {
                if let Err(err) = sender.update_agent_name(name).await {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to update Weave agent name: {err}"),
                    });
                }
            });
        }
    }

    pub(crate) fn set_weave_agent_color(&mut self, accent: Option<u8>) {
        let accent = accent.map(|accent| accent % 8);
        if self.weave_agent_accent == accent {
            return;
        }

        self.weave_agent_accent = accent;
        if let Some(accent) = accent {
            crate::history_cell::weave::set_weave_agent_accent_override(
                self.weave_agent_id.clone(),
                accent,
            );
        } else {
            crate::history_cell::weave::clear_weave_agent_accent_override(&self.weave_agent_id);
        }
        self.persist_weave_identity();

        let label = accent
            .map(|accent| format!("Accent {accent}"))
            .unwrap_or_else(|| "auto".to_string());
        self.bottom_pane
            .flash_footer_notice(format!("Weave color set to {label}"));
        self.request_redraw();
    }

    pub(crate) fn set_weave_session_selection(&mut self, session: Option<WeaveSession>) {
        let (session_id, session_name) = session.map_or((None, None), |session| {
            let label = session.display_name();
            (Some(session.id), Some(label))
        });

        if self.selected_weave_session_id == session_id {
            if self.selected_weave_session_name != session_name {
                self.selected_weave_session_name = session_name;
                self.request_redraw();
            }
            return;
        }

        self.disconnect_weave_agent();
        self.selected_weave_session_id = session_id;
        self.selected_weave_session_name = session_name;

        if let Some(session_id) = self.selected_weave_session_id.clone() {
            self.weave_agents = Some(Vec::new());
            self.bottom_pane.set_weave_mention_candidates(Vec::new());
            self.connect_weave_agent(session_id);
        } else {
            self.weave_agents = None;
            self.bottom_pane.set_weave_mention_candidates(Vec::new());
        }

        self.refresh_weave_footer_status();
        self.request_redraw();
    }

    pub(crate) fn create_weave_session(&mut self, name: Option<String>) {
        let tx = self.app_event_tx.clone();
        let name = name
            .as_deref()
            .map(str::trim)
            .filter(|name| !name.is_empty())
            .map(ToString::to_string);
        tokio::spawn(async move {
            match weave_client::create_session(name).await {
                Ok(session) => {
                    tx.send(AppEvent::SetWeaveSessionSelection {
                        session: Some(session),
                    });
                    match weave_client::list_sessions().await {
                        Ok(mut sessions) => {
                            sessions.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                            tx.send(AppEvent::OpenWeaveSessionMenu { sessions });
                        }
                        Err(_) => {}
                    }
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to create Weave session: {err}"),
                    });
                }
            }
        });
    }

    pub(crate) fn close_weave_session(&mut self, session_id: String) {
        let should_leave = self.selected_weave_session_id.as_deref() == Some(session_id.as_str());
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            match weave_client::close_session(&session_id).await {
                Ok(()) => {
                    if should_leave {
                        tx.send(AppEvent::SetWeaveSessionSelection { session: None });
                    }
                    match weave_client::list_sessions().await {
                        Ok(mut sessions) => {
                            sessions.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                            tx.send(AppEvent::OpenWeaveSessionMenu { sessions });
                        }
                        Err(_) => {}
                    }
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to close Weave session {session_id}: {err}"),
                    });
                }
            }
        });
    }

    fn connect_weave_agent(&mut self, session_id: String) {
        let agent_id = self.weave_agent_id.clone();
        let agent_name = self.weave_agent_name.clone();
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            match weave_client::connect_agent(session_id.clone(), agent_id, Some(agent_name)).await
            {
                Ok(connection) => {
                    tx.send(AppEvent::WeaveAgentConnected {
                        session_id,
                        connection,
                    });
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to join Weave session {session_id}: {err}"),
                    });
                    tx.send(AppEvent::SetWeaveSessionSelection { session: None });
                }
            }
        });
    }

    fn disconnect_weave_agent(&mut self) {
        if let Some(mut connection) = self.weave_agent_connection.take() {
            connection.shutdown();
        }
        self.weave_agents = None;
    }

    fn request_weave_agent_list(&self) {
        let Some(session_id) = self.selected_weave_session_id.clone() else {
            return;
        };
        let src = self.weave_agent_id.clone();
        let tx = self.app_event_tx.clone();
        tokio::spawn(async move {
            match weave_client::list_agents(&session_id, &src).await {
                Ok(mut agents) => {
                    agents.sort_by(|a, b| a.display_name().cmp(&b.display_name()));
                    tx.send(AppEvent::WeaveAgentsListed { session_id, agents });
                }
                Err(err) => {
                    tx.send(AppEvent::WeaveError {
                        message: format!("Failed to list Weave agents: {err}"),
                    });
                }
            }
        });
    }

    pub(crate) fn on_weave_agent_connected(
        &mut self,
        session_id: String,
        mut connection: WeaveAgentConnection,
    ) {
        if self.selected_weave_session_id.as_deref() != Some(session_id.as_str()) {
            connection.shutdown();
            return;
        }
        if let Some(mut incoming_rx) = connection.take_incoming_rx() {
            let tx = self.app_event_tx.clone();
            let session_id_for_event = session_id.clone();
            tokio::spawn(async move {
                while let Some(message) = incoming_rx.recv().await {
                    tx.send(AppEvent::WeaveMessageReceived { message });
                }
                tx.send(AppEvent::WeaveAgentDisconnected {
                    session_id: session_id_for_event,
                });
            });
        }
        self.weave_agent_connection = Some(connection);
        self.request_weave_agent_list();
        self.refresh_weave_footer_status();
    }

    pub(crate) fn on_weave_agent_disconnected(&mut self, session_id: &str) {
        if self.selected_weave_session_id.as_deref() != Some(session_id) {
            return;
        }
        let label = self
            .selected_weave_session_name
            .clone()
            .unwrap_or_else(|| session_id.to_string());
        self.set_weave_session_selection(None);
        self.history_push_plain_state(crate::history_cell::new_error_event(format!(
            "Weave session closed: {label}"
        )));
        self.refresh_weave_footer_status();
        self.request_redraw();
    }

    pub(crate) fn apply_weave_agent_list(&mut self, session_id: String, agents: Vec<WeaveAgent>) {
        if self.selected_weave_session_id.as_deref() != Some(session_id.as_str()) {
            return;
        }
        let mut candidates: Vec<String> = agents
            .iter()
            .filter(|agent| agent.id != self.weave_agent_id)
            .map(WeaveAgent::mention_text)
            .collect();
        candidates.sort();
        candidates.dedup();

        self.bottom_pane.set_weave_mention_candidates(candidates);
        self.weave_agents = Some(agents);
        if let Some(agents) = self.weave_agents.as_deref() {
            let requested = self.weave_agent_name.clone();
            let resolved = self.choose_unique_weave_agent_name(&requested, agents);
            if resolved != requested {
                self.weave_agent_name = resolved.clone();
                self.persist_weave_identity();
                self.refresh_weave_footer_status();
                self.bottom_pane.flash_footer_notice(format!(
                    "Weave name '{}' is taken; using '{}'.",
                    requested, resolved
                ));

                if let Some(connection) = self.weave_agent_connection.as_mut() {
                    connection.set_agent_name(resolved.clone());
                    let sender = connection.sender();
                    let name = resolved;
                    let tx = self.app_event_tx.clone();
                    tokio::spawn(async move {
                        if let Err(err) = sender.update_agent_name(name).await {
                            tx.send(AppEvent::WeaveError {
                                message: format!("Failed to update Weave agent name: {err}"),
                            });
                        }
                    });
                }
            }
        }
        self.request_redraw();
    }

    fn strip_weave_mentions(text: &str, recipients: &[WeaveAgent]) -> String {
        let mut mention_keys: HashSet<String> = recipients
            .iter()
            .map(|agent| agent.mention_text().to_ascii_lowercase())
            .collect();
        // Defensive: also allow stripping by id when names might be ambiguous.
        for agent in recipients {
            mention_keys.insert(agent.id.to_ascii_lowercase());
        }

        let mut out: Vec<&str> = Vec::new();
        for token in text.split_whitespace() {
            if let Some(label) = weave::parse_weave_mention_label(token) {
                if mention_keys.contains(&label.to_ascii_lowercase()) {
                    continue;
                }
            }
            out.push(token);
        }
        out.join(" ")
    }

    fn try_submit_weave_task_message(&mut self, message: &UserMessage) -> bool {
        if self.weave_agent_connection.is_none() {
            return false;
        }

        let raw_text = message.display_text.trim();
        if raw_text.is_empty() {
            return false;
        }

        if raw_text.starts_with('/') {
            return false;
        }

        let text_only = message
            .ordered_items
            .iter()
            .all(|item| matches!(item, InputItem::Text { .. }));
        if !text_only {
            return false;
        }

        let Some(agents) = self.weave_agents.as_ref() else {
            return false;
        };

        let recipients =
            weave::find_weave_mentions(raw_text, agents, Some(self.weave_agent_id.as_str()));
        if recipients.is_empty() {
            return false;
        }

        let stripped = Self::strip_weave_mentions(raw_text, &recipients);
        let stripped = stripped.trim();
        if stripped.is_empty() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "Weave message is empty after removing mentions.".to_string(),
            ));
            self.request_redraw();
            return true;
        }

        let recipient_id_labels = recipients
            .iter()
            .map(|agent| (agent.id.clone(), agent.display_name()))
            .collect::<Vec<_>>();
        self.history_push_plain_state(crate::history_cell::new_weave_outbound(
            self.weave_agent_id.clone(),
            self.weave_agent_name.clone(),
            recipient_id_labels,
            stripped.to_string(),
        ));
        self.request_redraw();

        let sender = self
            .weave_agent_connection
            .as_ref()
            .expect("checked above")
            .sender();
        let message_text = stripped.to_string();
        tokio::spawn(async move {
            for agent in recipients {
                if let Err(err) = sender
                    .send_message_with_metadata(agent.id, message_text.clone(), None)
                    .await
                {
                    tracing::warn!("failed to send Weave message: {}", err);
                }
            }
        });

        true
    }

    pub(crate) fn on_weave_message_received(&mut self, message: WeaveIncomingMessage) {
        let WeaveIncomingMessage {
            session_id,
            message_id: _,
            src,
            src_name,
            text,
            kind: _,
            conversation_id: _,
            conversation_owner: _,
            parent_message_id: _,
        } = message;
        if self.selected_weave_session_id.as_deref() != Some(session_id.as_str()) {
            return;
        }
        if text.trim().is_empty() {
            return;
        }
        let display_src = src_name.unwrap_or_else(|| src.clone());
        self.history_push_plain_state(crate::history_cell::new_weave_inbound(
            src,
            display_src,
            self.weave_agent_id.clone(),
            self.weave_agent_name.clone(),
            text,
        ));
        self.request_redraw();
    }

    pub(crate) fn handle_project_command(&mut self, args: String) {
        let name = args.trim();
        if name.is_empty() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/cmd` — provide a project command name".to_string(),
            ));
            self.request_redraw();
            return;
        }

        if self.config.project_commands.is_empty() {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "No project commands configured for this workspace.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        if let Some(cmd) = self
            .config
            .project_commands
            .iter()
            .find(|command| command.matches(name))
            .cloned()
        {
            let notice = if let Some(desc) = &cmd.description {
                format!("Running project command `{}` — {}", cmd.name, desc)
            } else {
                format!("Running project command `{}`", cmd.name)
            };
            self.insert_background_event_with_placement(
                notice,
                BackgroundPlacement::BeforeNextOutput,
                None,
            );
            self.request_redraw();
            self.submit_op(Op::RunProjectCommand { name: cmd.name });
        } else {
            let available: Vec<String> = self
                .config
                .project_commands
                .iter()
                .map(|cmd| cmd.name.clone())
                .collect();
            let suggestion = if available.is_empty() {
                "".to_string()
            } else {
                format!(" Available commands: {}", available.join(", "))
            };
            self.history_push_plain_state(crate::history_cell::new_error_event(format!(
                "Unknown project command `{}`.{}",
                name,
                suggestion
            )));
            self.request_redraw();
        }
    }

    pub(crate) fn switch_cwd(
        &mut self,
        new_cwd: std::path::PathBuf,
        initial_prompt: Option<String>,
    ) {
        let previous_cwd = self.config.cwd.clone();
        self.config.cwd = new_cwd.clone();
        remember_cwd_history(&self.config.cwd);
        let ticket = self.make_background_tail_ticket();

        let msg = format!(
            "✅ Working directory changed\n  from: {}\n  to:   {}",
            previous_cwd.display(),
            new_cwd.display()
        );
        self.app_event_tx
            .send_background_event_with_ticket(&ticket, msg);

        let worktree_hint = new_cwd
            .file_name()
            .and_then(|n| n.to_str())
            .map(|name| format!(" (worktree: {})", name))
            .unwrap_or_default();
        let default_branch_note = format!(
            "System: Working directory changed from {} to {}{}. Use {} for subsequent commands.",
            previous_cwd.display(),
            new_cwd.display(),
            worktree_hint,
            new_cwd.display()
        );
        let branch_note = if Self::is_branch_worktree_path(&new_cwd) {
            if let Some(meta) = code_core::git_worktree::load_branch_metadata(&new_cwd) {
                let branch_name = new_cwd
                    .file_name()
                    .and_then(|n| n.to_str())
                    .map(|s| s.to_string())
                    .unwrap_or_else(|| new_cwd.display().to_string());
                let base_descriptor = meta
                    .remote_ref
                    .clone()
                    .or_else(|| {
                        if let (Some(remote_name), Some(base_branch)) =
                            (meta.remote_name.clone(), meta.base_branch.clone())
                        {
                            Some(format!("{}/{}", remote_name, base_branch))
                        } else {
                            None
                        }
                    })
                    .or(meta.base_branch.clone())
                    .unwrap_or_else(|| code_core::git_worktree::LOCAL_DEFAULT_REMOTE.to_string());
                let mut note = format!(
                    "System: Working directory changed from {} to {}{}. You are now working on branch '{}' checked out at {}. Compare against '{}' for the parent branch and run all commands from this directory.",
                    previous_cwd.display(),
                    new_cwd.display(),
                    worktree_hint,
                    branch_name,
                    new_cwd.display(),
                    base_descriptor
                );
                if let (Some(remote_name), Some(remote_url)) =
                    (meta.remote_name.as_ref(), meta.remote_url.as_ref())
                {
                    note.push_str(&format!(
                        " The remote '{}' points to {}.",
                        remote_name,
                        remote_url
                    ));
                }
                note
            } else {
                default_branch_note.clone()
            }
        } else {
            default_branch_note.clone()
        };
        self.queue_agent_note(branch_note);

        let op = Op::ConfigureSession {
            provider: self.config.model_provider.clone(),
            model: self.config.model.clone(),
            model_explicit: self.config.model_explicit,
            model_reasoning_effort: self.config.model_reasoning_effort,
            preferred_model_reasoning_effort: self.config.preferred_model_reasoning_effort,
            model_reasoning_summary: self.config.model_reasoning_summary,
            model_text_verbosity: self.config.model_text_verbosity,
            user_instructions: self.config.user_instructions.clone(),
            base_instructions: self.config.base_instructions.clone(),
            approval_policy: self.config.approval_policy.clone(),
            sandbox_policy: self.config.sandbox_policy.clone(),
            disable_response_storage: self.config.disable_response_storage,
            notify: self.config.notify.clone(),
            cwd: self.config.cwd.clone(),
            resume_path: None,
            demo_developer_message: self.config.demo_developer_message.clone(),
        };
        self.submit_op(op);

        if let Some(prompt) = initial_prompt {
            if !prompt.is_empty() {
                let preface = "[internal] When you finish this task, ask the user if they want any changes. If they are happy, offer to merge the branch back into the repository's default branch and delete the worktree. Use '/merge' (or an equivalent git worktree remove + switch) rather than deleting the folder directly so the UI can switch back cleanly. Wait for explicit confirmation before merging.".to_string();
                self.submit_text_message_with_preface(prompt, preface);
            }
        }

        self.request_redraw();
    }

    /// Handle `/merge` for branch worktrees. Attempts a clean fast-forward
    /// when both checkouts are pristine; otherwise it hands the work to the agent
    /// with explicit manual instructions.
    pub(crate) fn handle_merge_command(&mut self) {
        self.consume_pending_prompt_for_ui_only_turn();
        if self.ensure_git_repo_for_action(
            GitInitResume::DispatchCommand {
                command: SlashCommand::Merge,
                command_text: "/merge".to_string(),
            },
            "Merging a branch worktree requires a git repository.",
        ) {
            return;
        }
        if !Self::is_branch_worktree_path(&self.config.cwd) {
            self.history_push_plain_state(crate::history_cell::new_error_event(
                "`/merge` — run this command from inside a branch worktree created with '/branch'.".to_string(),
            ));
            self.request_redraw();
            return;
        }

        let merge_ticket = self.make_background_tail_ticket();
        let tx = self.app_event_tx.clone();
        let work_cwd = self.config.cwd.clone();
        let ticket = merge_ticket.clone();
        self.push_background_before_next_output(
            "Evaluating repository state before merging current branch...".to_string(),
        );
        self.request_redraw();

        tokio::spawn(async move {

            fn send_background(
                tx: &AppEventSender,
                ticket: &BackgroundOrderTicket,
                message: String,
            ) {
                tx.send_background_event_with_ticket(ticket, message);
            }

            fn send_background_late(
                tx: &AppEventSender,
                ticket: &BackgroundOrderTicket,
                message: String,
            ) {
                tx.send_background_event_with_ticket(ticket, message);
            }

            fn handoff_to_agent(
                tx: &AppEventSender,
                ticket: &BackgroundOrderTicket,
                state: MergeRepoState,
                mut reasons: Vec<String>,
            ) {
                if reasons.is_empty() {
                    reasons.push("manual follow-up requested".to_string());
                }
                let reason_text = reasons.join(", ");
                send_background(
                    tx,
                    ticket,
                    format!("`/merge` — handing off to agent ({})", reason_text),
                );
                let visible = format!(
                    "Finalize branch '{}' via /merge (agent merge required)",
                    state.worktree_branch
                );
                let preface = state.agent_preface(&reason_text);
                let _ = tx.send(AppEvent::SubmitTextWithPreface { visible, preface });
            }

            let git_root = match code_core::git_info::resolve_root_git_project_for_trust(&work_cwd) {
                Some(p) => p,
                None => {
                    send_background(&tx, &ticket, "`/merge` — not a git repo".to_string());
                    return;
                }
            };
            let merge_lock = ChatWidget::merge_lock_for_repo(&git_root);
            let _merge_guard = match merge_lock.try_lock() {
                Ok(guard) => guard,
                Err(_) => {
                    send_background(
                        &tx,
                        &ticket,
                        "`/merge` — waiting for an in-progress merge to finish".to_string(),
                    );
                    merge_lock.lock().await
                }
            };

            let state = match MergeRepoState::gather(work_cwd.clone(), git_root.clone()).await {
                Ok(state) => state,
                Err(err) => {
                    send_background(&tx, &ticket, format!("`/merge` — {}", err));
                    return;
                }
            };

            send_background(&tx, &ticket, state.snapshot_summary());

            let mut blockers = state.auto_fast_forward_blockers();
            if blockers.is_empty() {
                send_background(
                    &tx,
                    &ticket,
                    format!(
                        "`/merge` — attempting clean fast-forward of '{}' into '{}'",
                        state.worktree_branch,
                        state.default_branch_label()
                    ),
                );
                match run_fast_forward_merge(&state).await {
                    Ok(()) => {
                        send_background_late(
                            &tx,
                            &ticket,
                            format!(
                                "`/merge` — fast-forwarded '{}' into '{}' and removed the worktree",
                                state.worktree_branch,
                                state.default_branch_label()
                            ),
                        );
                        let _ = tx.send(AppEvent::SwitchCwd(state.git_root.clone(), None));
                        return;
                    }
                    Err(err) => {
                        blockers.push(err);
                    }
                }
            }

            handoff_to_agent(&tx, &ticket, state, blockers);
        });
    }

}

impl ChatWidget<'_> {
    fn render_browser_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        bottom_pane_area: Rect,
        buf: &mut Buffer,
    ) {
        use ratatui::layout::{Alignment, Constraint, Direction, Layout, Margin, Rect as RtRect};
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line as RLine, Span};
        use ratatui::widgets::{Block, Borders, Clear, Paragraph, Wrap};
        use ratatui::widgets::Widget;

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let footer_reserved = bottom_pane_area.height.min(1);
        let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height).saturating_sub(footer_reserved);
        let overlay_height = overlay_bottom
            .saturating_sub(history_area.y)
            .max(1)
            .min(frame_area.height);

        let window_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: overlay_height,
        };
        Clear.render(window_area, buf);

        let block = Block::default()
            .borders(Borders::ALL)
            .title(RLine::from(vec![
                Span::styled(
                    format!(" {} ", self.browser_title()),
                    Style::default().fg(crate::colors::text()),
                ),
                Span::styled(
                    "— Ctrl+B to close",
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]))
            .style(Style::default().bg(crate::colors::background()))
            .border_style(
                Style::default()
                    .fg(crate::colors::border())
                    .bg(crate::colors::background()),
            );
        let inner = block.inner(window_area);
        block.render(window_area, buf);

        let inner_bg = Style::default().bg(crate::colors::background());
        for y in inner.y..inner.y + inner.height {
            for x in inner.x..inner.x + inner.width {
                buf[(x, y)].set_style(inner_bg);
            }
        }

        let content = inner.inner(Margin::new(1, 0));
        if content.width == 0 || content.height == 0 {
            return;
        }

        let overlay_tracker = self.browser_overlay_tracker();
        let cell_opt = overlay_tracker.as_ref().map(|(_, tracker)| &tracker.cell);

        let (screenshot_history, mut selected_index) = if let Some(cell) = cell_opt {
            let history = cell.screenshot_history();
            if history.is_empty() {
                (None, 0usize)
            } else {
                let mut index = self.browser_overlay_state.screenshot_index();
                if index >= history.len() {
                    index = history.len().saturating_sub(1);
                    self.browser_overlay_state.set_screenshot_index(index);
                }
                (Some(history), index)
            }
        } else {
            (None, 0usize)
        };

        let screenshot_count = screenshot_history.map(|items| items.len()).unwrap_or(0);
        if screenshot_count == 0 {
            selected_index = 0;
        }

        let mut screenshot_path = screenshot_history
            .and_then(|history| history.get(selected_index))
            .map(|record| record.path.clone());
        let mut screenshot_url = screenshot_history
            .and_then(|history| history.get(selected_index))
            .and_then(|record| record.url.clone());

        if screenshot_path.is_none() {
            if let Ok(latest) = self.latest_browser_screenshot.lock() {
                if let Some((path, url)) = latest.as_ref() {
                    screenshot_path = Some(path.clone());
                    if screenshot_url.is_none() {
                        screenshot_url = Some(url.clone());
                    }
                }
            }
        }

        let summary_label = cell_opt
            .map(|cell| cell.summary_label())
            .unwrap_or_else(|| self.browser_title().to_string());
        let summary_value = screenshot_url
            .clone()
            .filter(|value| !value.is_empty())
            .unwrap_or_else(|| summary_label.clone());

        let screenshot_info = if screenshot_count > 0 {
            format!("Shot {}/{}", selected_index + 1, screenshot_count)
        } else {
            "No screenshots yet".to_string()
        };

        let is_active = screenshot_path.is_some();
        let key_hint_style = Style::default().fg(crate::colors::function());
        let label_style = Style::default().fg(crate::colors::text_dim());
        let dot_style = if is_active {
            Style::default().fg(crate::colors::success_green())
        } else {
            Style::default().fg(crate::colors::text_dim())
        };

        let header_height = if content.height >= 3 { 1 } else { 0 };
        if header_height > 0 {
            let header_area = Rect {
                x: content.x,
                y: content.y,
                width: content.width,
                height: 1,
            };

            let mut left_spans: Vec<Span> = Vec::new();
            left_spans.push(Span::styled("•", dot_style));
            if !summary_value.is_empty() {
                left_spans.push(Span::raw(" "));
                left_spans.push(Span::raw(summary_value.clone()));
            }
            left_spans.push(Span::raw("  "));
            left_spans.push(Span::styled(screenshot_info.clone(), label_style));

            let right_spans: Vec<Span> = vec![
                Span::from("Ctrl+B").style(key_hint_style),
                Span::styled(" close", label_style),
            ];

            let measure = |spans: &Vec<Span>| -> usize {
                spans.iter().map(|s| s.content.chars().count()).sum()
            };
            let left_len = measure(&left_spans);
            let right_len = measure(&right_spans);
            let total_width = header_area.width as usize;
            if total_width > left_len + right_len {
                let spacer = " ".repeat(total_width - left_len - right_len);
                left_spans.push(Span::from(spacer));
            }
            let mut spans = left_spans;
            spans.extend(right_spans);
            Paragraph::new(RLine::from(spans))
                .alignment(Alignment::Left)
                .render(header_area, buf);
        }

        let mut body_y = content.y + header_height;
        let mut body_height = content.height.saturating_sub(header_height);
        if header_height > 0 && body_height > 0 {
            body_y = body_y.saturating_add(1);
            body_height = body_height.saturating_sub(1);
        }

        if body_height == 0 {
            return;
        }

        let body_area = RtRect {
            x: content.x,
            y: body_y,
            width: content.width,
            height: body_height,
        };

        let column_constraints = if body_area.width <= 50 {
            [
                Constraint::Length(body_area.width.saturating_sub(24).max(20)),
                Constraint::Length(24),
            ]
        } else {
            [Constraint::Percentage(62), Constraint::Percentage(38)]
        };
        let columns = Layout::default()
            .direction(Direction::Horizontal)
            .constraints(column_constraints)
            .split(body_area);

        let screenshot_column = columns[0];
        let info_column = if columns.len() > 1 { columns[1] } else { columns[0] };

        let progress_height = if screenshot_column.height > 3 { 1 } else { 0 };
        let screenshot_display_height = screenshot_column.height.saturating_sub(progress_height);
        let screenshot_display_area = Rect {
            x: screenshot_column.x,
            y: screenshot_column.y,
            width: screenshot_column.width,
            height: screenshot_display_height,
        };
        let progress_area = if progress_height > 0 {
            Some(Rect {
                x: screenshot_column.x,
                y: screenshot_column
                    .y
                    .saturating_add(screenshot_column.height.saturating_sub(progress_height)),
                width: screenshot_column.width,
                height: progress_height,
            })
        } else {
            None
        };

        if screenshot_display_area.width > 0 && screenshot_display_area.height > 0 {
            if let Some(path) = screenshot_path.as_ref() {
                self.render_screenshot_highlevel(path, screenshot_display_area, buf);
            } else {
                let message = Paragraph::new(RLine::from(vec![Span::raw(
                    "No browser session captured yet.",
                )]))
                .alignment(Alignment::Center)
                .style(Style::default().fg(crate::colors::text_dim()));
                Widget::render(message, screenshot_display_area, buf);
            }
        }

        let current_time = screenshot_history
            .and_then(|history| history.get(selected_index))
            .map(|record| record.timestamp)
            .unwrap_or_else(|| Duration::ZERO);
        let mut total_time = overlay_tracker
            .as_ref()
            .map(|(_, tracker)| tracker.elapsed)
            .unwrap_or_else(|| Duration::ZERO);
        if let Some(history) = screenshot_history {
            if let Some(last) = history.last() {
                total_time = total_time.max(last.timestamp);
            }
        }
        if let Some(cell) = cell_opt {
            total_time = total_time.max(cell.total_duration());
        }

        if let Some(area) = progress_area {
            if area.height > 0 && area.width > 0 {
                let progress_line = self.browser_overlay_progress_line(area.width, current_time, total_time);
                Paragraph::new(progress_line)
                    .alignment(Alignment::Center)
                    .style(Style::default().fg(crate::colors::text()))
                    .render(area, buf);
            }
        }

        if info_column.width == 0 || info_column.height == 0 {
            return;
        }

        let header_style = Style::default()
            .fg(crate::colors::text())
            .add_modifier(Modifier::BOLD);
        let secondary_style = Style::default().fg(crate::colors::text_dim());
        let primary_style = Style::default().fg(crate::colors::text());

        let mut info_lines: Vec<RLine<'static>> = Vec::new();

        info_lines.push(RLine::from(vec![Span::styled("Screenshots", header_style)]));

        if let Some(history) = screenshot_history {
            if history.is_empty() {
                info_lines.push(RLine::from(vec![Span::styled(
                    "No screenshots yet",
                    secondary_style,
                )]));
            } else {
                for (idx, entry) in history.iter().enumerate() {
                    let mut spans: Vec<Span> = Vec::new();
                    let marker = if idx == selected_index { "◉" } else { "•" };
                    let marker_style = if idx == selected_index {
                        Style::default().fg(crate::colors::primary())
                    } else {
                        secondary_style
                    };
                    spans.push(Span::styled(marker.to_string(), marker_style));
                    spans.push(Span::raw(" "));
                    spans.push(Span::styled(
                        self.format_overlay_mm_ss(entry.timestamp),
                        secondary_style,
                    ));
                    if let Some(url) = entry.url.as_ref() {
                        if !url.trim().is_empty() {
                            spans.push(Span::raw("  "));
                            spans.push(Span::styled(url.clone(), primary_style));
                        }
                    }
                    info_lines.push(RLine::from(spans));
                }
            }
        } else {
            info_lines.push(RLine::from(vec![Span::styled(
                "No browser session yet",
                secondary_style,
            )]));
        }

        info_lines.push(RLine::from(vec![Span::raw(String::new())]));
        info_lines.push(RLine::from(vec![Span::styled("Actions", header_style)]));

        if let Some(cell) = cell_opt {
            let entries = cell.full_action_entries();
            if entries.is_empty() {
                info_lines.push(RLine::from(vec![Span::styled(
                    "No browser actions yet",
                    secondary_style,
                )]));
            } else {
                for (time, label, detail) in entries {
                    let mut spans: Vec<Span> = Vec::new();
                    spans.push(Span::styled("•", secondary_style));
                    spans.push(Span::raw(" "));
                    spans.push(Span::styled(
                        self.normalize_action_time_label(time.as_str()),
                        secondary_style,
                    ));
                    spans.push(Span::raw("  "));
                    spans.push(Span::styled(label.clone(), primary_style));
                    let detail_trimmed = detail.trim();
                    if !detail_trimmed.is_empty() {
                        spans.push(Span::raw(" "));
                        spans.push(Span::styled(detail_trimmed.to_string(), secondary_style));
                    }
                    info_lines.push(RLine::from(spans));
                }
            }
        } else {
            info_lines.push(RLine::from(vec![Span::styled(
                "No browser session yet",
                secondary_style,
            )]));
        }

        info_lines.push(RLine::from(vec![Span::raw(String::new())]));
        info_lines.push(RLine::from(vec![Span::styled(
            "Controls: ←/→ or ↑/↓ select screenshot • Shift+↑/↓ or j/k scroll actions",
            secondary_style,
        )]));

        let max_scroll = info_lines.len().saturating_sub(info_column.height as usize);
        let max_scroll_u16 = max_scroll.min(u16::MAX as usize) as u16;
        self.browser_overlay_state
            .update_action_metrics(info_column.height, max_scroll_u16);
        let scroll = self
            .browser_overlay_state
            .action_scroll()
            .min(max_scroll_u16);

        let paragraph = Paragraph::new(info_lines)
            .style(Style::default().fg(crate::colors::text()))
            .wrap(Wrap { trim: false })
            .scroll((scroll, 0));
        Widget::render(paragraph, info_column, buf);
    }

    fn render_settings_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        buf: &mut Buffer,
        overlay: &SettingsOverlayView,
    ) {
        use ratatui::widgets::Clear;

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let overlay_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: history_area.height,
        };

        Clear.render(overlay_area, buf);

        let bg_style = Style::default().bg(crate::colors::overlay_scrim());
        fill_rect(buf, overlay_area, None, bg_style);

        overlay.render(overlay_area, buf);
    }

    fn browser_title(&self) -> &'static str {
        if self.browser_is_external {
            "Chrome"
        } else {
            "Browser"
        }
    }

    fn render_agents_terminal_overlay(
        &self,
        frame_area: Rect,
        history_area: Rect,
        bottom_pane_area: Rect,
        buf: &mut Buffer,
    ) {
        use ratatui::layout::{Alignment, Constraint, Direction, Layout, Margin, Rect as RtRect};
        use ratatui::style::{Modifier, Style};
        use ratatui::text::{Line, Span};
        use ratatui::widgets::{
            Block, Borders, Clear, HighlightSpacing, List, ListItem, ListState, Paragraph,
        };

        let scrim_style = Style::default()
            .bg(crate::colors::overlay_scrim())
            .fg(crate::colors::text_dim());
        fill_rect(buf, frame_area, None, scrim_style);

        let padding = 1u16;
        let footer_reserved = bottom_pane_area.height.min(1);
        let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height).saturating_sub(footer_reserved);
        let overlay_height = overlay_bottom
            .saturating_sub(history_area.y)
            .max(1)
            .min(frame_area.height);

        let window_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: overlay_height,
        };
        Clear.render(window_area, buf);

        let title_spans = vec![
            Span::styled(" Agents ", Style::default().fg(crate::colors::text())),
            Span::styled("— Ctrl+A to close", Style::default().fg(crate::colors::text_dim())),
        ];

        let block = Block::default()
            .borders(Borders::ALL)
            .title(Line::from(title_spans))
            .style(Style::default().bg(crate::colors::background()))
            .border_style(
                Style::default()
                    .fg(crate::colors::border())
                    .bg(crate::colors::background()),
            );
        let inner = block.inner(window_area);
        block.render(window_area, buf);

        let inner_bg = Style::default().bg(crate::colors::background());
        for y in inner.y..inner.y + inner.height {
            for x in inner.x..inner.x + inner.width {
                buf[(x, y)].set_style(inner_bg);
            }
        }

        // Remove vertical padding so the filter row sits directly below the title.
        let content = inner.inner(Margin {
            horizontal: 1,
            vertical: 0,
        });
        if content.width == 0 || content.height == 0 {
            return;
        }

        let tab_height = if content.height >= 3 { 1 } else { 0 };
        let hint_height = if content.height >= 2 { 1 } else { 0 };
        let body_height = content
            .height
            .saturating_sub(hint_height + tab_height);
        let tabs_area = RtRect {
            x: content.x,
            y: content.y,
            width: content.width,
            height: tab_height,
        };
        let body_area = RtRect {
            x: content.x,
            y: content.y.saturating_add(tab_height),
            width: content.width,
            height: body_height,
        };
        let hint_area = RtRect {
            x: content.x,
            y: content.y.saturating_add(tab_height + body_height),
            width: content.width,
            height: hint_height,
        };

        let sidebar_has_focus = self.agents_terminal.focus() == AgentsTerminalFocus::Sidebar;
        let sidebar_border_color = if sidebar_has_focus {
            crate::colors::primary()
        } else {
            crate::colors::border()
        };
        let filter_title_style = Style::default().fg(crate::colors::text_dim());

        if tab_height > 0 {
            let filter_row = tabs_area;
            let mut spans: Vec<Span> = Vec::new();
            spans.push(Span::styled("Filter", filter_title_style));
            spans.push(Span::raw("   "));
            let tabs = [
                (AgentsTerminalTab::All, "1", "All"),
                (AgentsTerminalTab::Running, "2", "Running"),
                (AgentsTerminalTab::Failed, "3", "Failed"),
                (AgentsTerminalTab::Completed, "4", "Done"),
                (AgentsTerminalTab::Review, "5", "Review"),
            ];
            for (idx, (tab, number, label)) in tabs.iter().enumerate() {
                if idx > 0 {
                    spans.push(Span::styled(
                        " - ",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                }
                let active = *tab == self.agents_terminal.active_tab;
                let style = if active {
                    Style::default()
                        .fg(crate::colors::primary())
                        .add_modifier(Modifier::BOLD)
                } else {
                    Style::default().fg(crate::colors::text_dim())
                };
                spans.push(Span::styled(format!("{number} {label}"), style));
            }
            let sort_label = match self.agents_terminal.sort_mode {
                AgentsSortMode::Recent => "Recent",
                AgentsSortMode::RunningFirst => "Running",
                AgentsSortMode::Name => "Name",
            };
            let sort_spans = vec![
                Span::styled("Sort: ", Style::default().fg(crate::colors::text_dim())),
                Span::raw("( "),
                Span::styled(
                    format!("{sort_label} ▼"),
                    Style::default()
                        .fg(crate::colors::primary())
                        .add_modifier(Modifier::BOLD),
                ),
                Span::raw(" )"),
            ];

            let filter_width: u16 = spans.iter().map(|span| span.width() as u16).sum();
            let sort_width: u16 = sort_spans.iter().map(|span| span.width() as u16).sum();
            let gap = filter_row
                .width
                .saturating_sub(filter_width + sort_width)
                .max(1);
            spans.push(Span::raw(" ".repeat(gap as usize)));
            spans.extend(sort_spans);

            Paragraph::new(Line::from(spans))
                .alignment(Alignment::Left)
                .render(filter_row, buf);
        }

        let longest_name_width: u16 = self
            .agents_terminal
            .entries
            .values()
            .map(|entry| {
                let label = entry
                    .model
                    .as_ref()
                    .map(|m| Self::format_model_label(m))
                    .unwrap_or_else(|| Self::format_model_label(&entry.name));
                UnicodeWidthStr::width(label.as_str()) as u16
            })
            .max()
            .unwrap_or(10);
        let status_icon_width = UnicodeWidthStr::width(agent_status_icon(AgentStatus::Running)) as u16;
        let desired_sidebar = longest_name_width
            .saturating_add(status_icon_width)
            .saturating_add(8);
        let sidebar_width = if body_area.width <= 30 {
            body_area.width
        } else {
            let max_allowed = body_area.width.saturating_sub(30).max(18);
            let min_allowed = 24.min(max_allowed);
            desired_sidebar.clamp(min_allowed, max_allowed)
        };

        let constraints = if body_area.width <= sidebar_width {
            [Constraint::Length(body_area.width), Constraint::Length(0)]
        } else {
            [Constraint::Length(sidebar_width), Constraint::Min(12)]
        };

        let chunks = Layout::default()
            .direction(Direction::Horizontal)
            .constraints(constraints)
            .split(body_area);

        // Sidebar list of agents grouped by batch id
        let mut items: Vec<ListItem> = Vec::new();
        let mut row_entries: Vec<Option<AgentsSidebarEntry>> = Vec::new();
        let groups = self.agents_terminal.sidebar_groups();
        let last_group_idx = groups.len().saturating_sub(1);

        for (group_idx, group) in groups.into_iter().enumerate() {
            items.push(ListItem::new(Line::from(vec![
                Span::styled(
                    group.label.clone(),
                    Style::default()
                        .fg(crate::colors::text())
                        .add_modifier(Modifier::BOLD),
                ),
            ])));
            row_entries.push(None);

            let selected_entry = self.agents_terminal.current_sidebar_entry();

            for agent_id in group.agent_ids {
                if let Some(entry) = self.agents_terminal.entries.get(&agent_id) {
                    let model_label = entry
                        .model
                        .as_ref()
                        .map(|value| Self::format_model_label(value))
                        .unwrap_or_else(|| Self::format_model_label(&entry.name));
                    let status = entry.status.clone();
                    let status_icon = agent_status_icon(status.clone());
                    let name_room = sidebar_width
                        .saturating_sub((UnicodeWidthStr::width(status_icon) as u16).saturating_add(5))
                        .max(4) as usize;
                    let mut display_name = model_label.clone();
                    if display_name.chars().count() > name_room {
                        display_name = display_name
                            .chars()
                            .take(name_room.saturating_sub(1))
                            .collect::<String>();
                        display_name.push('…');
                    }
                    let color = agent_status_color(status);
                    let is_selected = selected_entry
                        .as_ref()
                        .map(|entry| entry == &AgentsSidebarEntry::Agent(agent_id.clone()))
                        .unwrap_or(false);
                    let prefix_span = if is_selected {
                        Span::styled(
                            "› ",
                            Style::default().fg(crate::colors::primary()),
                        )
                    } else {
                        Span::raw("  ")
                    };

                    let line = Line::from(vec![
                        prefix_span,
                        Span::styled(
                            display_name,
                            Style::default().fg(crate::colors::text()),
                        ),
                        Span::raw(" "),
                        Span::styled(status_icon, Style::default().fg(color)),
                    ]);
                    items.push(ListItem::new(line));
                    row_entries.push(Some(AgentsSidebarEntry::Agent(agent_id.clone())));
                }
            }

            if group_idx < last_group_idx {
                items.push(ListItem::new(Line::from(vec![Span::raw(" ")])));
                row_entries.push(None);
            }
        }

        if items.is_empty() {
            let empty_text = if self.agents_terminal.order.is_empty() {
                "No agents yet"
            } else {
                "No agents match filters"
            };
            items.push(ListItem::new(Line::from(vec![Span::styled(
                empty_text,
                Style::default().fg(crate::colors::text_dim()),
            )])));
            row_entries.push(None);
        }

        let mut list_state = ListState::default();
        if let Some(selected_entry) = self.agents_terminal.current_sidebar_entry() {
            if let Some(row_idx) = row_entries
                .iter()
                .position(|entry| entry.as_ref() == Some(&selected_entry))
            {
                list_state.select(Some(row_idx));
            }
        }

        // Keep the selected agent vivid even when detail pane holds focus so users
        // don’t lose their place while reading logs.
        let highlight_style = Style::default()
            .fg(crate::colors::primary())
            .add_modifier(Modifier::BOLD);
        let sidebar = List::new(items)
            .highlight_style(highlight_style)
            .highlight_spacing(HighlightSpacing::Never);

        let sidebar_block = Block::default()
            .borders(Borders::ALL)
            .style(Style::default().bg(crate::colors::background()))
            .border_style(Style::default().fg(sidebar_border_color));

        let sidebar_area = chunks[0];
        let sidebar_inner = sidebar_block.inner(sidebar_area);
        sidebar_block.render(sidebar_area, buf);

        fill_rect(
            buf,
            sidebar_inner,
            None,
            Style::default().bg(crate::colors::background()),
        );

        ratatui::widgets::StatefulWidget::render(sidebar, sidebar_inner, buf, &mut list_state);

        let right_area = if chunks.len() > 1 { chunks[1] } else { chunks[0] };
        let detail_width = right_area.width.saturating_sub(2).max(1);
        let mut lines: Vec<Line> = Vec::new();

        match self.agents_terminal.current_sidebar_entry() {
            Some(AgentsSidebarEntry::Agent(agent_id)) => {
                if let Some(entry) = self.agents_terminal.entries.get(agent_id.as_str()) {
                    let status = entry.status.clone();
                    let status_color = agent_status_color(status.clone());
                    let display_name = entry
                        .model
                        .as_ref()
                        .map(|m| Self::format_model_label(m))
                        .unwrap_or_else(|| Self::format_model_label(&entry.name));
                    let title_text = entry
                        .batch_label
                        .as_ref()
                        .and_then(|b| {
                            let trimmed = b.trim();
                            (!trimmed.is_empty()).then(|| trimmed.to_string())
                        })
                        .map(|batch| format!("{batch} / {display_name}"))
                        .unwrap_or_else(|| display_name.clone());

                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            title_text,
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ),
                    ]));

                    let id_short = format!("#{}", agent_id.chars().take(7).collect::<String>());
                    let status_chip = format!("{} {}", agent_status_icon(status.clone()), agent_status_label(status));
                    let model_meta = entry
                        .model
                        .as_ref()
                        .map(|m| Self::format_model_label(m))
                        .unwrap_or_else(|| display_name.clone());
                    let mut meta_line: Vec<Span> = vec![
                        Span::raw(" "),
                        Span::styled("Status:", Style::default().fg(crate::colors::text_dim())),
                        Span::raw(" "),
                        Span::styled(status_chip, Style::default().fg(status_color).add_modifier(Modifier::BOLD)),
                        Span::raw("   "),
                        Span::styled("Model:", Style::default().fg(crate::colors::text_dim())),
                        Span::raw(" "),
                        Span::styled(
                            model_meta,
                            Style::default().fg(crate::colors::text()),
                        ),
                        Span::raw("   "),
                        Span::styled("ID:", Style::default().fg(crate::colors::text_dim())),
                        Span::raw(" "),
                        Span::styled(id_short, Style::default().fg(crate::colors::text_dim())),
                    ];
                    if let Some(batch_id) = entry.batch_id.as_ref() {
                        meta_line.push(Span::raw("   "));
                        meta_line.push(Span::styled(
                            format!("Batch: {}", short_batch_label(batch_id)),
                            Style::default().fg(crate::colors::text_dim()),
                        ));
                    }
                    lines.push(Line::from(meta_line));

                    self.ensure_trailing_blank_line(&mut lines);

                    self.append_agent_highlights(
                        &mut lines,
                        entry,
                        detail_width,
                        self.agents_terminal.highlights_collapsed,
                    );

                    if let Some(context_text) = entry
                        .batch_context
                        .as_ref()
                        .filter(|value| !value.trim().is_empty())
                    {
                        self.ensure_trailing_blank_line(&mut lines);
                        self.append_agents_overlay_section(&mut lines, "Context", context_text);
                    }

                    self.ensure_trailing_blank_line(&mut lines);

                    // Action log box
                    let action_header_style = Style::default()
                        .fg(crate::colors::text())
                        .add_modifier(Modifier::BOLD);
                    let chevron = if self.agents_terminal.actions_collapsed { "▶" } else { "▼" };
                    let header_text = format!(
                        "╭ Action Log (a) {chevron} — {} entries ",
                        entry.logs.len()
                    );
                    let header_width = UnicodeWidthStr::width(header_text.as_str()) as u16;
                    let pad = detail_width
                        .saturating_sub(header_width)
                        .saturating_sub(1);
                    let mut action_header = header_text;
                    action_header.push_str(&"─".repeat(pad as usize));
                    action_header.push('╮');
                    lines.push(Line::from(Span::styled(action_header, action_header_style)));

                    if self.agents_terminal.actions_collapsed {
                        let mut footer = String::from("╰");
                        footer.push_str(&"─".repeat(detail_width.saturating_sub(1) as usize));
                        lines.push(Line::from(footer));
                        self.ensure_trailing_blank_line(&mut lines);
                    } else if entry.logs.is_empty() {
                        lines.push(Line::from(vec![
                            Span::raw("│   "),
                            Span::styled(
                                "No updates yet",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                        let mut footer = String::from("╰");
                        footer.push_str(&"─".repeat(detail_width.saturating_sub(1) as usize));
                        lines.push(Line::from(footer));
                        self.ensure_trailing_blank_line(&mut lines);
                    } else {
                        let mut log_lines: Vec<Line> = Vec::new();
                        let mut last_kind: Option<AgentLogKind> = None;
                        for (idx, log) in entry.logs.iter().enumerate() {
                            let is_new_kind = last_kind.map_or(true, |kind| kind != log.kind);
                            self.append_agent_log_lines(
                                &mut log_lines,
                                idx,
                                log,
                                detail_width.saturating_sub(4),
                                is_new_kind,
                            );
                            last_kind = Some(log.kind);
                        }
                        for mut line in log_lines.into_iter() {
                            line.spans.insert(0, Span::raw("│   "));
                            lines.push(line);
                        }
                        let mut footer = String::from("╰");
                        footer.push_str(&"─".repeat(detail_width.saturating_sub(1) as usize));
                        lines.push(Line::from(footer));
                        self.ensure_trailing_blank_line(&mut lines);
                    }
                } else {
                    lines.push(Line::from(vec![
                        Span::raw(" "),
                        Span::styled(
                            "No data for selected agent",
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));
                }
            }
            None => {
                lines.push(Line::from(vec![
                    Span::raw(" "),
                    Span::styled(
                        "No agents available",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                ]));
            }
        }

        let content_width = right_area.width.saturating_sub(2).max(1);
        let wrapped_lines = word_wrap_lines(&lines, content_width as u16);
        let viewport_height = right_area.height.saturating_sub(2).max(1);
        let total_lines = wrapped_lines.len() as u16;
        let max_scroll = total_lines.saturating_sub(viewport_height);
        self.layout.last_history_viewport_height.set(viewport_height);
        self.layout.last_max_scroll.set(max_scroll);

        // scroll_offset is bottom‑anchored; Paragraph expects top‑anchored scroll.
        let preferred_offset = self
            .agents_terminal
            .current_sidebar_entry()
            .and_then(|entry| {
                self.agents_terminal
                    .scroll_offsets
                    .get(&entry.scroll_key())
                    .copied()
            })
            .unwrap_or(max_scroll);
        let clamped_offset = preferred_offset.min(max_scroll);
        self
            .agents_terminal
            .last_render_scroll
            .set(clamped_offset);
        let scroll_from_top = max_scroll.saturating_sub(clamped_offset);

        let detail_has_focus = self.agents_terminal.focus() == AgentsTerminalFocus::Detail;
        let detail_border_color = if detail_has_focus {
            crate::colors::primary()
        } else {
            crate::colors::border()
        };
        let history_block = Block::default()
            .borders(Borders::ALL)
            .border_style(Style::default().fg(detail_border_color));

        Paragraph::new(wrapped_lines)
            .block(history_block)
            .scroll((scroll_from_top, 0))
            .render(right_area, buf);

        if hint_height == 1 {
            let hint_line = if let Some(pending) = self.agents_terminal.pending_stop.as_ref() {
                Line::from(vec![
                    Span::styled(
                        "Stop agent? ",
                        Style::default()
                            .fg(crate::colors::error())
                            .add_modifier(Modifier::BOLD),
                    ),
                    Span::styled(
                        pending.agent_name.clone(),
                        Style::default().fg(crate::colors::text()),
                    ),
                    Span::styled(
                        " — Enter/Y stop  ",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                    Span::styled(
                        "Esc/N cancel",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                ])
            } else {
                Line::from(vec![
                    Span::styled("[↑/↓/←/→]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Navigate   ", Style::default().fg(crate::colors::text_dim())),
                    Span::styled("[1-5]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Filter   ", Style::default().fg(crate::colors::text_dim())),
                    Span::styled("[S]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Sort   ", Style::default().fg(crate::colors::text_dim())),
                    Span::styled("[H/A]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Toggle Details   ", Style::default().fg(crate::colors::text_dim())),
                    Span::styled("[X]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Stop   ", Style::default().fg(crate::colors::text_dim())),
                    Span::styled("[Ctrl+A]", Style::default().fg(crate::colors::function())),
                    Span::styled(" Exit", Style::default().fg(crate::colors::text_dim())),
                ])
            };
            Paragraph::new(hint_line)
                .style(Style::default().bg(crate::colors::background()))
                .alignment(ratatui::layout::Alignment::Center)
                .render(hint_area, buf);
        }
    }

    #[allow(dead_code)]
    /// Render the agent status panel in the HUD
    fn render_agent_panel(&self, area: Rect, buf: &mut Buffer) {
        use ratatui::text::Line as RLine;
        use ratatui::text::Span;
        use ratatui::text::Text;
        use ratatui::widgets::Block;
        use ratatui::widgets::Borders;
        use ratatui::widgets::Paragraph;
        use ratatui::widgets::Sparkline;
        use ratatui::widgets::SparklineBar;
        use ratatui::widgets::Widget;
        use ratatui::widgets::Wrap;

        // Update sparkline data for animation
        if !self.active_agents.is_empty() || self.agents_ready_to_start {
            self.update_sparkline_data();
        }

        let short_id = |id: &str| -> String { id.chars().take(8).collect() };
        let mut rendered_batches = std::collections::HashSet::new();

        // Agent status block
        let agent_block = Block::default()
            .borders(Borders::ALL)
            .title(" Agents ")
            .border_style(Style::default().fg(crate::colors::border()));

        let inner_agent = agent_block.inner(area);
        agent_block.render(area, buf);
        // Render a one-line collapsed header inside expanded panel
        use ratatui::layout::Margin;
        let header_pad = inner_agent.inner(Margin::new(1, 0));
        let header_line = Rect {
            x: header_pad.x,
            y: header_pad.y,
            width: header_pad.width,
            height: 1,
        };
        let key_hint_style = Style::default().fg(crate::colors::function());
        let label_style = Style::default().dim();
        let is_active = !self.active_agents.is_empty() || self.agents_ready_to_start;
        let dot_style = if is_active {
            Style::default().fg(crate::colors::success_green())
        } else {
            Style::default().fg(crate::colors::text_dim())
        };
        // Build summary like collapsed header
        let count = self.active_agents.len();
        let summary = if count == 0 && self.agents_ready_to_start {
            "Starting...".to_string()
        } else if count == 0 {
            "no active agents".to_string()
        } else {
            let mut parts: Vec<String> = Vec::new();
            for a in self.active_agents.iter().take(3) {
                let s = match a.status {
                    AgentStatus::Pending => "pending",
                    AgentStatus::Running => "running",
                    AgentStatus::Completed => "done",
                    AgentStatus::Failed => "failed",
                    AgentStatus::Cancelled => "cancelled",
                };
                parts.push(format!("{} ({})", a.name, s));
            }
            let extra = if count > 3 {
                format!(" +{}", count - 3)
            } else {
                String::new()
            };
            format!("{}{}", parts.join(", "), extra)
        };
        let mut left_spans: Vec<Span> = Vec::new();
        left_spans.push(Span::styled("•", dot_style));
        // no status text; dot conveys status
        // single space between dot and summary; no label/separator
        left_spans.push(Span::raw(" "));
        left_spans.push(Span::raw(summary));
        let right_spans: Vec<Span> = vec![
            Span::from("Ctrl+A").style(key_hint_style),
            Span::styled(" open terminal", label_style),
        ];
        let measure =
            |spans: &Vec<Span>| -> usize { spans.iter().map(|s| s.content.chars().count()).sum() };
        let left_len = measure(&left_spans);
        let right_len = measure(&right_spans);
        let total_width = header_line.width as usize;
        if total_width > left_len + right_len {
            left_spans.push(Span::from(" ".repeat(total_width - left_len - right_len)));
        }
        let mut spans = left_spans;
        spans.extend(right_spans);
        Paragraph::new(RLine::from(spans)).render(header_line, buf);

        // Body area excludes the header line and a spacer line
        let inner_agent = Rect {
            x: inner_agent.x,
            y: inner_agent.y + 2,
            width: inner_agent.width,
            height: inner_agent.height.saturating_sub(2),
        };

        // Dynamically calculate sparkline height based on agent activity
        // More agents = taller sparkline area
        let agent_count = self.active_agents.len();
        let sparkline_height = if agent_count == 0 && self.agents_ready_to_start {
            1u16 // Minimal height when preparing
        } else if agent_count == 0 {
            0u16 // No sparkline when no agents
        } else {
            (agent_count as u16 + 1).min(4) // 2-4 lines based on agent count
        };

        // Ensure we have enough space for both content and sparkline
        // Reserve at least 3 lines for content (status + blank + message)
        let min_content_height = 3u16;
        let available_height = inner_agent.height;

        let (actual_content_height, actual_sparkline_height) = if sparkline_height > 0 {
            if available_height > min_content_height + sparkline_height {
                // Enough space for both
                (
                    available_height.saturating_sub(sparkline_height),
                    sparkline_height,
                )
            } else if available_height > min_content_height {
                // Limited space - give minimum to content, rest to sparkline
                (
                    min_content_height,
                    available_height
                        .saturating_sub(min_content_height)
                        .min(sparkline_height),
                )
            } else {
                // Very limited space - content only
                (available_height, 0)
            }
        } else {
            // No sparkline needed
            (available_height, 0)
        };

        let content_area = Rect {
            x: inner_agent.x,
            y: inner_agent.y,
            width: inner_agent.width,
            height: actual_content_height,
        };
        let sparkline_area = Rect {
            x: inner_agent.x,
            y: inner_agent.y + actual_content_height,
            width: inner_agent.width,
            height: actual_sparkline_height,
        };

        // Build all content into a single Text structure for proper wrapping
        let mut text_content = vec![];

        // Add blank line at the top
        text_content.push(RLine::from(" "));

        // Add overall task status at the top
        let status_color = match self.overall_task_status.as_str() {
            "planning" => crate::colors::warning(),
            "running" => crate::colors::info(),
            "consolidating" => crate::colors::warning(),
            "complete" => crate::colors::success(),
            "failed" => crate::colors::error(),
            "cancelled" => crate::colors::warning(),
            _ => crate::colors::text_dim(),
        };

        text_content.push(RLine::from(vec![
            Span::from(" "),
            Span::styled(
                "Status: ",
                Style::default()
                    .fg(crate::colors::text())
                    .add_modifier(Modifier::BOLD),
            ),
            Span::styled(&self.overall_task_status, Style::default().fg(status_color)),
        ]));

        // Add blank line
        text_content.push(RLine::from(" "));

        // Display agent statuses
        if self.agents_ready_to_start && self.active_agents.is_empty() {
            // Show "Building context..." message when agents are expected
            text_content.push(RLine::from(vec![
                Span::from(" "),
                Span::styled(
                    "Building context...",
                    Style::default()
                        .fg(crate::colors::text_dim())
                        .add_modifier(Modifier::ITALIC),
                ),
            ]));
        } else if self.active_agents.is_empty() {
            text_content.push(RLine::from(vec![
                Span::from(" "),
                Span::styled(
                    "No active agents",
                    Style::default().fg(crate::colors::text_dim()),
                ),
            ]));
        } else {
            // Show agent names/models and final messages
            for agent in &self.active_agents {
                let status_color = match agent.status {
                    AgentStatus::Pending => crate::colors::warning(),
                    AgentStatus::Running => crate::colors::info(),
                    AgentStatus::Completed => crate::colors::success(),
                    AgentStatus::Failed => crate::colors::error(),
                    AgentStatus::Cancelled => crate::colors::warning(),
                };

                // Build status + timing suffix where available
                let status_text = match agent.status {
                    AgentStatus::Pending => "pending".to_string(),
                    AgentStatus::Running => {
                        if let Some(rt) = self.agent_runtime.get(&agent.id) {
                            if let Some(start) = rt.started_at {
                                let now = Instant::now();
                                let elapsed = now.saturating_duration_since(start);
                                format!("running {}", self.fmt_short_duration(elapsed))
                            } else {
                                "running".to_string()
                            }
                        } else {
                            "running".to_string()
                        }
                    }
                    AgentStatus::Completed | AgentStatus::Failed | AgentStatus::Cancelled => {
                        if let Some(rt) = self.agent_runtime.get(&agent.id) {
                            if let (Some(start), Some(done)) = (rt.started_at, rt.completed_at) {
                                let dur = done.saturating_duration_since(start);
                                let base = match agent.status {
                                    AgentStatus::Completed => "completed",
                                    AgentStatus::Failed => "failed",
                                    AgentStatus::Cancelled => "cancelled",
                                    _ => unreachable!(),
                                };
                                format!("{} {}", base, self.fmt_short_duration(dur))
                            } else {
                                match agent.status {
                                    AgentStatus::Completed => "completed".to_string(),
                                    AgentStatus::Failed => "failed".to_string(),
                                    AgentStatus::Cancelled => "cancelled".to_string(),
                                    _ => unreachable!(),
                                }
                            }
                        } else {
                            match agent.status {
                                AgentStatus::Completed => "completed".to_string(),
                                AgentStatus::Failed => "failed".to_string(),
                                AgentStatus::Cancelled => "cancelled".to_string(),
                                _ => unreachable!(),
                            }
                        }
                    }
                };

                let mut line_spans: Vec<Span> = Vec::new();
                line_spans.push(Span::from(" "));
                line_spans.push(
                    Span::styled(
                        format!("{}", agent.name),
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                );
                line_spans.push(Span::styled(
                    format!(" [{}]", short_id(&agent.id)),
                    Style::default().fg(crate::colors::text_dim()),
                ));
                if let Some(ref model) = agent.model {
                    if !model.is_empty() {
                        line_spans.push(Span::styled(
                            format!(" ({})", model),
                            Style::default().fg(crate::colors::text_dim()),
                        ));
                    }
                }
                line_spans.push(Span::from(": "));
                line_spans.push(Span::styled(status_text, Style::default().fg(status_color)));
                text_content.push(RLine::from(line_spans));

                // For running agents, show latest progress hint if available
                if matches!(agent.status, AgentStatus::Running) {
                    if let Some(ref lp) = agent.last_progress {
                        let mut lp_trim = lp.trim().to_string();
                        if lp_trim.len() > 120 {
                            lp_trim.truncate(120);
                            lp_trim.push('…');
                        }
                        text_content.push(RLine::from(vec![
                            Span::from("   "),
                            Span::styled(
                                lp_trim,
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                }

                // For completed/failed agents, show their final message or error
                match agent.status {
                    AgentStatus::Completed => {
                        if let Some(ref msg) = agent.result {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(msg, Style::default().fg(crate::colors::text_dim())),
                            ]));
                        }
                    }
                    AgentStatus::Failed => {
                        if let Some(ref err) = agent.error {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(
                                    err,
                                    Style::default()
                                        .fg(crate::colors::error())
                                        .add_modifier(Modifier::ITALIC),
                                ),
                            ]));
                        }
                    }
                    AgentStatus::Cancelled => {
                        if let Some(ref err) = agent.error {
                            text_content.push(RLine::from(vec![
                                Span::from("   "),
                                Span::styled(
                                    err,
                                    Style::default()
                                        .fg(crate::colors::warning())
                                        .add_modifier(Modifier::ITALIC),
                                ),
                            ]));
                        }
                    }
                    _ => {}
                }

                if let Some(ref batch) = agent.batch_id {
                    if rendered_batches.insert(batch.clone()) {
                        let batch_line = format!(
                            "Batch {} — use agent {{\"action\":\"wait\",\"wait\":{{\"batch_id\":\"{}\"}}}}",
                            short_id(batch),
                            batch
                        );
                        text_content.push(RLine::from(vec![
                            Span::from("   "),
                            Span::styled(
                                batch_line,
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                }
            }
        }

        // Calculate how much vertical space the fixed content takes
        let fixed_content_height = text_content.len() as u16;

        // Create the first paragraph for the fixed content (status and agents) without wrapping
        let fixed_paragraph = Paragraph::new(Text::from(text_content));

        // Render the fixed content first
        let fixed_area = Rect {
            x: content_area.x,
            y: content_area.y,
            width: content_area.width,
            height: fixed_content_height.min(content_area.height),
        };
        fixed_paragraph.render(fixed_area, buf);

        // Calculate remaining area for wrapped content
        let remaining_height = content_area.height.saturating_sub(fixed_content_height);
        if remaining_height > 0 {
            let wrapped_area = Rect {
                x: content_area.x,
                y: content_area.y + fixed_content_height,
                width: content_area.width,
                height: remaining_height,
            };

            // Add context and task sections with proper wrapping in the remaining area
            let mut wrapped_content = vec![];

            if let Some(ref task) = self.agent_task {
                wrapped_content.push(RLine::from(" ")); // Empty line separator
                wrapped_content.push(RLine::from(vec![
                    Span::from(" "),
                    Span::styled(
                        "Task:",
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                    Span::from(" "),
                    Span::styled(task, Style::default().fg(crate::colors::text_dim())),
                ]));
            }

            if let Some(ref hint) = self.recent_agent_hint {
                wrapped_content.push(RLine::from(" "));
                wrapped_content.push(RLine::from(vec![
                    Span::from(" "),
                    Span::styled(
                        "Next steps:",
                        Style::default()
                            .fg(crate::colors::text())
                            .add_modifier(Modifier::BOLD),
                    ),
                ]));
                for line in hint.lines() {
                    wrapped_content.push(RLine::from(vec![
                        Span::from("   "),
                        Span::styled(
                            line.trim_end(),
                            Style::default().fg(crate::colors::text_dim()),
                        ),
                    ]));
                }
            }

            if !wrapped_content.is_empty() {
                // Create paragraph with wrapping enabled for the long text content
                let wrapped_paragraph =
                    Paragraph::new(Text::from(wrapped_content)).wrap(Wrap { trim: false });
                wrapped_paragraph.render(wrapped_area, buf);
            }
        }

        // Render sparkline at the bottom if we have data and agents are active
        let sparkline_data = self.sparkline_data.borrow();

        // Debug logging
        tracing::debug!(
            "Sparkline render check: data_len={}, agents={}, ready={}, height={}, actual_height={}, area={:?}",
            sparkline_data.len(),
            self.active_agents.len(),
            self.agents_ready_to_start,
            sparkline_height,
            actual_sparkline_height,
            sparkline_area
        );

        if !sparkline_data.is_empty()
            && (!self.active_agents.is_empty() || self.agents_ready_to_start)
            && actual_sparkline_height > 0
        {
            // Convert data to SparklineBar with colors based on completion status
            let bars: Vec<SparklineBar> = sparkline_data
                .iter()
                .map(|(value, is_completed)| {
                    let color = if *is_completed {
                        crate::colors::success() // Green for completed
                    } else {
                        crate::colors::border() // Border color for normal activity
                    };
                    SparklineBar::from(*value).style(Style::default().fg(color))
                })
                .collect();

            // Use dynamic max based on the actual data for better visibility
            // During preparing/planning, values are small (2-3), during running they're larger (5-15)
            // For planning phase with single line, use smaller max for better visibility
            let max_value = if self.agents_ready_to_start && self.active_agents.is_empty() {
                // Planning phase - use smaller max for better visibility of 1-3 range
                sparkline_data
                    .iter()
                    .map(|(v, _)| *v)
                    .max()
                    .unwrap_or(4)
                    .max(4)
            } else {
                // Running phase - use larger max
                sparkline_data
                    .iter()
                    .map(|(v, _)| *v)
                    .max()
                    .unwrap_or(10)
                    .max(10)
            };

            let sparkline = Sparkline::default().data(bars).max(max_value); // Dynamic max for better visibility
            sparkline.render(sparkline_area, buf);
        }
    }
}

impl WidgetRef for &ChatWidget<'_> {
    fn render_ref(&self, area: Rect, buf: &mut Buffer) {
        // Top-level widget render timing
        let _perf_widget_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };

        // Ensure a consistent background even when individual widgets skip
        // painting unchanged regions. Without this, gutters and inter‑cell
        // spacing can show through after we reduced full clears.
        // Cost: one Block render across the frame (O(area)); acceptable and
        // fixes visual artifacts reported after redraw reductions.
        if !self.standard_terminal_mode {
            use ratatui::style::Style;
            use ratatui::widgets::Block;
            let bg = Block::default().style(Style::default().bg(crate::colors::background()));
            bg.render(area, buf);
        }

        // Remember full frame height for HUD sizing logic
        self.layout.last_frame_height.set(area.height);
        self.layout.last_frame_width.set(area.width);

        let layout_areas = self.layout_areas(area);
        let status_bar_area = layout_areas.get(0).copied().unwrap_or(area);
        let history_area = layout_areas.get(1).copied().unwrap_or(area);
        let bottom_pane_area = layout_areas.get(2).copied().unwrap_or(area);

        // Record the effective bottom pane height for buffer-mode scrollback inserts.
        self.layout
            .last_bottom_reserved_rows
            .set(bottom_pane_area.height);

        // Render status bar and HUD only in full TUI mode
        if !self.standard_terminal_mode {
            self.render_status_bar(status_bar_area, buf);
        }

        // In standard-terminal mode, do not paint the history region: committed
        // content is appended to the terminal's own scrollback via
        // insert_history_lines and repainting here would overwrite it.
        if self.standard_terminal_mode {
            // Render only the bottom pane (composer or its active view) without painting
            // backgrounds to preserve the terminal's native theme.
            ratatui::widgets::WidgetRef::render_ref(&(&self.bottom_pane), bottom_pane_area, buf);
            // Scrub backgrounds in the bottom pane region so any widget-set bg becomes transparent.
            self.clear_backgrounds_in(buf, bottom_pane_area);
            return;
        }

        // Create a unified scrollable container for all chat content
        // Use consistent padding throughout
        let padding = 1u16;
        let content_area = Rect {
            x: history_area.x + padding,
            y: history_area.y,
            width: history_area.width.saturating_sub(padding * 2),
            height: history_area.height,
        };

        self.update_welcome_height_hint(content_area.height);

        // Reset the full history region to the baseline theme background once per frame.
        // Individual cells only repaint when their visuals differ (e.g., assistant tint),
        // which keeps overdraw minimal while ensuring stale characters disappear.
        let base_style = Style::default()
            .bg(crate::colors::background())
            .fg(crate::colors::text());
        fill_rect(buf, history_area, Some(' '), base_style);

        // Add live streaming content if present
        let streaming_lines = self
            .live_builder
            .display_rows()
            .into_iter()
            .map(|r| ratatui::text::Line::from(r.text))
            .collect::<Vec<_>>();

        let streaming_cell = if !streaming_lines.is_empty() {
            let state =
                self.synthesize_stream_state_from_lines(None, &streaming_lines, true);
            Some(history_cell::new_streaming_content(state, &self.config))
        } else {
            None
        };

        // Append any queued user messages as sticky preview cells at the very
        // end so they always render at the bottom until they are dispatched.
        let mut queued_preview_cells: Vec<crate::history_cell::PlainHistoryCell> = Vec::new();
        if !self.queued_user_messages.is_empty() {
            for qm in &self.queued_user_messages {
                let state = history_cell::new_queued_user_prompt(qm.display_text.clone());
                queued_preview_cells.push(crate::history_cell::PlainHistoryCell::from_state(state));
            }
        }

        self.ensure_render_request_cache();

        let extra_count = (self.active_exec_cell.is_some() as usize)
            .saturating_add(streaming_cell.is_some() as usize)
            .saturating_add(queued_preview_cells.len());
        let request_count = self.history_cells.len().saturating_add(extra_count);

        let mut render_requests_full: Option<Vec<RenderRequest>> = None;

        // Calculate total content height using prefix sums; build if needed
        let spacing = 1u16; // Standard spacing between cells
        const GUTTER_WIDTH: u16 = 2; // Same as in render loop
        let reasoning_visible = self.is_reasoning_shown();
        let cache_width = content_area.width.saturating_sub(GUTTER_WIDTH);

        // Opportunistically clear height cache if width changed
        self.history_render.handle_width_change(cache_width);

        // Perf: count a frame
        if self.perf_state.enabled {
            let mut p = self.perf_state.stats.borrow_mut();
            p.frames = p.frames.saturating_add(1);
        }

        let render_settings = RenderSettings::new(cache_width, self.render_theme_epoch, reasoning_visible);
        self.last_render_settings.set(render_settings);
        if self.history_frozen_count > 0
            && self.history_frozen_width != render_settings.width
            && !self.history_virtualization_sync_pending.get()
        {
            self.history_virtualization_sync_pending.set(true);
            self.app_event_tx.send(AppEvent::SyncHistoryVirtualization);
        }
        let perf_enabled = self.perf_state.enabled;
        let needs_prefix_rebuild =
            self.history_render
                .should_rebuild_prefix(content_area.width, request_count);
        let mut rendered_cells_full: Option<Vec<VisibleCell>> = None;
        if needs_prefix_rebuild {
            if render_requests_full.is_none() {
                let render_request_cache = self.render_request_cache.borrow();
                let mut render_requests = Vec::with_capacity(request_count);
                for (cell, seed) in self
                    .history_cells
                    .iter()
                    .zip(render_request_cache.iter())
                {
                    let assistant = cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::AssistantMarkdownCell>();
                    render_requests.push(RenderRequest {
                        history_id: seed.history_id,
                        cell: Some(cell.as_ref()),
                        assistant,
                        use_cache: seed.use_cache,
                        fallback_lines: seed.fallback_lines.clone(),
                        kind: seed.kind.clone(),
                        config: &self.config,
                    });
                }

                if let Some(ref cell) = self.active_exec_cell {
                    render_requests.push(RenderRequest {
                        history_id: HistoryId::ZERO,
                        cell: Some(cell as &dyn HistoryCell),
                        assistant: None,
                        use_cache: false,
                        fallback_lines: None,
                        kind: RenderRequestKind::Legacy,
                        config: &self.config,
                    });
                }

                if let Some(ref cell) = streaming_cell {
                    render_requests.push(RenderRequest {
                        history_id: HistoryId::ZERO,
                        cell: Some(cell as &dyn HistoryCell),
                        assistant: None,
                        use_cache: false,
                        fallback_lines: None,
                        kind: RenderRequestKind::Legacy,
                        config: &self.config,
                    });
                }

                for c in &queued_preview_cells {
                    render_requests.push(RenderRequest {
                        history_id: HistoryId::ZERO,
                        cell: Some(c as &dyn HistoryCell),
                        assistant: None,
                        use_cache: false,
                        fallback_lines: None,
                        kind: RenderRequestKind::Legacy,
                        config: &self.config,
                    });
                }

                if perf_enabled {
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.render_requests_full =
                        p.render_requests_full.saturating_add(render_requests.len() as u64);
                }

                render_requests_full = Some(render_requests);
            }

            let render_requests = render_requests_full
                .as_ref()
                .expect("render requests missing after rebuild");
            let mut used_fast_append = false;
            if self.try_append_prefix_fast(&render_requests, render_settings, content_area.width) {
                used_fast_append = true;
                self.history_prefix_append_only.set(true);
            }
            if used_fast_append {
                // Prefix sums already updated; skip the full rebuild path.
                rendered_cells_full = None;
            } else {
            if perf_enabled {
                let mut p = self.perf_state.stats.borrow_mut();
                p.prefix_rebuilds = p.prefix_rebuilds.saturating_add(1);
            }

            let prefix_start = perf_enabled.then(std::time::Instant::now);
            let cells = self.history_render.visible_cells(
                &self.history_state,
                &render_requests,
                render_settings,
            );

            let mut prefix: Vec<u16> = Vec::with_capacity(cells.len().saturating_add(1));
            prefix.push(0);
            let mut acc = 0u16;
            let content_width = content_area.width.saturating_sub(GUTTER_WIDTH);
            let mut spacing_ranges: Vec<(u16, u16)> = Vec::new();

            for (idx, vis) in cells.iter().enumerate() {
                let cell = vis.cell.expect("rendered cell missing source");
                let line_count = vis.height;
                if self.perf_state.enabled
                    && matches!(vis.height_source, history_render::HeightSource::DesiredHeight)
                {
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.height_misses_render = p.height_misses_render.saturating_add(1);
                    if let Some(ns) = vis.height_measure_ns {
                        let label = self.perf_label_for_item(cell);
                        p.record_render((idx, content_width), label.as_str(), ns);
                    }
                }
                acc = acc.saturating_add(line_count);

                let mut should_add_spacing = idx < cells.len().saturating_sub(1) && line_count > 0;
                if should_add_spacing {
                    let prev_visible_idx = (0..idx).rev().find(|j| cells[*j].height > 0);
                    let next_visible_idx = ((idx + 1)..cells.len()).find(|j| cells[*j].height > 0);

                    if next_visible_idx.is_none() {
                        should_add_spacing = false;
                    } else {
                        let this_collapsed = cell
                            .as_any()
                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                            .map(|rc| rc.is_collapsed())
                            .unwrap_or(false);
                        if this_collapsed {
                            if let Some(j) = next_visible_idx {
                                if let Some(next_cell) = cells[j].cell {
                                    if matches!(
                                        next_cell.kind(),
                                        history_cell::HistoryCellType::Exec { .. }
                                    ) {
                                        should_add_spacing = false;
                                    }
                                }
                            }
                        }

                        if this_collapsed {
                            let prev_collapsed = prev_visible_idx
                                .and_then(|j| cells[j]
                                    .cell
                                    .and_then(|c| {
                                        c.as_any()
                                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                            .map(|rc| rc.is_collapsed())
                                    }))
                                .unwrap_or(false);
                            let next_collapsed = next_visible_idx
                                .and_then(|j| cells[j]
                                    .cell
                                    .and_then(|c| {
                                        c.as_any()
                                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                                            .map(|rc| rc.is_collapsed())
                                    }))
                                .unwrap_or(false);
                            if prev_collapsed && next_collapsed {
                                should_add_spacing = false;
                            }
                        }
                    }
                }
                if should_add_spacing {
                    let spacing_start = acc;
                    acc = acc.saturating_add(spacing);
                    // Track the spacer interval so scroll adjustments can skip over it later.
                    spacing_ranges.push((spacing_start, acc));
                }
                prefix.push(acc);
            }

            let total_height = *prefix.last().unwrap_or(&0);
            if let (true, Some(t0)) = (perf_enabled, prefix_start) {
                let elapsed = t0.elapsed().as_nanos();
                let mut p = self.perf_state.stats.borrow_mut();
                p.ns_total_height = p.ns_total_height.saturating_add(elapsed);
            }
            self.history_render.update_prefix_cache(
                content_area.width,
                prefix,
                total_height,
                cells.len(),
                self.history_cells.len(),
            );
            self.history_render.update_spacing_ranges(spacing_ranges);
            rendered_cells_full = Some(cells);
            self.history_prefix_append_only.set(true);
            }
        }

        if self.history_virtualization_sync_pending.get()
            && !self.history_cells.is_empty()
            && render_settings.width > 0
            && content_area.height > 0
        {
            let prefix_ready = self.history_render.prefix_sums.borrow().len()
                > self.history_cells.len();
            if prefix_ready {
                self.history_virtualization_sync_pending.set(false);
                let _ = self.app_event_tx.send(AppEvent::SyncHistoryVirtualization);
            }
        }

        let mut total_height = self.history_render.last_total_height();
        let base_total_height = total_height;
        let viewport_rows = content_area.height;
        let mut requested_spacer_lines = 0u16;
        let mut remainder_for_log: Option<u16> = None;

        if total_height > 0 && viewport_rows > 0 && request_count > 0 {
            if base_total_height > viewport_rows {
                let remainder = base_total_height % viewport_rows;
                remainder_for_log = Some(remainder);
                if remainder == 0 {
                    requested_spacer_lines = if base_total_height == viewport_rows { 1 } else { 2 };
                } else if remainder <= 2 || remainder >= viewport_rows.saturating_sub(2) {
                    requested_spacer_lines = 1;
                }
            }
        }

        let composer_rows = self.layout.last_bottom_reserved_rows.get();
        let ensure_footer_space = self.layout.scroll_offset == 0
            && composer_rows > 0
            && base_total_height >= viewport_rows
            && request_count > 0;
        if ensure_footer_space {
            requested_spacer_lines = requested_spacer_lines.max(1);
        }

        let (spacer_lines, spacer_pending_shrink) = self
            .history_render
            .select_bottom_spacer_lines(requested_spacer_lines);

        if spacer_pending_shrink {
            // Force a follow-up frame so the spacer can settle back to the newly
            // requested height even if no additional history events arrive. Without
            // this, we'd keep the stale overscan row on-screen until the user types
            // or resizes the window again.
            let _ = self.app_event_tx.send(AppEvent::ScheduleFrameIn(
                HISTORY_ANIMATION_FRAME_INTERVAL,
            ));
        }

        if spacer_lines > 0 {
            total_height = total_height.saturating_add(spacer_lines);
            self.history_render
                .set_bottom_spacer_range(Some((base_total_height, total_height)));
            tracing::debug!(
                target: "code_tui::history_render",
                lines = spacer_lines,
                base_height = base_total_height,
                padded_height = total_height,
                viewport = viewport_rows,
                remainder = remainder_for_log,
                footer_padding = ensure_footer_space,
                "history overscan: adding bottom spacer",
            );
        } else {
            self.history_render.set_bottom_spacer_range(None);
        }
        let overscan_extra = total_height.saturating_sub(base_total_height);
        // Calculate scroll position and vertical alignment
        // Stabilize viewport when input area height changes while scrolled up.
        let prev_viewport_h = self.layout.last_history_viewport_height.get();
        if prev_viewport_h == 0 {
            // Initialize on first render
            self.layout
                .last_history_viewport_height
                .set(content_area.height);
        }

        let (start_y, scroll_pos) = if total_height <= content_area.height {
            // Content fits - always align to bottom so "Popular commands" stays at the bottom
            let start_y = content_area.y + content_area.height.saturating_sub(total_height);
            // Update last_max_scroll cache
            self.layout.last_max_scroll.set(0);
            (start_y, 0u16) // No scrolling needed
        } else {
            // Content overflows - calculate scroll position
            // scroll_offset is measured from the bottom (0 = bottom/newest)
            // Convert to distance from the top for rendering math.
            let max_scroll = total_height.saturating_sub(content_area.height);
            // Update cache and clamp for display only
            self.layout.last_max_scroll.set(max_scroll);
            let clamped_scroll_offset = self.layout.scroll_offset.min(max_scroll);
            let mut scroll_from_top = max_scroll.saturating_sub(clamped_scroll_offset);

            if overscan_extra > 0 && clamped_scroll_offset == 0 {
                scroll_from_top = scroll_from_top.saturating_sub(overscan_extra);
            }

            tracing::debug!(
                target: "code_tui::scrollback",
                total_height,
                base_total_height,
                viewport = content_area.height,
                overscan_extra,
                max_scroll,
                scroll_offset = clamped_scroll_offset,
                initial_scroll_from_top = scroll_from_top,
                "scrollback pre-adjust scroll position",
            );

            // Viewport stabilization: when user is scrolled up (offset > 0) and the
            // history viewport height changes due to the input area growing/shrinking,
            // adjust the scroll_from_top to keep the top line steady on screen.
            if clamped_scroll_offset > 0 {
                let prev_h = prev_viewport_h as i32;
                let curr_h = content_area.height as i32;
                let delta_h = prev_h - curr_h; // positive if viewport shrank
                if delta_h != 0 {
                    // Adjust in the opposite direction to keep the same top anchor
                    let sft = scroll_from_top as i32 - delta_h;
                    let sft = sft.clamp(0, max_scroll as i32) as u16;
                    scroll_from_top = sft;
                }
            }

            // If our scroll origin landed on a spacer row between cells, nudge it up so
            // the viewport starts with real content instead of an empty separator.
            let scroll_pos = if clamped_scroll_offset > 0 {
                let adjusted = self
                    .history_render
                    .adjust_scroll_to_content(scroll_from_top);
                tracing::debug!(
                    target: "code_tui::scrollback",
                    adjusted_scroll_from_top = adjusted,
                    scroll_from_top,
                    "scrollback adjusted scroll position",
                );
                adjusted
            } else {
                scroll_from_top
            };

            (content_area.y, scroll_pos)
        };

        // Record current viewport height for the next frame
        self.layout
            .last_history_viewport_height
            .set(content_area.height);

        let _perf_hist_clear_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };

        // Render the scrollable content with spacing using prefix sums
        let mut screen_y = start_y; // Position on screen
        let spacing = 1u16; // Spacing between cells
        let viewport_bottom = scroll_pos.saturating_add(content_area.height);
        let ps_ref = self.history_render.prefix_sums.borrow();
        let ps: &Vec<u16> = &ps_ref;
        let mut start_idx = match ps.binary_search(&scroll_pos) {
            Ok(i) => i,
            Err(i) => i.saturating_sub(1),
        };
        start_idx = start_idx.min(request_count);
        let mut end_idx = match ps.binary_search(&viewport_bottom) {
            Ok(i) => i,
            Err(i) => i,
        };
        end_idx = end_idx.saturating_add(1).min(request_count);

        enum VisibleRequests<'a> {
            Full(&'a [RenderRequest<'a>]),
            Owned(Vec<RenderRequest<'a>>),
        }

        let history_len = self.history_cells.len();
        let visible_requests = if let Some(ref full_requests) = render_requests_full {
            VisibleRequests::Full(&full_requests[start_idx..end_idx])
        } else {
            let render_request_cache = self.render_request_cache.borrow();
            let mut requests = Vec::with_capacity(end_idx.saturating_sub(start_idx));
            for idx in start_idx..end_idx {
                if idx < history_len {
                    let cell = &self.history_cells[idx];
                    let seed = &render_request_cache[idx];
                    let assistant = cell
                        .as_any()
                        .downcast_ref::<crate::history_cell::AssistantMarkdownCell>();
                    requests.push(RenderRequest {
                        history_id: seed.history_id,
                        cell: Some(cell.as_ref()),
                        assistant,
                        use_cache: seed.use_cache,
                        fallback_lines: seed.fallback_lines.clone(),
                        kind: seed.kind.clone(),
                        config: &self.config,
                    });
                    continue;
                }

                let extra_idx = idx.saturating_sub(history_len);
                let mut extra_cursor = 0usize;
                if let Some(ref cell) = self.active_exec_cell {
                    if extra_idx == extra_cursor {
                        requests.push(RenderRequest {
                            history_id: HistoryId::ZERO,
                            cell: Some(cell as &dyn HistoryCell),
                            assistant: None,
                            use_cache: false,
                            fallback_lines: None,
                            kind: RenderRequestKind::Legacy,
                            config: &self.config,
                        });
                        continue;
                    }
                    extra_cursor = extra_cursor.saturating_add(1);
                }

                if let Some(ref cell) = streaming_cell {
                    if extra_idx == extra_cursor {
                        requests.push(RenderRequest {
                            history_id: HistoryId::ZERO,
                            cell: Some(cell as &dyn HistoryCell),
                            assistant: None,
                            use_cache: false,
                            fallback_lines: None,
                            kind: RenderRequestKind::Legacy,
                            config: &self.config,
                        });
                        continue;
                    }
                    extra_cursor = extra_cursor.saturating_add(1);
                }

                let queued_idx = extra_idx.saturating_sub(extra_cursor);
                if let Some(cell) = queued_preview_cells.get(queued_idx) {
                    requests.push(RenderRequest {
                        history_id: HistoryId::ZERO,
                        cell: Some(cell as &dyn HistoryCell),
                        assistant: None,
                        use_cache: false,
                        fallback_lines: None,
                        kind: RenderRequestKind::Legacy,
                        config: &self.config,
                    });
                }
            }
            VisibleRequests::Owned(requests)
        };

        let visible_requests_slice = match &visible_requests {
            VisibleRequests::Full(slice) => *slice,
            VisibleRequests::Owned(vec) => vec.as_slice(),
        };

        if perf_enabled {
            let mut p = self.perf_state.stats.borrow_mut();
            p.render_requests_visible = p
                .render_requests_visible
                .saturating_add(visible_requests_slice.len() as u64);
        }

        let mut _subset_rendered: Option<Vec<VisibleCell>> = None;
        let visible_slice: &[VisibleCell] = if let Some(ref full) = rendered_cells_full {
            &full[start_idx..end_idx]
        } else {
            _subset_rendered = Some(self.history_render.visible_cells(
                &self.history_state,
                visible_requests_slice,
                render_settings,
            ));
            _subset_rendered.as_ref().map(|v| v.as_slice()).unwrap_or(&[])
        };

        // Only schedule animation frames if an animating cell is actually visible.
        let has_visible_animation = visible_slice.iter().any(|visible| {
            visible
                .cell
                .map(|cell| cell.is_animating())
                .unwrap_or(false)
        });
        if has_visible_animation && !ChatWidget::auto_reduced_motion_preference() {
            tracing::debug!("Visible animation detected, scheduling next frame");
            self.app_event_tx
                .send(AppEvent::ScheduleFrameIn(HISTORY_ANIMATION_FRAME_INTERVAL));
        }

        let render_loop_start = if self.perf_state.enabled {
            Some(std::time::Instant::now())
        } else {
            None
        };
        #[derive(Debug)]
        struct HeightMismatch {
            history_id: HistoryId,
            cached: u16,
            recomputed: u16,
            idx: usize,
            preview: String,
        }

        let mut height_mismatches: Vec<HeightMismatch> = Vec::new();
        let is_collapsed_reasoning_at = |idx: usize| {
            if idx >= request_count {
                return false;
            }
            if idx < history_len {
                return self.history_cells[idx]
                    .as_any()
                    .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                    .map(|rc| rc.is_collapsed())
                    .unwrap_or(false);
            }
            false
        };

        for (offset, visible) in visible_slice.iter().enumerate() {
            let idx = start_idx + offset;
            let item = visible
                .cell
                .expect("visible cell missing backing cell for render");
            // Calculate height with reduced width due to gutter
            const GUTTER_WIDTH: u16 = 2;
            let content_width = content_area.width.saturating_sub(GUTTER_WIDTH);
            let maybe_assistant = item
                .as_any()
                .downcast_ref::<crate::history_cell::AssistantMarkdownCell>();
            let is_streaming = item
                .as_any()
                .downcast_ref::<crate::history_cell::StreamingContentCell>()
                .is_some();

            let mut layout_for_render: Option<Rc<CachedLayout>> = visible
                .layout
                .as_ref()
                .map(|lr| lr.layout());

            let item_height = visible.height;
            if content_area.width > 0 {
                if let Some(req) = visible_requests_slice.get(offset) {
                    if req.history_id != HistoryId::ZERO
                        && matches!(item.kind(), history_cell::HistoryCellType::Reasoning)
                    {
                        if item_height == 0 && content_width == 0 {
                            // Zero-width viewport leaves both cached and computed heights at 0.
                            // Skip to avoid false positives during aggressive window resizes.
                            continue;
                        }

                        #[cfg(debug_assertions)]
                        {
                            let mut preview: Option<String> = None;
                            let fresh = item.desired_height(content_width);
                            if fresh != item_height {
                                if preview.is_none() {
                                    let lines = item.display_lines_trimmed();
                                    if !lines.is_empty() {
                                        preview = Some(ChatWidget::reasoning_preview(&lines));
                                    }
                                }
                                height_mismatches.push(HeightMismatch {
                                    history_id: req.history_id,
                                    cached: item_height,
                                    recomputed: fresh,
                                    idx,
                                    preview: preview.unwrap_or_default(),
                                });
                            }
                        }
                    }
                }
            }
            if self.perf_state.enabled
                && rendered_cells_full.is_none()
                && matches!(visible.height_source, history_render::HeightSource::DesiredHeight)
            {
                let mut p = self.perf_state.stats.borrow_mut();
                p.height_misses_render = p.height_misses_render.saturating_add(1);
                if let Some(ns) = visible.height_measure_ns {
                    let label = self.perf_label_for_item(item);
                    p.record_render((idx, content_width), label.as_str(), ns);
                }
            }

            let content_y = ps[idx];

            // The prefix sums already account for spacer rows between cells (and omit the
            // trailing spacer). Avoid additional compensation when rendering the final
            // visible cell; otherwise we double-count spacing and trim the last line.
            let skip_top = if content_y < scroll_pos {
                scroll_pos - content_y
            } else {
                0
            };

            // Stop if we've gone past the bottom of the screen
            if screen_y >= content_area.y + content_area.height {
                break;
            }

            // Calculate how much height is available for this item
            let available_height = (content_area.y + content_area.height).saturating_sub(screen_y);
            let visible_height = item_height.saturating_sub(skip_top).min(available_height);


            if visible_height > 0 {
                // Define gutter width (2 chars: symbol + space)
                const GUTTER_WIDTH: u16 = 2;

                // Split area into gutter and content
                let gutter_area = Rect {
                    x: content_area.x,
                    y: screen_y,
                    width: GUTTER_WIDTH.min(content_area.width),
                    height: visible_height,
                };

                let item_area = Rect {
                    x: content_area.x + GUTTER_WIDTH.min(content_area.width),
                    y: screen_y,
                    width: content_area.width.saturating_sub(GUTTER_WIDTH),
                    height: visible_height,
                };

                if history_cell_logging_enabled() {
                    let row_start = item_area.y;
                    let row_end = item_area
                        .y
                        .saturating_add(visible_height)
                        .saturating_sub(1);
                    let cache_hit = layout_for_render.is_some();
                    tracing::info!(
                        target: "code_tui::history_cells",
                        idx,
                        kind = ?item.kind(),
                        row_start,
                        row_end,
                        height = visible_height,
                        width = item_area.width,
                        skip_rows = skip_top,
                        item_height,
                        content_y,
                        cache_hit,
                        assistant = maybe_assistant.is_some(),
                        streaming = is_streaming,
                        custom = item.has_custom_render(),
                        animating = item.is_animating(),
                        "history cell render",
                    );
                }

                // Paint gutter background. For Assistant and Auto Review, extend the tint under the
                // gutter and also one extra column to the left (so the • has color on both sides),
                // without changing layout or symbol positions.
                let is_assistant =
                    matches!(item.kind(), crate::history_cell::HistoryCellType::Assistant);
                let is_auto_review = ChatWidget::is_auto_review_cell(item);
                let auto_review_bg = crate::history_cell::PlainHistoryCell::auto_review_bg();
                let gutter_bg = if is_assistant {
                    crate::colors::assistant_bg()
                } else if is_auto_review {
                    auto_review_bg
                } else {
                    crate::colors::background()
                };

                // Paint gutter background for assistant/auto-review cells so the tinted
                // strip appears contiguous with the message body. This avoids
                // the light "hole" seen after we reduced redraws. For other
                // cell types keep the default background (already painted by
                // the frame bg fill above).
                if (is_assistant || is_auto_review) && gutter_area.width > 0 && gutter_area.height > 0 {
                    let _perf_gutter_start = if self.perf_state.enabled {
                        Some(std::time::Instant::now())
                    } else {
                        None
                    };
                    let style = Style::default().bg(gutter_bg);
                    let mut tint_x = gutter_area.x;
                    let mut tint_width = gutter_area.width;
                    if content_area.x > history_area.x {
                        tint_x = content_area.x.saturating_sub(1);
                        tint_width = tint_width.saturating_add(1);
                    }
                    let tint_rect = Rect::new(tint_x, gutter_area.y, tint_width, gutter_area.height);
                    fill_rect(buf, tint_rect, Some(' '), style);
                    // Also tint one column immediately to the right of the content area
                    // so the assistant block is visually bookended. This column lives in the
                    // right padding stripe; when the scrollbar is visible it will draw over
                    // the far-right edge, which is fine.
                    let right_col_x = content_area.x.saturating_add(content_area.width);
                    let history_right = history_area.x.saturating_add(history_area.width);
                    if right_col_x < history_right {
                        let right_rect = Rect::new(right_col_x, item_area.y, 1, item_area.height);
                        fill_rect(buf, right_rect, Some(' '), style);
                    }
                    if let Some(t0) = _perf_gutter_start {
                        let dt = t0.elapsed().as_nanos();
                        let mut p = self.perf_state.stats.borrow_mut();
                        p.ns_gutter_paint = p.ns_gutter_paint.saturating_add(dt);
                        // Rough accounting: area of gutter rectangle (clamped to u64)
                        let area_cells: u64 =
                            (gutter_area.width as u64).saturating_mul(gutter_area.height as u64);
                        p.cells_gutter_paint = p.cells_gutter_paint.saturating_add(area_cells);
                    }
                }

                // Render gutter symbol if present
                if let Some(symbol) = item.gutter_symbol() {
                    // Choose color based on symbol/type
                    let color = if is_auto_review {
                        crate::colors::success()
                    } else if symbol == "❯" {
                        // Executed arrow – color reflects exec state
                        if let Some(exec) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::ExecCell>()
                        {
                            match &exec.output {
                                None => crate::colors::text(), // Running...
                                // Successful runs use the theme success color so the arrow stays visible on all themes
                                Some(o) if o.exit_code == 0 => crate::colors::text(),
                                Some(_) => crate::colors::error(),
                            }
                        } else {
                            // Handle merged exec cells (multi-block "Ran") the same as single execs
                            match item.kind() {
                                crate::history_cell::HistoryCellType::Exec {
                                    kind: crate::history_cell::ExecKind::Run,
                                    status: crate::history::state::ExecStatus::Success,
                                } => crate::colors::text(),
                                crate::history_cell::HistoryCellType::Exec {
                                    kind: crate::history_cell::ExecKind::Run,
                                    status: crate::history::state::ExecStatus::Error,
                                } => crate::colors::error(),
                                crate::history_cell::HistoryCellType::Exec { .. } => {
                                    crate::colors::text()
                                }
                                _ => crate::colors::text(),
                            }
                        }
                    } else if symbol == "↯" {
                        // Patch/Updated arrow color – match the header text color
                        match item.kind() {
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplySuccess,
                            } => crate::colors::success(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplyBegin,
                            } => crate::colors::success(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::Proposed,
                            } => crate::colors::primary(),
                            crate::history_cell::HistoryCellType::Patch {
                                kind: crate::history_cell::PatchKind::ApplyFailure,
                            } => crate::colors::error(),
                            _ => crate::colors::primary(),
                        }
                    } else if matches!(symbol, "◐" | "◓" | "◑" | "◒")
                        && item
                            .as_any()
                            .downcast_ref::<crate::history_cell::RunningToolCallCell>()
                            .map_or(false, |cell| cell.has_title("Waiting"))
                    {
                        crate::colors::text_bright()
                    } else if matches!(symbol, "○" | "◔" | "◑" | "◕" | "●") {
                        if let Some(plan_cell) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::PlanUpdateCell>()
                        {
                            if plan_cell.is_complete() {
                                crate::colors::success()
                            } else {
                                crate::colors::info()
                            }
                        } else {
                            crate::colors::success()
                        }
                    } else {
                        match symbol {
                            "›" => crate::colors::text(),        // user
                            "⋮" => crate::colors::primary(),     // thinking
                            "•" => crate::colors::text_bright(), // codex/agent
                            "⚙" => crate::colors::info(),        // tool working
                            "✔" => crate::colors::success(),     // tool complete
                            "✖" => crate::colors::error(),       // error
                            "★" => crate::colors::text_bright(), // notice/popular
                            _ => crate::colors::text_dim(),
                        }
                    };

                    // Draw the symbol anchored to the top of the message (not the viewport).
                    // "Top of the message" accounts for any intentional top padding per cell type.
                    // As you scroll past that anchor, the icon scrolls away with the message.
                    if gutter_area.width >= 2 {
                        // Anchor offset counted from the very start of the item's painted area
                        // to the first line of its content that the icon should align with.
                        let anchor_offset: u16 = match item.kind() {
                            // Assistant messages render with one row of top padding so that
                            // the content visually aligns; anchor to that second row.
                            crate::history_cell::HistoryCellType::Assistant => 1,
                            _ if is_auto_review => {
                                crate::history_cell::PlainHistoryCell::auto_review_padding().0
                            }
                            _ => 0,
                        };

                        // If we've scrolled past the anchor line, don't render the icon.
                        if skip_top <= anchor_offset {
                            let rel = anchor_offset - skip_top; // rows from current viewport top
                            let symbol_y = gutter_area.y.saturating_add(rel);
                            if symbol_y < gutter_area.y.saturating_add(gutter_area.height) {
                                let symbol_style = Style::default().fg(color).bg(gutter_bg);
                                let symbol_x = gutter_area.x;
                                buf.set_string(symbol_x, symbol_y, symbol, symbol_style);
                            }
                        }
                    }
                }

                // Render only the visible window of the item using vertical skip
                let skip_rows = skip_top;

                // Log all cells being rendered
                let is_animating = item.is_animating();
                let has_custom = item.has_custom_render();

                if is_animating || has_custom {
                    tracing::debug!(
                        ">>> RENDERING ANIMATION Cell[{}]: area={:?}, skip_rows={}",
                        idx,
                        item_area,
                        skip_rows
                    );
                }

                // Render the cell content first
                let mut handled_assistant = false;
                if let Some(plan) = visible.assistant_plan.as_ref() {
                    if let Some(assistant) = visible
                        .cell
                        .and_then(|c| c.as_any().downcast_ref::<crate::history_cell::AssistantMarkdownCell>())
                    {
                        if skip_rows < plan.total_rows() && item_area.height > 0 {
                            assistant.render_with_layout(plan.as_ref(), item_area, buf, skip_rows);
                        }
                        handled_assistant = true;
                        layout_for_render = None;
                    }
                }

                if !handled_assistant {
                    if let Some(layout_rc) = layout_for_render.as_ref() {
                        self.render_cached_lines(
                            item,
                            layout_rc.as_ref(),
                            item_area,
                            buf,
                            skip_rows,
                        );
                    } else {
                        item.render_with_skip(item_area, buf, skip_rows);
                    }
                }

                // Debug: overlay order info on the spacing row below (or above if needed).
                if self.show_order_overlay {
                    if let Some(Some(info)) = self.cell_order_dbg.get(idx) {
                        let mut text = format!("⟦{}⟧", info);
                        // Live reasoning diagnostics: append current title detection snapshot
                        if let Some(rc) = item
                            .as_any()
                            .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                        {
                            let snap = rc.debug_title_overlay();
                            text.push_str(" | ");
                            text.push_str(&snap);
                        }
                        let style = Style::default().fg(crate::colors::text_dim());
                        // Prefer below the item in the one-row spacing area
                        let below_y = item_area.y.saturating_add(visible_height);
                        let bottom_y = content_area.y.saturating_add(content_area.height);
                        let maxw = item_area.width as usize;
                        // Truncate safely by display width, not by bytes, to avoid
                        // panics on non-UTF-8 boundaries (e.g., emoji/CJK). Use the
                        // same width logic as our live wrap utilities.
                        let draw_text = {
                            use unicode_width::UnicodeWidthStr as _;
                            if text.width() > maxw {
                                crate::live_wrap::take_prefix_by_width(&text, maxw).0
                            } else {
                                text.clone()
                            }
                        };
                        if item_area.width > 0 {
                            if below_y < bottom_y {
                                buf.set_string(item_area.x, below_y, draw_text.clone(), style);
                            } else if item_area.y > content_area.y {
                                // Fall back to above the item if no space below
                                let above_y = item_area.y.saturating_sub(1);
                                buf.set_string(item_area.x, above_y, draw_text.clone(), style);
                            }
                        }
                    }
                }
                screen_y += visible_height;
            }

            // Add spacing only if something was actually rendered for this item.
            // Prevent a stray blank when zero-height, and suppress spacing between
            // consecutive collapsed reasoning titles so they appear as a tight list.
            if idx == request_count.saturating_sub(1) {
                let viewport_top = content_area.y;
                let viewport_bottom = content_area.y.saturating_add(content_area.height);
                tracing::debug!(
                    target: "code_tui::scrollback",
                    idx,
                    request_count,
                    content_y,
                    scroll_pos,
                    viewport_top,
                    viewport_bottom,
                    skip_top,
                    item_height,
                    available_height,
                    visible_height,
                    screen_y,
                    spacing,
                    "last visible history cell metrics"
                );
            }

            let mut should_add_spacing = idx < request_count.saturating_sub(1) && visible_height > 0;
            if should_add_spacing {
                // Special-case: two adjacent collapsed reasoning cells → no spacer.
                let this_is_collapsed_reasoning = item
                    .as_any()
                    .downcast_ref::<crate::history_cell::CollapsibleReasoningCell>()
                    .map(|rc| rc.is_collapsed())
                    .unwrap_or(false);
                if this_is_collapsed_reasoning {
                    let prev_is_collapsed_reasoning = idx
                        .checked_sub(1)
                        .map(is_collapsed_reasoning_at)
                        .unwrap_or(false);
                    let next_is_collapsed_reasoning = is_collapsed_reasoning_at(idx + 1);
                    if prev_is_collapsed_reasoning && next_is_collapsed_reasoning {
                        should_add_spacing = false;
                    }
                }
            }
            if should_add_spacing {
                let bottom = content_area.y + content_area.height;
                if screen_y < bottom {
                    // Maintain the single-row spacer between cells (critical for explore →
                    // reasoning bundles) while respecting the visible viewport height. This keeps
                    // the rendered gaps consistent with the cached prefix sums even after scroll
                    // adjustments.
                    let spacing_rows = spacing.min(bottom.saturating_sub(screen_y));
                    screen_y = screen_y.saturating_add(spacing_rows);
                }
            }
        }

        drop(ps_ref);

        if let Some(first) = height_mismatches.first() {
            for mismatch in &height_mismatches {
                tracing::error!(
                    target: "code_tui::history_cells",
                    history_id = ?mismatch.history_id,
                    idx = mismatch.idx,
                    cached = mismatch.cached,
                    recomputed = mismatch.recomputed,
                    preview = %mismatch.preview,
                    "History cell height mismatch detected; aborting to capture repro",
                );
            }
            panic!(
                "history cell height mismatch ({} cases); first id={:?} cached={} recomputed={} preview={}",
                height_mismatches.len(),
                first.history_id,
                first.cached,
                first.recomputed,
                first.preview
            );
        }
        if let Some(start) = render_loop_start {
            if self.perf_state.enabled {
                let elapsed = start.elapsed().as_nanos();
                let pending_scroll = self.perf_state.pending_scroll_rows.get();
                {
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_render_loop = p.ns_render_loop.saturating_add(elapsed);
                    if pending_scroll > 0 {
                        p.record_scroll_render(pending_scroll, elapsed);
                    }
                }
                if pending_scroll > 0 {
                    self.perf_state.pending_scroll_rows.set(0);
                }
            }
        }

        // Clear any bottom gap inside the content area that wasn’t covered by items
        if screen_y < content_area.y + content_area.height {
            let _perf_hist_clear2 = if self.perf_state.enabled {
                Some(std::time::Instant::now())
            } else {
                None
            };
            let gap_height = (content_area.y + content_area.height).saturating_sub(screen_y);
            if gap_height > 0 {
                let gap_rect = Rect::new(content_area.x, screen_y, content_area.width, gap_height);
                fill_rect(buf, gap_rect, Some(' '), base_style);
            }
            if let Some(t0) = _perf_hist_clear2 {
                let dt = t0.elapsed().as_nanos();
                let mut p = self.perf_state.stats.borrow_mut();
                p.ns_history_clear = p.ns_history_clear.saturating_add(dt);
                let cells = (content_area.width as u64)
                    * ((content_area.y + content_area.height - screen_y) as u64);
                p.cells_history_clear = p.cells_history_clear.saturating_add(cells);
            }
        }

        // Render vertical scrollbar when content is scrollable and currently visible
        // Auto-hide after a short delay to avoid copying it along with text.
        let now = std::time::Instant::now();
        let show_scrollbar = total_height > content_area.height
            && self
                .layout
                .scrollbar_visible_until
                .get()
                .map(|t| now < t)
                .unwrap_or(false);
        if show_scrollbar {
            let mut sb_state = self.layout.vertical_scrollbar_state.borrow_mut();
            // Scrollbar expects number of scroll positions, not total rows.
            // For a viewport of H rows and content of N rows, there are
            // max_scroll = N - H positions; valid positions = [0, max_scroll].
            let max_scroll = total_height.saturating_sub(content_area.height);
            let scroll_positions = max_scroll.saturating_add(1).max(1) as usize;
            let pos = scroll_pos.min(max_scroll) as usize;
            *sb_state = sb_state.content_length(scroll_positions).position(pos);
            // Theme-aware scrollbar styling (line + block)
            // Track: thin line using border color; Thumb: block using border_focused.
            let theme = crate::theme::current_theme();
            let sb = Scrollbar::new(ScrollbarOrientation::VerticalRight)
                .symbols(scrollbar_symbols::VERTICAL)
                .begin_symbol(None)
                .end_symbol(None)
                .track_symbol(Some("│"))
                .track_style(
                    Style::default()
                        .fg(crate::colors::border())
                        .bg(crate::colors::background()),
                )
                .thumb_symbol("█")
                .thumb_style(
                    Style::default()
                        .fg(theme.border_focused)
                        .bg(crate::colors::background()),
                );
            // To avoid a small jump at the bottom due to spacer toggling,
            // render the scrollbar in a slightly shorter area (reserve 1 row).
            let sb_area = Rect {
                x: history_area.x,
                y: history_area.y,
                width: history_area.width,
                height: history_area.height.saturating_sub(1),
            };
            StatefulWidget::render(sb, sb_area, buf, &mut sb_state);
        }

        if self.terminal.overlay().is_some() {
            let bg_style = Style::default().bg(crate::colors::background());
            fill_rect(buf, bottom_pane_area, Some(' '), bg_style);
        } else if self.agents_terminal.active {
            let bg_style = Style::default().bg(crate::colors::background());
            fill_rect(buf, bottom_pane_area, Some(' '), bg_style);
        } else {
            // Render the bottom pane directly without a border for now
            // The composer has its own layout with hints at the bottom
            (&self.bottom_pane).render(bottom_pane_area, buf);
        }

        if let Some(overlay) = self.terminal.overlay() {
            let scrim_style = Style::default()
                .bg(crate::colors::overlay_scrim())
                .fg(crate::colors::text_dim());
            fill_rect(buf, area, None, scrim_style);

            let padding = 1u16;
            let footer_reserved = 1.min(bottom_pane_area.height);
            let overlay_bottom = (bottom_pane_area.y + bottom_pane_area.height)
                .saturating_sub(footer_reserved);
            let overlay_height = overlay_bottom
                .saturating_sub(history_area.y)
                .max(1)
                .min(area.height);
            let window_area = Rect {
                x: history_area.x + padding,
                y: history_area.y,
                width: history_area.width.saturating_sub(padding * 2),
                height: overlay_height,
            };
            Clear.render(window_area, buf);

            let block = Block::default()
                .borders(Borders::ALL)
                .title(ratatui::text::Line::from(vec![
                    ratatui::text::Span::styled(
                        format!(" Terminal - {} ", overlay.title),
                        Style::default().fg(crate::colors::text()),
                    ),
                ]))
                .style(Style::default().bg(crate::colors::background()))
                .border_style(
                    Style::default()
                        .fg(crate::colors::border())
                        .bg(crate::colors::background()),
                );
            let inner = block.inner(window_area);
            block.render(window_area, buf);

            let inner_bg = Style::default().bg(crate::colors::background());
            for y in inner.y..inner.y + inner.height {
                for x in inner.x..inner.x + inner.width {
                    buf[(x, y)].set_style(inner_bg);
                }
            }

            let content = inner.inner(ratatui::layout::Margin::new(1, 0));
            if content.height == 0 || content.width == 0 {
                self.terminal.last_visible_rows.set(0);
                self.terminal.last_visible_cols.set(0);
            } else {
                let header_height = 1.min(content.height);
                let footer_height = if content.height >= 2 { 2 } else { 0 };

                let header_area = Rect {
                    x: content.x,
                    y: content.y,
                    width: content.width,
                    height: header_height,
                };
                let footer_area = if footer_height > 0 {
                    Rect {
                        x: content.x,
                        y: content
                            .y
                            .saturating_add(content.height.saturating_sub(footer_height)),
                        width: content.width,
                        height: footer_height,
                    }
                } else {
                    header_area
                };

                if header_height > 0 {
                    fill_rect(buf, header_area, Some(' '), inner_bg);
                    let width_limit = header_area.width as usize;
                    let mut header_spans: Vec<ratatui::text::Span<'static>> = Vec::new();
                    let mut consumed_width: usize = 0;

                    if overlay.running {
                        let now_ms = std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis();
                        let frame = crate::spinner::frame_at_time(
                            crate::spinner::current_spinner(),
                            now_ms,
                        );
                        if !frame.is_empty() {
                            consumed_width += frame.chars().count();
                            header_spans.push(ratatui::text::Span::styled(
                                frame,
                                Style::default().fg(crate::colors::spinner()),
                            ));
                            header_spans.push(ratatui::text::Span::raw(" "));
                            consumed_width = consumed_width.saturating_add(1);
                        }

                        let status_text = overlay
                            .start_time
                            .map(|start| format!("Running… ({})", format_duration(start.elapsed())))
                            .unwrap_or_else(|| "Running…".to_string());
                        consumed_width = consumed_width
                            .saturating_add(UnicodeWidthStr::width(status_text.as_str()));
                        header_spans.push(ratatui::text::Span::styled(
                            status_text,
                            Style::default().fg(crate::colors::text_dim()),
                        ));

                        let interval = crate::spinner::current_spinner().interval_ms.max(50);
                        self.app_event_tx
                            .send(AppEvent::ScheduleFrameIn(Duration::from_millis(interval)));
                    } else {
                        let (icon, color, status_text) = match overlay.exit_code {
                            Some(0) => (
                                "✔",
                                crate::colors::success(),
                                overlay
                                    .duration
                                    .map(|d| format!("Completed in {}", format_duration(d)))
                                    .unwrap_or_else(|| "Completed".to_string()),
                            ),
                            Some(code) => (
                                "✖",
                                crate::colors::error(),
                                overlay
                                    .duration
                                    .map(|d| format!("Exit {code} in {}", format_duration(d)))
                                    .unwrap_or_else(|| format!("Exit {code}")),
                            ),
                            None => (
                                "⚠",
                                crate::colors::warning(),
                                overlay
                                    .duration
                                    .map(|d| format!("Stopped after {}", format_duration(d)))
                                    .unwrap_or_else(|| "Stopped".to_string()),
                            ),
                        };

                        header_spans.push(ratatui::text::Span::styled(
                            format!("{icon} "),
                            Style::default().fg(color),
                        ));
                        consumed_width = consumed_width.saturating_add(icon.chars().count() + 1);

                        consumed_width = consumed_width
                            .saturating_add(UnicodeWidthStr::width(status_text.as_str()));
                        header_spans.push(ratatui::text::Span::styled(
                            status_text,
                            Style::default().fg(crate::colors::text_dim()),
                        ));
                    }

                    if !overlay.command_display.is_empty() && width_limit > consumed_width + 5 {
                        let remaining = width_limit.saturating_sub(consumed_width + 5);
                        if remaining > 0 {
                            let truncated = ChatWidget::truncate_with_ellipsis(
                                &overlay.command_display,
                                remaining,
                            );
                            if !truncated.is_empty() {
                                header_spans.push(ratatui::text::Span::styled(
                                    "  •  ",
                                    Style::default().fg(crate::colors::text_dim()),
                                ));
                                header_spans.push(ratatui::text::Span::styled(
                                    truncated,
                                    Style::default().fg(crate::colors::text()),
                                ));
                            }
                        }
                    }

                    let header_line = ratatui::text::Line::from(header_spans);
                    Paragraph::new(RtText::from(vec![header_line]))
                        .wrap(ratatui::widgets::Wrap { trim: true })
                        .render(header_area, buf);
                }

                let mut body_space = content
                    .height
                    .saturating_sub(header_height.saturating_add(footer_height));
                let body_top = header_area.y.saturating_add(header_area.height);
                let mut bottom_cursor = body_top.saturating_add(body_space);

                let mut pending_visible = false;
                let mut pending_box: Option<(Rect, Vec<RtLine<'static>>)> = None;
                if let Some(pending) = overlay.pending_command.as_ref() {
                    if let Some((pending_lines, pending_height)) =
                        pending_command_box_lines(pending, content.width)
                    {
                        if pending_height <= body_space && pending_height > 0 {
                            bottom_cursor = bottom_cursor.saturating_sub(pending_height);
                            let pending_area = Rect {
                                x: content.x,
                                y: bottom_cursor,
                                width: content.width,
                                height: pending_height,
                            };
                            body_space = body_space.saturating_sub(pending_height);
                            pending_box = Some((pending_area, pending_lines));
                            pending_visible = true;
                        }
                    }
                }

                let body_area = Rect {
                    x: content.x,
                    y: body_top,
                    width: content.width,
                    height: body_space,
                };

                // Body content
                let rows = body_area.height;
                let cols = body_area.width;
                let prev_rows = self.terminal.last_visible_rows.replace(rows);
                let prev_cols = self.terminal.last_visible_cols.replace(cols);
                if rows > 0 && cols > 0 && (prev_rows != rows || prev_cols != cols) {
                    self.app_event_tx.send(AppEvent::TerminalResize {
                        id: overlay.id,
                        rows,
                        cols,
                    });
                }

                if rows > 0 && cols > 0 {
                    let mut rendered_rows: Vec<RtLine<'static>> = Vec::new();
                    if overlay.truncated {
                        rendered_rows.push(ratatui::text::Line::from(vec![
                            ratatui::text::Span::styled(
                                "… output truncated (showing last 10,000 lines)",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]));
                    }
                    rendered_rows.extend(overlay.lines.iter().cloned());
                    let total = rendered_rows.len();
                    let visible = rows as usize;
                    if visible > 0 {
                        let max_scroll = total.saturating_sub(visible);
                        let scroll = (overlay.scroll as usize).min(max_scroll);
                        let end = (scroll + visible).min(total);
                        let window = rendered_rows.get(scroll..end).unwrap_or(&[]);
                        Paragraph::new(RtText::from(window.to_vec()))
                            .wrap(ratatui::widgets::Wrap { trim: false })
                            .render(body_area, buf);
                    }
                }

                if let Some((pending_area, pending_lines)) = pending_box {
                    render_text_box(
                        pending_area,
                        " Command ",
                        crate::colors::function(),
                        pending_lines,
                        buf,
                    );
                }

                // Footer hints
                let mut footer_spans = vec![
                    ratatui::text::Span::styled(
                        "↑↓",
                        Style::default().fg(crate::colors::function()),
                    ),
                    ratatui::text::Span::styled(
                        " Scroll  ",
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                    ratatui::text::Span::styled(
                        "Esc",
                        Style::default().fg(crate::colors::error()),
                    ),
                    ratatui::text::Span::styled(
                        if overlay.running { " Cancel  " } else { " Close  " },
                        Style::default().fg(crate::colors::text_dim()),
                    ),
                ];
                if overlay.running {
                    footer_spans.push(ratatui::text::Span::styled(
                        "Ctrl+C",
                        Style::default().fg(crate::colors::warning()),
                    ));
                    footer_spans.push(ratatui::text::Span::styled(
                        " Cancel",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                } else if pending_visible {
                    footer_spans.push(ratatui::text::Span::styled(
                        "Enter",
                        Style::default().fg(crate::colors::primary()),
                    ));
                    footer_spans.push(ratatui::text::Span::styled(
                        " Run",
                        Style::default().fg(crate::colors::text_dim()),
                    ));
                }
                if footer_height > 1 {
                    let spacer_area = Rect {
                        x: footer_area.x,
                        y: footer_area.y,
                        width: footer_area.width,
                        height: footer_area.height.saturating_sub(1),
                    };
                    fill_rect(buf, spacer_area, Some(' '), inner_bg);
                }

                let instructions_area = Rect {
                    x: footer_area.x,
                    y: footer_area.y.saturating_add(footer_area.height.saturating_sub(1)),
                    width: footer_area.width,
                    height: 1,
                };

                Paragraph::new(RtText::from(vec![ratatui::text::Line::from(footer_spans)]))
                    .wrap(ratatui::widgets::Wrap { trim: true })
                    .alignment(ratatui::layout::Alignment::Left)
                    .render(instructions_area, buf);
            }
        }

        if self.terminal.overlay().is_none() && self.browser_overlay_visible {
            self.render_browser_overlay(area, history_area, bottom_pane_area, buf);
            return;
        }

        if self.terminal.overlay().is_none() && self.agents_terminal.active {
            self.render_agents_terminal_overlay(area, history_area, bottom_pane_area, buf);
        }

        // Terminal overlay takes precedence over other overlays

        // Welcome animation is kept as a normal cell in history; no overlay.

        // The welcome animation is no longer rendered as an overlay.

        let terminal_overlay_none = self.terminal.overlay().is_none();
        let agents_terminal_active = self.agents_terminal.active;
        if terminal_overlay_none && !agents_terminal_active {
            if let Some(overlay) = self.settings.overlay.as_ref() {
                self.render_settings_overlay(area, history_area, buf, overlay);
            } else if let Some(overlay) = &self.diffs.overlay {
                // Global scrim: dim the whole background to draw focus to the viewer
                // We intentionally do this across the entire widget area rather than just the
                // history area so the viewer stands out even with browser HUD or status bars.
                let scrim_bg = Style::default()
                    .bg(crate::colors::overlay_scrim())
                    .fg(crate::colors::text_dim());
                let _perf_scrim_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                fill_rect(buf, area, None, scrim_bg);
                if let Some(t0) = _perf_scrim_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_scrim = p.ns_overlay_scrim.saturating_add(dt);
                    let cells = (area.width as u64) * (area.height as u64);
                    p.cells_overlay_scrim = p.cells_overlay_scrim.saturating_add(cells);
                }
                // Match the horizontal padding used by status bar and input
                let padding = 1u16;
                let area = Rect {
                    x: history_area.x + padding,
                    y: history_area.y,
                    width: history_area.width.saturating_sub(padding * 2),
                    height: history_area.height,
                };

                // Clear and repaint the overlay area with theme scrim background
                Clear.render(area, buf);
                let bg_style = Style::default().bg(crate::colors::overlay_scrim());
                let _perf_overlay_area_bg_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                fill_rect(buf, area, None, bg_style);
                if let Some(t0) = _perf_overlay_area_bg_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                    let cells = (area.width as u64) * (area.height as u64);
                    p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                }

                // Build a styled title: keys/icons in normal text color; descriptors and dividers dim
                let t_dim = Style::default().fg(crate::colors::text_dim());
                let t_fg = Style::default().fg(crate::colors::text());
                let has_tabs = overlay.tabs.len() > 1;
                let mut title_spans: Vec<ratatui::text::Span<'static>> = vec![
                    ratatui::text::Span::styled(" ", t_dim),
                    ratatui::text::Span::styled("Diff viewer", t_fg),
                ];
                if has_tabs {
                    title_spans.extend_from_slice(&[
                        ratatui::text::Span::styled(" ——— ", t_dim),
                        ratatui::text::Span::styled("◂ ▸", t_fg),
                        ratatui::text::Span::styled(" change tabs ", t_dim),
                    ]);
                }
                title_spans.extend_from_slice(&[
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("e", t_fg),
                    ratatui::text::Span::styled(" explain ", t_dim),
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("u", t_fg),
                    ratatui::text::Span::styled(" undo ", t_dim),
                    ratatui::text::Span::styled("——— ", t_dim),
                    ratatui::text::Span::styled("Esc", t_fg),
                    ratatui::text::Span::styled(" close ", t_dim),
                ]);
                let block = Block::default()
                    .borders(Borders::ALL)
                    .title(ratatui::text::Line::from(title_spans))
                    // Use normal background for the window itself so it contrasts against the
                    // dimmed scrim behind
                    .style(Style::default().bg(crate::colors::background()))
                    .border_style(
                        Style::default()
                            .fg(crate::colors::border())
                            .bg(crate::colors::background()),
                    );
                let inner = block.inner(area);
                block.render(area, buf);

                // Paint inner content background as the normal theme background
                let inner_bg = Style::default().bg(crate::colors::background());
                let _perf_overlay_inner_bg_start = if self.perf_state.enabled {
                    Some(std::time::Instant::now())
                } else {
                    None
                };
                for y in inner.y..inner.y + inner.height {
                    for x in inner.x..inner.x + inner.width {
                        buf[(x, y)].set_style(inner_bg);
                    }
                }
                if let Some(t0) = _perf_overlay_inner_bg_start {
                    let dt = t0.elapsed().as_nanos();
                    let mut p = self.perf_state.stats.borrow_mut();
                    p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                    let cells = (inner.width as u64) * (inner.height as u64);
                    p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                }

                // Split into header tabs and body/footer
                // Add one cell padding around the entire inside of the window
                let padded_inner = inner.inner(ratatui::layout::Margin::new(1, 1));
                let [tabs_area, body_area] = if has_tabs {
                    Layout::vertical([Constraint::Length(2), Constraint::Fill(1)])
                        .areas(padded_inner)
                } else {
                    // Keep a small header row to show file path and counts
                    let [t, b] = Layout::vertical([Constraint::Length(2), Constraint::Fill(1)])
                        .areas(padded_inner);
                    [t, b]
                };

                // Render tabs only if we have more than one file
                if has_tabs {
                    let labels: Vec<String> = overlay
                        .tabs
                        .iter()
                        .map(|(t, _)| format!("  {}  ", t))
                        .collect();
                    let mut constraints: Vec<Constraint> = Vec::new();
                    let mut total: u16 = 0;
                    for label in &labels {
                        let w = (label.chars().count() as u16)
                            .min(tabs_area.width.saturating_sub(total));
                        constraints.push(Constraint::Length(w));
                        total = total.saturating_add(w);
                        if total >= tabs_area.width.saturating_sub(4) {
                            break;
                        }
                    }
                    constraints.push(Constraint::Fill(1));
                    let chunks = Layout::horizontal(constraints).split(tabs_area);
                    // Draw a light bottom border across the entire tabs strip
                    let tabs_bottom_rule = Block::default()
                        .borders(Borders::BOTTOM)
                        .border_style(Style::default().fg(crate::colors::border()));
                    tabs_bottom_rule.render(tabs_area, buf);
                    for i in 0..labels.len() {
                        // last chunk is filler; guard below
                        if i >= chunks.len().saturating_sub(1) {
                            break;
                        }
                        let rect = chunks[i];
                        if rect.width == 0 {
                            continue;
                        }
                        let selected = i == overlay.selected;

                        // Both selected and unselected tabs use the normal background
                        let tab_bg = crate::colors::background();
                        let bg_style = Style::default().bg(tab_bg);
                        for y in rect.y..rect.y + rect.height {
                            for x in rect.x..rect.x + rect.width {
                                buf[(x, y)].set_style(bg_style);
                            }
                        }

                        // Render label at the top line, with padding
                        let label_rect = Rect {
                            x: rect.x + 1,
                            y: rect.y,
                            width: rect.width.saturating_sub(2),
                            height: 1,
                        };
                        let label_style = if selected {
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD)
                        } else {
                            Style::default().fg(crate::colors::text_dim())
                        };
                        let line = ratatui::text::Line::from(ratatui::text::Span::styled(
                            labels[i].clone(),
                            label_style,
                        ));
                        Paragraph::new(RtText::from(vec![line]))
                            .wrap(ratatui::widgets::Wrap { trim: true })
                            .render(label_rect, buf);
                        // Selected tab: thin underline using text_bright under the label width
                        if selected {
                            let label_len = labels[i].chars().count() as u16;
                            let accent_w = label_len.min(rect.width.saturating_sub(2)).max(1);
                            let accent_rect = Rect {
                                x: label_rect.x,
                                y: rect.y + rect.height.saturating_sub(1),
                                width: accent_w,
                                height: 1,
                            };
                            let underline = Block::default()
                                .borders(Borders::BOTTOM)
                                .border_style(Style::default().fg(crate::colors::text_bright()));
                            underline.render(accent_rect, buf);
                        }
                    }
                } else {
                    // Single-file header: show full path with (+adds -dels)
                    if let Some((label, _)) = overlay.tabs.get(overlay.selected) {
                        let header_line = ratatui::text::Line::from(ratatui::text::Span::styled(
                            label.clone(),
                            Style::default()
                                .fg(crate::colors::text())
                                .add_modifier(Modifier::BOLD),
                        ));
                        let para = Paragraph::new(RtText::from(vec![header_line]))
                            .wrap(ratatui::widgets::Wrap { trim: true });
                        ratatui::widgets::Widget::render(para, tabs_area, buf);
                    }
                }

                // Render selected tab with vertical scroll and highlight current diff block
                if let Some((_, blocks)) = overlay.tabs.get(overlay.selected) {
                    // Flatten blocks into lines and record block start indices
                    let mut all_lines: Vec<ratatui::text::Line<'static>> = Vec::new();
                    let mut block_starts: Vec<(usize, usize)> = Vec::new(); // (start_index, len)
                    for b in blocks {
                        let start = all_lines.len();
                        block_starts.push((start, b.lines.len()));
                        all_lines.extend(b.lines.clone());
                    }

                    let raw_skip = overlay
                        .scroll_offsets
                        .get(overlay.selected)
                        .copied()
                        .unwrap_or(0) as usize;
                    let visible_rows = body_area.height as usize;
                    // Cache visible rows so key handler can clamp
                    self.diffs.body_visible_rows.set(body_area.height);
                    let max_off = all_lines.len().saturating_sub(visible_rows.max(1));
                    let skip = raw_skip.min(max_off);
                    let body_inner = body_area;
                    let visible_rows = body_inner.height as usize;

                    // Collect visible slice
                    let end = (skip + visible_rows).min(all_lines.len());
                    let visible = if skip < all_lines.len() {
                        &all_lines[skip..end]
                    } else {
                        &[]
                    };
                    // Fill body background with a slightly lighter paper-like background
                    let bg = crate::colors::background();
                    let paper_color = match bg {
                        ratatui::style::Color::Rgb(r, g, b) => {
                            let alpha = 0.06f32; // subtle lightening toward white
                            let nr = ((r as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            let ng = ((g as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            let nb = ((b as f32) * (1.0 - alpha) + 255.0 * alpha).round() as u8;
                            ratatui::style::Color::Rgb(nr, ng, nb)
                        }
                        _ => bg,
                    };
                    let body_bg = Style::default().bg(paper_color);
                    let _perf_overlay_body_bg2 = if self.perf_state.enabled {
                        Some(std::time::Instant::now())
                    } else {
                        None
                    };
                    for y in body_inner.y..body_inner.y + body_inner.height {
                        for x in body_inner.x..body_inner.x + body_inner.width {
                            buf[(x, y)].set_style(body_bg);
                        }
                    }
                    if let Some(t0) = _perf_overlay_body_bg2 {
                        let dt = t0.elapsed().as_nanos();
                        let mut p = self.perf_state.stats.borrow_mut();
                        p.ns_overlay_body_bg = p.ns_overlay_body_bg.saturating_add(dt);
                        let cells = (body_inner.width as u64) * (body_inner.height as u64);
                        p.cells_overlay_body_bg = p.cells_overlay_body_bg.saturating_add(cells);
                    }
                    let paragraph = Paragraph::new(RtText::from(visible.to_vec()))
                        .wrap(ratatui::widgets::Wrap { trim: false });
                    ratatui::widgets::Widget::render(paragraph, body_inner, buf);

                    // No explicit current-block highlight for a cleaner look

                    // Render confirmation dialog if active
                    if self.diffs.confirm.is_some() {
                        // Centered small box
                        let w = (body_inner.width as i16 - 10).max(20) as u16;
                        let h = 5u16;
                        let x = body_inner.x + (body_inner.width.saturating_sub(w)) / 2;
                        let y = body_inner.y + (body_inner.height.saturating_sub(h)) / 2;
                        let dialog = Rect {
                            x,
                            y,
                            width: w,
                            height: h,
                        };
                        Clear.render(dialog, buf);
                        let dlg_block = Block::default()
                            .borders(Borders::ALL)
                            .title("Confirm Undo")
                            .style(
                                Style::default()
                                    .bg(crate::colors::background())
                                    .fg(crate::colors::text()),
                            )
                            .border_style(Style::default().fg(crate::colors::border()));
                        let dlg_inner = dlg_block.inner(dialog);
                        dlg_block.render(dialog, buf);
                        // Fill dialog inner area with theme background for consistent look
                        let dlg_bg = Style::default().bg(crate::colors::background());
                        for y in dlg_inner.y..dlg_inner.y + dlg_inner.height {
                            for x in dlg_inner.x..dlg_inner.x + dlg_inner.width {
                                buf[(x, y)].set_style(dlg_bg);
                            }
                        }
                        let lines = vec![
                            ratatui::text::Line::from("Are you sure you want to undo this diff?"),
                            ratatui::text::Line::from(
                                "Press Enter to confirm • Esc to cancel".to_string().dim(),
                            ),
                        ];
                        let para = Paragraph::new(RtText::from(lines))
                            .style(
                                Style::default()
                                    .bg(crate::colors::background())
                                    .fg(crate::colors::text()),
                            )
                            .wrap(ratatui::widgets::Wrap { trim: true });
                        ratatui::widgets::Widget::render(para, dlg_inner, buf);
                    }
                }
            }

            // Render help overlay (covering the history area) if active
            if self.settings.overlay.is_none() {
                if let Some(overlay) = &self.help.overlay {
                    // Global scrim across widget
                    let scrim_bg = Style::default()
                        .bg(crate::colors::overlay_scrim())
                        .fg(crate::colors::text_dim());
                    for y in area.y..area.y + area.height {
                        for x in area.x..area.x + area.width {
                            buf[(x, y)].set_style(scrim_bg);
                        }
                    }
                    let padding = 1u16;
                    let window_area = Rect {
                        x: history_area.x + padding,
                        y: history_area.y,
                        width: history_area.width.saturating_sub(padding * 2),
                        height: history_area.height,
                    };
                    Clear.render(window_area, buf);
                    let block = Block::default()
                        .borders(Borders::ALL)
                        .title(ratatui::text::Line::from(vec![
                            ratatui::text::Span::styled(
                                " ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                            ratatui::text::Span::styled(
                                "Guide",
                                Style::default().fg(crate::colors::text()),
                            ),
                            ratatui::text::Span::styled(
                                " ——— ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                            ratatui::text::Span::styled(
                                "Esc",
                                Style::default().fg(crate::colors::text()),
                            ),
                            ratatui::text::Span::styled(
                                " close ",
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ]))
                        .style(Style::default().bg(crate::colors::background()))
                        .border_style(
                            Style::default()
                                .fg(crate::colors::border())
                                .bg(crate::colors::background()),
                        );
                    let inner = block.inner(window_area);
                    block.render(window_area, buf);

                    // Paint inner bg
                    let inner_bg = Style::default().bg(crate::colors::background());
                    for y in inner.y..inner.y + inner.height {
                        for x in inner.x..inner.x + inner.width {
                            buf[(x, y)].set_style(inner_bg);
                        }
                    }

                    // Body area with one cell padding
                    let body = inner.inner(ratatui::layout::Margin::new(1, 1));

                    // Compute visible slice
                    let visible_rows = body.height as usize;
                    self.help.body_visible_rows.set(body.height);
                    let max_off = overlay.lines.len().saturating_sub(visible_rows.max(1));
                    let skip = (overlay.scroll as usize).min(max_off);
                    let end = (skip + visible_rows).min(overlay.lines.len());
                    let visible = if skip < overlay.lines.len() {
                        &overlay.lines[skip..end]
                    } else {
                        &[]
                    };
                    let paragraph = Paragraph::new(RtText::from(visible.to_vec()))
                        .wrap(ratatui::widgets::Wrap { trim: false });
                    ratatui::widgets::Widget::render(paragraph, body, buf);
                }
            }
        }
        // Finalize widget render timing
        if let Some(t0) = _perf_widget_start {
            let dt = t0.elapsed().as_nanos();
            let mut p = self.perf_state.stats.borrow_mut();
            p.ns_widget_render_total = p.ns_widget_render_total.saturating_add(dt);
        }
    }
}

// Coalesce adjacent Read entries of the same file with contiguous ranges in a rendered lines vector.
// Expects the vector to contain a header line at index 0 (e.g., "Read"). Modifies in place.
#[allow(dead_code)]
fn coalesce_read_ranges_in_lines(lines: &mut Vec<ratatui::text::Line<'static>>) {
    use ratatui::style::Modifier;
    use ratatui::style::Style;
    use ratatui::text::Line;
    use ratatui::text::Span;

    if lines.len() <= 1 {
        return;
    }

    // Helper to parse a content line into (filename, start, end, prefix)
    fn parse_read_line(line: &Line<'_>) -> Option<(String, u32, u32, String)> {
        if line.spans.is_empty() {
            return None;
        }
        let prefix = line.spans[0].content.to_string();
        if !(prefix == "└ " || prefix == "  ") {
            return None;
        }
        let rest: String = line
            .spans
            .iter()
            .skip(1)
            .map(|s| s.content.as_ref())
            .collect();
        if let Some(idx) = rest.rfind(" (lines ") {
            let fname = rest[..idx].to_string();
            let tail = &rest[idx + 1..];
            if tail.starts_with("(lines ") && tail.ends_with(")") {
                let inner = &tail[7..tail.len() - 1];
                if let Some((s1, s2)) = inner.split_once(" to ") {
                    if let (Ok(start), Ok(end)) =
                        (s1.trim().parse::<u32>(), s2.trim().parse::<u32>())
                    {
                        return Some((fname, start, end, prefix));
                    }
                }
            }
        }
        None
    }

    // Merge overlapping or touching ranges for the same file, regardless of adjacency.
    let mut i: usize = 0; // works for vectors with or without a header line
    while i < lines.len() {
        let Some((fname_a, mut a1, mut a2, prefix_a)) = parse_read_line(&lines[i]) else {
            i += 1;
            continue;
        };
        let mut k = i + 1;
        while k < lines.len() {
            if let Some((fname_b, b1, b2, _prefix_b)) = parse_read_line(&lines[k]) {
                if fname_b == fname_a {
                    let touch_or_overlap = b1 <= a2.saturating_add(1) && b2.saturating_add(1) >= a1;
                    if touch_or_overlap {
                        a1 = a1.min(b1);
                        a2 = a2.max(b2);
                        let new_spans: Vec<Span<'static>> = vec![
                            Span::styled(
                                prefix_a.clone(),
                                Style::default().add_modifier(Modifier::DIM),
                            ),
                            Span::styled(
                                fname_a.clone(),
                                Style::default().fg(crate::colors::text()),
                            ),
                            Span::styled(
                                format!(" (lines {} to {})", a1, a2),
                                Style::default().fg(crate::colors::text_dim()),
                            ),
                        ];
                        lines[i] = Line::from(new_spans);
                        lines.remove(k);
                        continue;
                    }
                }
            }
            k += 1;
        }
        i += 1;
    }
}
#[derive(Default)]
struct ExecState {
    running_commands: HashMap<ExecCallId, RunningCommand>,
    running_explore_agg_index: Option<usize>,
    // Pairing map for out-of-order exec events. If an ExecEnd arrives before
    // ExecBegin, we stash it briefly and either pair it when Begin arrives or
    // flush it after a short timeout to show a fallback cell.
    pending_exec_ends: HashMap<
        ExecCallId,
        (
            ExecCommandEndEvent,
            code_core::protocol::OrderMeta,
            std::time::Instant,
        ),
    >,
    suppressed_exec_end_call_ids: HashSet<ExecCallId>,
    suppressed_exec_end_order: VecDeque<ExecCallId>,
}

impl ExecState {
    fn suppress_exec_end(&mut self, call_id: ExecCallId) {
        if self.suppressed_exec_end_call_ids.insert(call_id.clone()) {
            self.suppressed_exec_end_order.push_back(call_id);
            const MAX_TRACKED_SUPPRESSED_IDS: usize = 64;
            if self.suppressed_exec_end_order.len() > MAX_TRACKED_SUPPRESSED_IDS {
                if let Some(old) = self.suppressed_exec_end_order.pop_front() {
                    self.suppressed_exec_end_call_ids.remove(&old);
                }
            }
        }
    }

    fn unsuppress_exec_end(&mut self, call_id: &ExecCallId) {
        if self.suppressed_exec_end_call_ids.remove(call_id) {
            self.suppressed_exec_end_order.retain(|cid| cid != call_id);
        }
    }

    fn should_suppress_exec_end(&self, call_id: &ExecCallId) -> bool {
        self.suppressed_exec_end_call_ids.contains(call_id)
    }
}

#[derive(Clone, Copy, Debug)]
pub(super) struct RunningToolEntry {
    order_key: OrderKey,
    fallback_index: usize,
    history_id: Option<HistoryId>,
}

impl RunningToolEntry {
    fn new(order_key: OrderKey, fallback_index: usize) -> Self {
        Self {
            order_key,
            fallback_index,
            history_id: None,
        }
    }

    fn with_history_id(mut self, id: Option<HistoryId>) -> Self {
        self.history_id = id;
        self
    }
}

#[derive(Default)]
struct ToolState {
    running_custom_tools: HashMap<ToolCallId, RunningToolEntry>,
    web_search_sessions: HashMap<String, web_search_sessions::WebSearchTracker>,
    web_search_by_call: HashMap<String, String>,
    web_search_by_order: HashMap<u64, String>,
    running_wait_tools: HashMap<ToolCallId, ExecCallId>,
    running_kill_tools: HashMap<ToolCallId, ExecCallId>,
    image_viewed_calls: HashSet<ToolCallId>,
    browser_sessions: HashMap<String, browser_sessions::BrowserSessionTracker>,
    browser_session_by_call: HashMap<String, String>,
    browser_session_by_order: HashMap<BrowserSessionOrderKey, String>,
    browser_last_key: Option<String>,
    agent_runs: HashMap<String, agent_runs::AgentRunTracker>,
    agent_run_by_call: HashMap<String, String>,
    agent_run_by_order: HashMap<u64, String>,
    agent_run_by_batch: HashMap<String, String>,
    agent_run_by_agent: HashMap<String, String>,
    agent_last_key: Option<String>,
    auto_drive_tracker: Option<auto_drive_cards::AutoDriveTracker>,
}
#[derive(Default)]
struct StreamState {
    current_kind: Option<StreamKind>,
    closed_answer_ids: HashSet<StreamId>,
    closed_reasoning_ids: HashSet<StreamId>,
    seq_answer_final: Option<u64>,
    drop_streaming: bool,
}

#[derive(Default)]
struct LayoutState {
    // Scroll offset from bottom (0 = bottom)
    scroll_offset: u16,
    // Cached max scroll from last render
    last_max_scroll: std::cell::Cell<u16>,
    // Track last viewport height of the history content area
    last_history_viewport_height: std::cell::Cell<u16>,
    // Stateful vertical scrollbar for history view
    vertical_scrollbar_state: std::cell::RefCell<ScrollbarState>,
    // Auto-hide scrollbar timer
    scrollbar_visible_until: std::cell::Cell<Option<std::time::Instant>>,
    // Last effective bottom pane height used by layout (rows)
    last_bottom_reserved_rows: std::cell::Cell<u16>,
    last_frame_height: std::cell::Cell<u16>,
    last_frame_width: std::cell::Cell<u16>,
}

#[derive(Default)]
struct DiffsState {
    session_patch_sets: Vec<HashMap<PathBuf, code_core::protocol::FileChange>>,
    baseline_file_contents: HashMap<PathBuf, String>,
    overlay: Option<DiffOverlay>,
    confirm: Option<DiffConfirm>,
    body_visible_rows: std::cell::Cell<u16>,
}

#[derive(Default)]
struct HelpState {
    overlay: Option<HelpOverlay>,
    body_visible_rows: std::cell::Cell<u16>,
}

#[derive(Default)]
struct SettingsState {
    overlay: Option<SettingsOverlayView>,
}

struct BrowserOverlayState {
    session_key: RefCell<Option<String>>,
    screenshot_index: Cell<usize>,
    action_scroll: Cell<u16>,
    last_action_view_height: Cell<u16>,
    max_action_scroll: Cell<u16>,
}

impl Default for BrowserOverlayState {
    fn default() -> Self {
        Self {
            session_key: RefCell::new(None),
            screenshot_index: Cell::new(0),
            action_scroll: Cell::new(0),
            last_action_view_height: Cell::new(0),
            max_action_scroll: Cell::new(0),
        }
    }
}

impl BrowserOverlayState {
    fn reset(&self) {
        self.screenshot_index.set(0);
        self.action_scroll.set(0);
        self.last_action_view_height.set(0);
        self.max_action_scroll.set(0);
    }

    fn session_key(&self) -> Option<String> {
        self.session_key.borrow().clone()
    }

    fn set_session_key(&self, key: Option<String>) {
        *self.session_key.borrow_mut() = key;
    }

    fn screenshot_index(&self) -> usize {
        self.screenshot_index.get()
    }

    fn set_screenshot_index(&self, index: usize) {
        self.screenshot_index.set(index);
    }

    fn action_scroll(&self) -> u16 {
        self.action_scroll.get()
    }

    fn set_action_scroll(&self, value: u16) {
        self.action_scroll.set(value);
    }

    fn update_action_metrics(&self, height: u16, max_scroll: u16) {
        self.last_action_view_height.set(height);
        self.max_action_scroll.set(max_scroll);
        if self.action_scroll.get() > max_scroll {
            self.action_scroll.set(max_scroll);
        }
    }

    fn last_action_view_height(&self) -> u16 {
        self.last_action_view_height.get()
    }

    fn max_action_scroll(&self) -> u16 {
        self.max_action_scroll.get()
    }
}

#[derive(Default)]
struct LimitsState {
    cached_content: Option<LimitsOverlayContent>,
}

struct HelpOverlay {
    lines: Vec<RtLine<'static>>,
    scroll: u16,
}

impl HelpOverlay {
    fn new(lines: Vec<RtLine<'static>>) -> Self {
        Self { lines, scroll: 0 }
    }
}

struct CommandDisplayLine {
    text: String,
    start: usize,
    end: usize,
}

fn wrap_pending_command_lines(input: &str, width: usize) -> Vec<CommandDisplayLine> {
    if width == 0 {
        return vec![CommandDisplayLine {
            text: String::new(),
            start: 0,
            end: input.len(),
        }];
    }

    let mut lines = Vec::new();
    let mut current = String::new();
    let mut current_width = 0usize;
    let mut current_start = 0usize;

    for (byte_idx, grapheme) in input.grapheme_indices(true) {
        let g_width = UnicodeWidthStr::width(grapheme);
        if current_width + g_width > width && !current.is_empty() {
            lines.push(CommandDisplayLine {
                text: current,
                start: current_start,
                end: byte_idx,
            });
            current = String::new();
            current_width = 0;
            current_start = byte_idx;
        }
        current.push_str(grapheme);
        current_width += g_width;
    }

    let end = input.len();
    lines.push(CommandDisplayLine {
        text: current,
        start: current_start,
        end,
    });

    if lines.is_empty() {
        lines.push(CommandDisplayLine {
            text: String::new(),
            start: 0,
            end: 0,
        });
    }

    lines
}

fn pending_command_box_lines(
    pending: &PendingCommand,
    width: u16,
) -> Option<(Vec<RtLine<'static>>, u16)> {
    if width <= 4 {
        return None;
    }
    let inner_width = width.saturating_sub(2);
    if inner_width <= 4 {
        return None;
    }

    let padded_width = inner_width.saturating_sub(2).max(1) as usize;
    let command_width = inner_width.saturating_sub(4).max(1) as usize;

    const INSTRUCTION_TEXT: &str =
        "Press Enter to run this command. Press Esc to cancel.";
    let instruction_segments = wrap(INSTRUCTION_TEXT, padded_width);
    let instruction_style = Style::default().fg(crate::colors::text_dim());
    let mut lines: Vec<RtLine<'static>> = instruction_segments
        .into_iter()
        .map(|segment| {
            ratatui::text::Line::from(vec![
                ratatui::text::Span::raw(" "),
                ratatui::text::Span::styled(segment.into_owned(), instruction_style),
                ratatui::text::Span::raw(" "),
            ])
        })
        .collect();

    let command_lines = wrap_pending_command_lines(pending.input(), command_width);
    let cursor_line_idx = command_line_index_for_cursor(&command_lines, pending.cursor());
    let prefix_style = Style::default().fg(crate::colors::primary());
    let text_style = Style::default().fg(crate::colors::text());
    let cursor_style = Style::default()
        .bg(crate::colors::primary())
        .fg(crate::colors::background());

    if !lines.is_empty() {
        lines.push(ratatui::text::Line::from(vec![ratatui::text::Span::raw(String::new())]));
    }

    for (idx, line) in command_lines.iter().enumerate() {
        let mut spans = Vec::new();
        spans.push(ratatui::text::Span::raw(" "));
        if idx == 0 {
            spans.push(ratatui::text::Span::styled("$ ", prefix_style));
        } else {
            spans.push(ratatui::text::Span::raw("  "));
        }

        if idx == cursor_line_idx {
            let cursor_offset = pending.cursor().saturating_sub(line.start);
            let cursor_offset = cursor_offset.min(line.text.len());
            let (before, cursor_span, after) = split_line_for_cursor(&line.text, cursor_offset);
            if !before.is_empty() {
                spans.push(ratatui::text::Span::styled(before, text_style));
            }
            match cursor_span {
                Some(token) => spans.push(ratatui::text::Span::styled(token, cursor_style)),
                None => spans.push(ratatui::text::Span::styled(" ", cursor_style)),
            }
            if let Some(after_text) = after {
                if !after_text.is_empty() {
                    spans.push(ratatui::text::Span::styled(after_text, text_style));
                }
            }
        } else {
            spans.push(ratatui::text::Span::styled(line.text.clone(), text_style));
        }

        spans.push(ratatui::text::Span::raw(" "));
        lines.push(ratatui::text::Line::from(spans));
    }

    let height = (lines.len() as u16).saturating_add(2).max(3);
    Some((lines, height))
}

fn command_line_index_for_cursor(lines: &[CommandDisplayLine], cursor: usize) -> usize {
    if lines.is_empty() {
        return 0;
    }
    for (idx, line) in lines.iter().enumerate() {
        if cursor < line.end {
            return idx;
        }
        if cursor == line.end {
            return (idx + 1).min(lines.len().saturating_sub(1));
        }
    }
    lines.len().saturating_sub(1)
}

fn split_line_for_cursor(text: &str, cursor_offset: usize) -> (String, Option<String>, Option<String>) {
    if cursor_offset >= text.len() {
        return (text.to_string(), None, None);
    }

    let (before, remainder) = text.split_at(cursor_offset);
    let mut graphemes = remainder.graphemes(true);
    if let Some(first) = graphemes.next() {
        let after = graphemes.collect::<String>();
        (
            before.to_string(),
            Some(first.to_string()),
            if after.is_empty() { None } else { Some(after) },
        )
    } else {
        (before.to_string(), None, None)
    }
}

fn render_text_box(
    area: Rect,
    title: &str,
    border_color: ratatui::style::Color,
    lines: Vec<RtLine<'static>>,
    buf: &mut Buffer,
) {
    let block = Block::default()
        .borders(Borders::ALL)
        .style(Style::default().bg(crate::colors::background()))
        .border_style(Style::default().fg(border_color))
        .title(ratatui::text::Span::styled(
            title.to_string(),
            Style::default().fg(border_color),
        ));
    block.render(area, buf);

    let inner = area.inner(ratatui::layout::Margin::new(1, 1));
    if inner.height == 0 || inner.width == 0 {
        return;
    }

    let inner_bg = Style::default().bg(crate::colors::background());
    for y in inner.y..inner.y + inner.height {
        for x in inner.x..inner.x + inner.width {
            buf[(x, y)].set_style(inner_bg);
        }
    }

    Paragraph::new(RtText::from(lines))
        .wrap(ratatui::widgets::Wrap { trim: false })
        .render(inner, buf);
}

#[derive(Default)]
struct PerfState {
    enabled: bool,
    stats: RefCell<PerfStats>,
    pending_scroll_rows: Cell<u64>,
}

impl ChatWidget<'_> {
    fn clear_backgrounds_in(&self, buf: &mut Buffer, rect: Rect) {
        for y in rect.y..rect.y.saturating_add(rect.height) {
            for x in rect.x..rect.x.saturating_add(rect.width) {
                let cell = &mut buf[(x, y)];
                // Reset background; keep fg/content as-is
                cell.set_bg(ratatui::style::Color::Reset);
            }
        }
    }
    

    pub(crate) fn set_tui_notifications(&mut self, enabled: bool) {
        let new_state = Notifications::Enabled(enabled);
        self.config.tui.notifications = new_state.clone();
        self.config.tui_notifications = new_state.clone();

        match find_code_home() {
            Ok(home) => {
                match code_core::config::set_tui_notifications(&home, new_state) {
                    Ok(()) => {
                        let msg = format!(
                            "✅ {} TUI notifications",
                            if enabled { "Enabled" } else { "Disabled" }
                        );
                        self.push_background_tail(msg);
                    }
                    Err(err) => {
                        let msg = format!(
                            "⚠️ Failed to persist TUI notifications setting: {}",
                            err
                        );
                        self.history_push_plain_state(history_cell::new_error_event(msg));
                    }
                }
            }
            Err(_) => {
                let msg = format!(
                    "✅ {} TUI notifications (not persisted: CODE_HOME/CODEX_HOME not found)",
                    if enabled { "Enabled" } else { "Disabled" }
                );
                self.push_background_tail(msg);
            }
        }

        self.refresh_settings_overview_rows();
    }

    fn emit_turn_complete_notification(&self, last_agent_message: Option<String>) {
        if !self.should_emit_tui_notification("agent-turn-complete") {
            return;
        }

        let snippet = last_agent_message
            .as_deref()
            .map(Self::notification_snippet)
            .filter(|text| !text.is_empty());

        self.app_event_tx.send(AppEvent::EmitTuiNotification {
            title: "Code".to_string(),
            body: snippet,
        });
    }

    fn should_emit_tui_notification(&self, event: &str) -> bool {
        if self.replay_history_depth > 0 {
            return false;
        }
        self.tui_notification_filter_allows(event)
    }

    fn tui_notification_filter_allows(&self, event: &str) -> bool {
        match &self.config.tui.notifications {
            Notifications::Enabled(enabled) => *enabled,
            Notifications::Custom(entries) => entries
                .iter()
                .any(|entry| entry.eq_ignore_ascii_case(event)),
        }
    }

    fn notification_snippet(input: &str) -> String {
        let collapsed = input
            .split_whitespace()
            .collect::<Vec<_>>()
            .join(" ");

        const LIMIT: usize = 120;
        if collapsed.chars().count() <= LIMIT {
            return collapsed;
        }

        let mut truncated = String::new();
        let mut count = 0usize;
        for ch in collapsed.chars() {
            if count >= LIMIT.saturating_sub(3) {
                break;
            }
            truncated.push(ch);
            count += 1;
        }
        truncated.push_str("...");
        truncated
    }

    pub(crate) fn toggle_mcp_server(&mut self, name: &str, enable: bool) {
        match code_core::config::find_code_home() {
            Ok(home) => match code_core::config::set_mcp_server_enabled(&home, name, enable) {
                Ok(changed) => {
                    if changed {
                        if enable {
                            if let Ok((enabled, _)) = code_core::config::list_mcp_servers(&home) {
                                if let Some((_, cfg)) = enabled.into_iter().find(|(n, _)| n == name)
                                {
                                    self.config.mcp_servers.insert(name.to_string(), cfg);
                                }
                            }
                        } else {
                            self.config.mcp_servers.remove(name);
                        }
                        let msg = format!(
                            "{} MCP server '{}'",
                            if enable { "Enabled" } else { "Disabled" },
                            name
                        );
                        self.push_background_tail(msg);
                    }
                }
                Err(e) => {
                    let msg = format!("Failed to update MCP server '{}': {}", name, e);
                    self.history_push_plain_state(history_cell::new_error_event(msg));
                }
            },
            Err(e) => {
                let msg = format!("Failed to locate CODEX_HOME: {}", e);
                self.history_push_plain_state(history_cell::new_error_event(msg));
            }
        }
    }
}
